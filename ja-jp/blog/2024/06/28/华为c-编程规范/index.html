<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja-jp class=no-js data-theme-init><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=color-scheme content="light dark"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#000000"><style>html{background:Canvas;color:CanvasText}@media(prefers-color-scheme:dark){html{background:#0b0d12;color:#e6e6e6}}html[data-theme-init] *{transition:none!important}</style><script>(function(){const t="td-color-theme",n=localStorage.getItem(t);let e=n||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");e==="auto"&&(e=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"),document.documentElement.setAttribute("data-bs-theme",e)})()</script><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>华为C++编程规范 | jqknono Blogs</title><meta name=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:url" content="https://blog.jqknono.com/ja-jp/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"><meta property="og:site_name" content="jqknono Blogs"><meta property="og:title" content="华为C++编程规范"><meta property="og:description" content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:locale" content="ja_jp"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-28T17:30:10+08:00"><meta property="article:modified_time" content="2024-06-28T17:30:10+08:00"><meta property="article:tag" content="教程"><meta property="article:tag" content="程序员"><meta itemprop=name content="华为C++编程规范"><meta itemprop=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta itemprop=datePublished content="2024-06-28T17:30:10+08:00"><meta itemprop=dateModified content="2024-06-28T17:30:10+08:00"><meta itemprop=wordCount content="4748"><meta itemprop=keywords content="教程,程序员"><meta name=twitter:card content="summary"><meta name=twitter:title content="华为C++编程规范"><meta name=twitter:description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><link rel=preload href=/scss/main.min.06ec545bc526509366973aad911c3b01c355af759b57d6c661642fccb0b80a34.css as=style integrity="sha256-BuxUW8UmUJNmlzqtkRw7AcNVr3WbV9bGYWQvzLC4CjQ=" crossorigin=anonymous><link href=/scss/main.min.06ec545bc526509366973aad911c3b01c355af759b57d6c661642fccb0b80a34.css rel=stylesheet integrity="sha256-BuxUW8UmUJNmlzqtkRw7AcNVr3WbV9bGYWQvzLC4CjQ=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3FFTG72NE"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3FFTG72NE")}</script></head><body class="td-page td-blog"><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="td-navbar-container container-fluid flex-column flex-md-row"><a class=navbar-brand href=/ja-jp/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>jqknono Blogs</span></a><div class="td-navbar-nav-scroll td-navbar-nav-scroll--indicator" id=main_navbar><div class="scroll-indicator scroll-left"></div><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/ja-jp/blog/><i class='fas fa-cube'></i><span>ブログ</span></a></li><li class=nav-item><a class=nav-link href=https://jqknono.com target=_blank rel=noopener><span>About</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class=nav-item><a class=nav-link href=https://github.com/jqknono target=_blank rel=noopener><i class="fab fa-github" aria-hidden=true></i><span>GitHub</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class="nav-item td-navbar__lang-menu"><div class="td-lang-menu dropdown"><a class="nav-link dropdown-toggle td-lang-menu__title" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><span class=td-lang-menu__title-text>日本語</span>
<span class=td-lang-menu__title-code>JA-JP</span></a><ul class=dropdown-menu><li><a class=dropdown-item href=/blog/2024/06/28/huawei-c-programming-specification/>English</a></li><li><a class=dropdown-item href=/zh-tw/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>繁體中文</a></li><li><span class="dropdown-item active">日本語</span></li><li><a class=dropdown-item href=/ko-kr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>한국어</a></li><li><a class=dropdown-item href=/ar-sa/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/de-de/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Deutsch</a></li><li><a class=dropdown-item href=/fr-fr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Français</a></li><li><a class=dropdown-item href=/hi-in/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>हिंदी</a></li><li><a class=dropdown-item href=/es-es/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Español</a></li><li><a class=dropdown-item href=/pt-br/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Português</a></li><li><a class=dropdown-item href=/ru-ru/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Русский</a></li><li><a class=dropdown-item href=/it-it/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Italiano</a></li><li><span class="dropdown-item disabled">Bahasa Indonesia</span></li><li><a class=dropdown-item href=/tr-tr/blog/2024/06/28/huawei-c-programlama-kurallar%C4%B1/>Türkçe</a></li><li><a class=dropdown-item href=/nl-nl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Nederlands</a></li><li><a class=dropdown-item href=/pl-pl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Polski</a></li><li><a class=dropdown-item href=/ar-ae/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/zh-cn/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>简体中文</a></li></ul></div></li><li class="nav-item td-navbar__light-dark-menu"><div class="td-light-dark-menu dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown aria-label="Toggle theme (auto)">
<svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class=dropdown-menu aria-labelledby=bd-theme><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></div></li></ul><div class="scroll-indicator scroll-right"></div></div><div class="d-none d-lg-block td-navbar__search"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main data-bs-spy=scroll data-bs-target=.td-toc data-bs-root-margin="0px 0px -10%"><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="td-sidebar-nav collapse td-sidebar-nav--search-disabled foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-ja-jpblog-li><a href=/ja-jp/blog/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-ja-jpblog><span>ブログ</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260226project-translator-vscode-extension-li><input type=checkbox id=m-ja-jpblog20260226project-translator-vscode-extension-check>
<label for=m-ja-jpblog20260226project-translator-vscode-extension-check><a href=/ja-jp/blog/2026/02/26/project-translator-vscode-extension/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260226project-translator-vscode-extension><span>Project Translator VSCode 拡張機能によるプロジェクト多言語ローカライゼーションの実現</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260217gpt-53-codex-experience-li><input type=checkbox id=m-ja-jpblog20260217gpt-53-codex-experience-check>
<label for=m-ja-jpblog20260217gpt-53-codex-experience-check><a href=/ja-jp/blog/2026/02/17/gpt-53-codex-experience/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260217gpt-53-codex-experience><span>GPT-5.3-Codex 初体験：驚きから理性的評価へ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260211doh-vs-dot-comparison-li><input type=checkbox id=m-ja-jpblog20260211doh-vs-dot-comparison-check>
<label for=m-ja-jpblog20260211doh-vs-dot-comparison-check><a href=/ja-jp/blog/2026/02/11/doh-vs-dot-comparison/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260211doh-vs-dot-comparison><span>DoHとDoTの技術比較分析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260209openrouter-gpt-oss-120b-chinese-bug-li><input type=checkbox id=m-ja-jpblog20260209openrouter-gpt-oss-120b-chinese-bug-check>
<label for=m-ja-jpblog20260209openrouter-gpt-oss-120b-chinese-bug-check><a href=/ja-jp/blog/2026/02/09/openrouter-gpt-oss-120b-chinese-bug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260209openrouter-gpt-oss-120b-chinese-bug><span>OpenRouter gpt-oss-120b モデルが中国語リクエストをサポートしていないデバッグ記録</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260202free-ai-icon-generators-li><input type=checkbox id=m-ja-jpblog20260202free-ai-icon-generators-check>
<label for=m-ja-jpblog20260202free-ai-icon-generators-check><a href=/ja-jp/blog/2026/02/02/free-ai-icon-generators/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260202free-ai-icon-generators><span>無料AIアイコン生成ツールまとめ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260107vibe-coding-cost-formulas-li><input type=checkbox id=m-ja-jpblog20260107vibe-coding-cost-formulas-check>
<label for=m-ja-jpblog20260107vibe-coding-cost-formulas-check><a href=/ja-jp/blog/2026/01/07/vibe-coding-cost-formulas/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260107vibe-coding-cost-formulas><span>Vibe Coding のコスト削減公式と臨界点</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20260101windows-remote-browser-cdp-li><input type=checkbox id=m-ja-jpblog20260101windows-remote-browser-cdp-check>
<label for=m-ja-jpblog20260101windows-remote-browser-cdp-check><a href=/ja-jp/blog/2026/01/01/windows-remote-browser-cdp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20260101windows-remote-browser-cdp><span>Windows 上でリモートブラウザデバッグエントリを構築する</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251223technical-blogs-are-dead-li><input type=checkbox id=m-ja-jpblog20251223technical-blogs-are-dead-check>
<label for=m-ja-jpblog20251223technical-blogs-are-dead-check><a href=/ja-jp/blog/2025/12/23/technical-blogs-are-dead/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251223technical-blogs-are-dead><span>技术ブログは死んだ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251205e68a9ce3818fe382b5e383bce38390e383bce381afe5a4a7e5be97-li><input type=checkbox id=m-ja-jpblog20251205e68a9ce3818fe382b5e383bce38390e383bce381afe5a4a7e5be97-check>
<label for=m-ja-jpblog20251205e68a9ce3818fe382b5e383bce38390e383bce381afe5a4a7e5be97-check><a href=/ja-jp/blog/2025/12/05/%E6%8A%9C%E3%81%8F%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AF%E5%A4%A7%E5%BE%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251205e68a9ce3818fe382b5e383bce38390e383bce381afe5a4a7e5be97><span>抜くサーバーは大得</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251203e382a2e383aae38390e38390e382afe383a9e382a6e38389e381aeesa_pagee6a99fe883bde381afe381bee381a0e4bdbfe794a8e38197e381aae38184e38193e381a8e38292e68ea8e5a5a8-li><input type=checkbox id=m-ja-jpblog20251203e382a2e383aae38390e38390e382afe383a9e382a6e38389e381aeesa_pagee6a99fe883bde381afe381bee381a0e4bdbfe794a8e38197e381aae38184e38193e381a8e38292e68ea8e5a5a8-check>
<label for=m-ja-jpblog20251203e382a2e383aae38390e38390e382afe383a9e382a6e38389e381aeesa_pagee6a99fe883bde381afe381bee381a0e4bdbfe794a8e38197e381aae38184e38193e381a8e38292e68ea8e5a5a8-check><a href=/ja-jp/blog/2025/12/03/%E3%82%A2%E3%83%AA%E3%83%90%E3%83%90%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%81%AEesa_page%E6%A9%9F%E8%83%BD%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E6%8E%A8%E5%A5%A8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251203e382a2e383aae38390e38390e382afe383a9e382a6e38389e381aeesa_pagee6a99fe883bde381afe381bee381a0e4bdbfe794a8e38197e381aae38184e38193e381a8e38292e68ea8e5a5a8><span>アリババクラウドのESA_page機能はまだ使用しないことを推奨</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251202e382a2e383aae38390e38390e381aeesae381a8osse381aee890bde381a8e38197e7a9b4-li><input type=checkbox id=m-ja-jpblog20251202e382a2e383aae38390e38390e381aeesae381a8osse381aee890bde381a8e38197e7a9b4-check>
<label for=m-ja-jpblog20251202e382a2e383aae38390e38390e381aeesae381a8osse381aee890bde381a8e38197e7a9b4-check><a href=/ja-jp/blog/2025/12/02/%E3%82%A2%E3%83%AA%E3%83%90%E3%83%90%E3%81%AEesa%E3%81%A8oss%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251202e382a2e383aae38390e38390e381aeesae381a8osse381aee890bde381a8e38197e7a9b4><span>アリババのESAとOSSの落とし穴</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251202windowse585b1e69c89e38387e38390e38383e382b0chromee696b9e6b395-li><input type=checkbox id=m-ja-jpblog20251202windowse585b1e69c89e38387e38390e38383e382b0chromee696b9e6b395-check>
<label for=m-ja-jpblog20251202windowse585b1e69c89e38387e38390e38383e382b0chromee696b9e6b395-check><a href=/ja-jp/blog/2025/12/02/windows%E5%85%B1%E6%9C%89%E3%83%87%E3%83%90%E3%83%83%E3%82%B0chrome%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251202windowse585b1e69c89e38387e38390e38383e382b0chromee696b9e6b395><span>windows共有デバッグChrome方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251202cloudflaree381afe5ae8ce585a8e381abe4bfa1e9a0bce381a7e3818de3828be3818b-li><input type=checkbox id=m-ja-jpblog20251202cloudflaree381afe5ae8ce585a8e381abe4bfa1e9a0bce381a7e3818de3828be3818b-check>
<label for=m-ja-jpblog20251202cloudflaree381afe5ae8ce585a8e381abe4bfa1e9a0bce381a7e3818de3828be3818b-check><a href=/ja-jp/blog/2025/12/02/cloudflare%E3%81%AF%E5%AE%8C%E5%85%A8%E3%81%AB%E4%BF%A1%E9%A0%BC%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251202cloudflaree381afe5ae8ce585a8e381abe4bfa1e9a0bce381a7e3818de3828be3818b><span>Cloudflareは完全に信頼できるか</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251201e8a696e58a9be694b9e59684e381aee79691e99bb2-li><input type=checkbox id=m-ja-jpblog20251201e8a696e58a9be694b9e59684e381aee79691e99bb2-check>
<label for=m-ja-jpblog20251201e8a696e58a9be694b9e59684e381aee79691e99bb2-check><a href=/ja-jp/blog/2025/12/01/%E8%A6%96%E5%8A%9B%E6%94%B9%E5%96%84%E3%81%AE%E7%96%91%E9%9B%B2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251201e8a696e58a9be694b9e59684e381aee79691e99bb2><span>視力改善の疑雲</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251129e8aeb0e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7bd91e7bb9ce997aee9a298e68e92e69fa5-li><input type=checkbox id=m-ja-jpblog20251129e8aeb0e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7bd91e7bb9ce997aee9a298e68e92e69fa5-check>
<label for=m-ja-jpblog20251129e8aeb0e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7bd91e7bb9ce997aee9a298e68e92e69fa5-check><a href=/ja-jp/blog/2025/11/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%9E%E5%85%B8%E5%9E%8B%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251129e8aeb0e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7bd91e7bb9ce997aee9a298e68e92e69fa5><span>非典型的な家庭ネットワーク問題の1回のトラブルシューティング記録</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251127freebies-you-can-snag-by-owning-a-domain-li><input type=checkbox id=m-ja-jpblog20251127freebies-you-can-snag-by-owning-a-domain-check>
<label for=m-ja-jpblog20251127freebies-you-can-snag-by-owning-a-domain-check><a href=/ja-jp/blog/2025/11/27/freebies-you-can-snag-by-owning-a-domain/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251127freebies-you-can-snag-by-owning-a-domain><span>ドメインを所有することで得られる無料サービス</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251126what-are-low-intelligence-llms-good-for-li><input type=checkbox id=m-ja-jpblog20251126what-are-low-intelligence-llms-good-for-check>
<label for=m-ja-jpblog20251126what-are-low-intelligence-llms-good-for-check><a href=/ja-jp/blog/2025/11/26/what-are-low-intelligence-llms-good-for/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251126what-are-low-intelligence-llms-good-for><span>低知能型LLMに何が適しているか</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251126gpt-5-highe698afe69c80e98082e59088e5bc80e58f91e88085e79a84e6a8a1e59e8b-li><input type=checkbox id=m-ja-jpblog20251126gpt-5-highe698afe69c80e98082e59088e5bc80e58f91e88085e79a84e6a8a1e59e8b-check>
<label for=m-ja-jpblog20251126gpt-5-highe698afe69c80e98082e59088e5bc80e58f91e88085e79a84e6a8a1e59e8b-check><a href=/ja-jp/blog/2025/11/26/gpt-5-high%E6%98%AF%E6%9C%80%E9%80%82%E5%90%88%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%A8%A1%E5%9E%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251126gpt-5-highe698afe69c80e98082e59088e5bc80e58f91e88085e79a84e6a8a1e59e8b><span>gpt-5-highは開発者に最も適したモデルです</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251124llme381aee581bde4babae6849f-li><input type=checkbox id=m-ja-jpblog20251124llme381aee581bde4babae6849f-check>
<label for=m-ja-jpblog20251124llme381aee581bde4babae6849f-check><a href=/ja-jp/blog/2025/11/24/llm%E3%81%AE%E5%81%BD%E4%BA%BA%E6%84%9F/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251124llme381aee581bde4babae6849f><span>llmの偽人感</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251107useful-mouse-key-mapping-share-li><input type=checkbox id=m-ja-jpblog20251107useful-mouse-key-mapping-share-check>
<label for=m-ja-jpblog20251107useful-mouse-key-mapping-share-check><a href=/ja-jp/blog/2025/11/07/useful-mouse-key-mapping-share/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251107useful-mouse-key-mapping-share><span>実用的なマウスキー割り当て共有</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251015traee3818ce382b7e382b9e38386e383a0e38397e383ade383b3e38397e38388e381aee6bc8fe6b4a9e38292e998b2e38190e696b9e6b395-li><input type=checkbox id=m-ja-jpblog20251015traee3818ce382b7e382b9e38386e383a0e38397e383ade383b3e38397e38388e381aee6bc8fe6b4a9e38292e998b2e38190e696b9e6b395-check>
<label for=m-ja-jpblog20251015traee3818ce382b7e382b9e38386e383a0e38397e383ade383b3e38397e38388e381aee6bc8fe6b4a9e38292e998b2e38190e696b9e6b395-check><a href=/ja-jp/blog/2025/10/15/trae%E3%81%8C%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%83%B3%E3%83%97%E3%83%88%E3%81%AE%E6%BC%8F%E6%B4%A9%E3%82%92%E9%98%B2%E3%81%90%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251015traee3818ce382b7e382b9e38386e383a0e38397e383ade383b3e38397e38388e381aee6bc8fe6b4a9e38292e998b2e38190e696b9e6b395><span>Traeがシステムプロンプトの漏洩を防ぐ方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251014e5a4a7e8a68fe6a8a1e383a2e38387e383abe381aee383aae382b3e383bce383abe78e87e68c87e6a899e3818ce9878de8a681e381aae79086e794b1-li><input type=checkbox id=m-ja-jpblog20251014e5a4a7e8a68fe6a8a1e383a2e38387e383abe381aee383aae382b3e383bce383abe78e87e68c87e6a899e3818ce9878de8a681e381aae79086e794b1-check>
<label for=m-ja-jpblog20251014e5a4a7e8a68fe6a8a1e383a2e38387e383abe381aee383aae382b3e383bce383abe78e87e68c87e6a899e3818ce9878de8a681e381aae79086e794b1-check><a href=/ja-jp/blog/2025/10/14/%E5%A4%A7%E8%A6%8F%E6%A8%A1%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E3%83%AA%E3%82%B3%E3%83%BC%E3%83%AB%E7%8E%87%E6%8C%87%E6%A8%99%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%AA%E7%90%86%E7%94%B1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251014e5a4a7e8a68fe6a8a1e383a2e38387e383abe381aee383aae382b3e383bce383abe78e87e68c87e6a899e3818ce9878de8a681e381aae79086e794b1><span>大規模モデルのリコール率指標が重要な理由</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20251009dnse38397e383a9e382a4e38390e382b7e383bce4bf9de8adb7e381a8e383a6e383bce382b6e383bce5838fe998b2e6ada2e688a6e795a5-li><input type=checkbox id=m-ja-jpblog20251009dnse38397e383a9e382a4e38390e382b7e383bce4bf9de8adb7e381a8e383a6e383bce382b6e383bce5838fe998b2e6ada2e688a6e795a5-check>
<label for=m-ja-jpblog20251009dnse38397e383a9e382a4e38390e382b7e383bce4bf9de8adb7e381a8e383a6e383bce382b6e383bce5838fe998b2e6ada2e688a6e795a5-check><a href=/ja-jp/blog/2025/10/09/dns%E3%83%97%E3%83%A9%E3%82%A4%E3%83%90%E3%82%B7%E3%83%BC%E4%BF%9D%E8%AD%B7%E3%81%A8%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E5%83%8F%E9%98%B2%E6%AD%A2%E6%88%A6%E7%95%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20251009dnse38397e383a9e382a4e38390e382b7e383bce4bf9de8adb7e381a8e383a6e383bce382b6e383bce5838fe998b2e6ada2e688a6e795a5><span>DNSプライバシー保護とユーザー像防止戦略</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250930github-spec-kite585ace5bc8fe4bb95e6a798e9a786e58b95e9968be799bae38384e383bce383abe382ade38383e38388e381aee8a9b3e7b4b0e8a7a3e69e90-li><input type=checkbox id=m-ja-jpblog20250930github-spec-kite585ace5bc8fe4bb95e6a798e9a786e58b95e9968be799bae38384e383bce383abe382ade38383e38388e381aee8a9b3e7b4b0e8a7a3e69e90-check>
<label for=m-ja-jpblog20250930github-spec-kite585ace5bc8fe4bb95e6a798e9a786e58b95e9968be799bae38384e383bce383abe382ade38383e38388e381aee8a9b3e7b4b0e8a7a3e69e90-check><a href=/ja-jp/blog/2025/09/30/github-spec-kit%E5%85%AC%E5%BC%8F%E4%BB%95%E6%A7%98%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB%E3%82%AD%E3%83%83%E3%83%88%E3%81%AE%E8%A9%B3%E7%B4%B0%E8%A7%A3%E6%9E%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250930github-spec-kite585ace5bc8fe4bb95e6a798e9a786e58b95e9968be799bae38384e383bce383abe382ade38383e38388e381aee8a9b3e7b4b0e8a7a3e69e90><span>GitHub Spec Kit：公式仕様駆動開発ツールキットの詳細解析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250917claude-code-e382b5e383bce38389e38391e383bce38386e382a3e38399e383b3e38380e383bce4bdbfe794a8e382ace382a4e38389-e6b7b1e5baa6e8a7a3e69e90e381a8e38399e382b9e38388e38397e383a9e382afe38386e382a3e382b9-li><input type=checkbox id=m-ja-jpblog20250917claude-code-e382b5e383bce38389e38391e383bce38386e382a3e38399e383b3e38380e383bce4bdbfe794a8e382ace382a4e38389-e6b7b1e5baa6e8a7a3e69e90e381a8e38399e382b9e38388e38397e383a9e382afe38386e382a3e382b9-check>
<label for=m-ja-jpblog20250917claude-code-e382b5e383bce38389e38391e383bce38386e382a3e38399e383b3e38380e383bce4bdbfe794a8e382ace382a4e38389-e6b7b1e5baa6e8a7a3e69e90e381a8e38399e382b9e38388e38397e383a9e382afe38386e382a3e382b9-check><a href=/ja-jp/blog/2025/09/17/claude-code-%E3%82%B5%E3%83%BC%E3%83%89%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%83%99%E3%83%B3%E3%83%80%E3%83%BC%E4%BD%BF%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E3%81%A8%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250917claude-code-e382b5e383bce38389e38391e383bce38386e382a3e38399e383b3e38380e383bce4bdbfe794a8e382ace382a4e38389-e6b7b1e5baa6e8a7a3e69e90e381a8e38399e382b9e38388e38397e383a9e382afe38386e382a3e382b9><span>Claude Code サードパーティベンダー使用ガイド - 深度解析とベストプラクティス</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250827ddnse38292e4bdbfe794a8e38199e3828be3819fe38281e381abe38389e383a1e382a4e383b3e5908de381afe5bf85e8a681e381a7e38199e3818b-li><input type=checkbox id=m-ja-jpblog20250827ddnse38292e4bdbfe794a8e38199e3828be3819fe38281e381abe38389e383a1e382a4e383b3e5908de381afe5bf85e8a681e381a7e38199e3818b-check>
<label for=m-ja-jpblog20250827ddnse38292e4bdbfe794a8e38199e3828be3819fe38281e381abe38389e383a1e382a4e383b3e5908de381afe5bf85e8a681e381a7e38199e3818b-check><a href=/ja-jp/blog/2025/08/27/ddns%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%90%8D%E3%81%AF%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%81%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250827ddnse38292e4bdbfe794a8e38199e3828be3819fe38281e381abe38389e383a1e382a4e383b3e5908de381afe5bf85e8a681e381a7e38199e3818b><span>DDNSを使用するためにドメイン名は必要ですか？</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250722traee381aee4bdbfe794a8e381abe996a2e38199e3828be7b0a1e58d98e381aae585b1e69c89-li><input type=checkbox id=m-ja-jpblog20250722traee381aee4bdbfe794a8e381abe996a2e38199e3828be7b0a1e58d98e381aae585b1e69c89-check>
<label for=m-ja-jpblog20250722traee381aee4bdbfe794a8e381abe996a2e38199e3828be7b0a1e58d98e381aae585b1e69c89-check><a href=/ja-jp/blog/2025/07/22/trae%E3%81%AE%E4%BD%BF%E7%94%A8%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E7%B0%A1%E5%8D%98%E3%81%AA%E5%85%B1%E6%9C%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250722traee381aee4bdbfe794a8e381abe996a2e38199e3828be7b0a1e58d98e381aae585b1e69c89><span>traeの使用に関する簡単な共有</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250711e383a2e38387e383abe383aae383ace383bce382b5e383bce38393e382b9e381aee694bbe69283e6898be6b395-li><input type=checkbox id=m-ja-jpblog20250711e383a2e38387e383abe383aae383ace383bce382b5e383bce38393e382b9e381aee694bbe69283e6898be6b395-check>
<label for=m-ja-jpblog20250711e383a2e38387e383abe383aae383ace383bce382b5e383bce38393e382b9e381aee694bbe69283e6898be6b395-check><a href=/ja-jp/blog/2025/07/11/%E3%83%A2%E3%83%87%E3%83%AB%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E6%94%BB%E6%92%83%E6%89%8B%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250711e383a2e38387e383abe383aae383ace383bce382b5e383bce38393e382b9e381aee694bbe69283e6898be6b395><span>モデルリレーサービスの攻撃手法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250710e4b8ade7b699e383a2e38387e383abe382b5e383bce38393e382b9e381aee383aae382b9e382af-li><input type=checkbox id=m-ja-jpblog20250710e4b8ade7b699e383a2e38387e383abe382b5e383bce38393e382b9e381aee383aae382b9e382af-check>
<label for=m-ja-jpblog20250710e4b8ade7b699e383a2e38387e383abe382b5e383bce38393e382b9e381aee383aae382b9e382af-check><a href=/ja-jp/blog/2025/07/10/%E4%B8%AD%E7%B6%99%E3%83%A2%E3%83%87%E3%83%AB%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E3%83%AA%E3%82%B9%E3%82%AF/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250710e4b8ade7b699e383a2e38387e383abe382b5e383bce38393e382b9e381aee383aae382b9e382af><span>中継モデルサービスのリスク</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250710adguardhome-e381abe38388e383a9e38395e382a3e38383e382afe58886e589b2e6a99fe883bde38292e8bfbde58aa0-li><input type=checkbox id=m-ja-jpblog20250710adguardhome-e381abe38388e383a9e38395e382a3e38383e382afe58886e589b2e6a99fe883bde38292e8bfbde58aa0-check>
<label for=m-ja-jpblog20250710adguardhome-e381abe38388e383a9e38395e382a3e38383e382afe58886e589b2e6a99fe883bde38292e8bfbde58aa0-check><a href=/ja-jp/blog/2025/07/10/adguardhome-%E3%81%AB%E3%83%88%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E5%88%86%E5%89%B2%E6%A9%9F%E8%83%BD%E3%82%92%E8%BF%BD%E5%8A%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250710adguardhome-e381abe38388e383a9e38395e382a3e38383e382afe58886e589b2e6a99fe883bde38292e8bfbde58aa0><span>AdguardHome にトラフィック分割機能を追加</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250710e38397e383ade382b8e382a7e382afe38388e381aee5a49ae8a880e8aa9ee58c96e381abe981a9e38197e3819fe8a880e8aa9ee381aee981b8e5ae9a-li><input type=checkbox id=m-ja-jpblog20250710e38397e383ade382b8e382a7e382afe38388e381aee5a49ae8a880e8aa9ee58c96e381abe981a9e38197e3819fe8a880e8aa9ee381aee981b8e5ae9a-check>
<label for=m-ja-jpblog20250710e38397e383ade382b8e382a7e382afe38388e381aee5a49ae8a880e8aa9ee58c96e381abe981a9e38197e3819fe8a880e8aa9ee381aee981b8e5ae9a-check><a href=/ja-jp/blog/2025/07/10/%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%A4%9A%E8%A8%80%E8%AA%9E%E5%8C%96%E3%81%AB%E9%81%A9%E3%81%97%E3%81%9F%E8%A8%80%E8%AA%9E%E3%81%AE%E9%81%B8%E5%AE%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250710e38397e383ade382b8e382a7e382afe38388e381aee5a49ae8a880e8aa9ee58c96e381abe981a9e38197e3819fe8a880e8aa9ee381aee981b8e5ae9a><span>プロジェクトの多言語化に適した言語の選定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250709e88fafe782bae38292e5aea2e8a6b3e79a84e381abe8a995e4bea1e38197e381a6e381bfe3828b-li><input type=checkbox id=m-ja-jpblog20250709e88fafe782bae38292e5aea2e8a6b3e79a84e381abe8a995e4bea1e38197e381a6e381bfe3828b-check>
<label for=m-ja-jpblog20250709e88fafe782bae38292e5aea2e8a6b3e79a84e381abe8a995e4bea1e38197e381a6e381bfe3828b-check><a href=/ja-jp/blog/2025/07/09/%E8%8F%AF%E7%82%BA%E3%82%92%E5%AE%A2%E8%A6%B3%E7%9A%84%E3%81%AB%E8%A9%95%E4%BE%A1%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250709e88fafe782bae38292e5aea2e8a6b3e79a84e381abe8a995e4bea1e38197e381a6e381bfe3828b><span>華為を客観的に評価してみる</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250627cursor-e887aae58b95e38387e38390e38383e382b0-li><input type=checkbox id=m-ja-jpblog20250627cursor-e887aae58b95e38387e38390e38383e382b0-check>
<label for=m-ja-jpblog20250627cursor-e887aae58b95e38387e38390e38383e382b0-check><a href=/ja-jp/blog/2025/06/27/cursor-%E8%87%AA%E5%8B%95%E3%83%87%E3%83%90%E3%83%83%E3%82%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250627cursor-e887aae58b95e38387e38390e38383e382b0><span>cursor 自動デバッグ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250625wsl-mirrorede3838de38383e38388e383afe383bce382afe383a2e383bce38389e8a8ade5ae9ae382ace382a4e38389-li><input type=checkbox id=m-ja-jpblog20250625wsl-mirrorede3838de38383e38388e383afe383bce382afe383a2e383bce38389e8a8ade5ae9ae382ace382a4e38389-check>
<label for=m-ja-jpblog20250625wsl-mirrorede3838de38383e38388e383afe383bce382afe383a2e383bce38389e8a8ade5ae9ae382ace382a4e38389-check><a href=/ja-jp/blog/2025/06/25/wsl-mirrored%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%A2%E3%83%BC%E3%83%89%E8%A8%AD%E5%AE%9A%E3%82%AC%E3%82%A4%E3%83%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250625wsl-mirrorede3838de38383e38388e383afe383bce382afe383a2e383bce38389e8a8ade5ae9ae382ace382a4e38389><span>WSL mirroredネットワークモード設定ガイド</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250526windows-sshe383aae383a2e383bce38388e383ade382b0e382a4e383b3-li><input type=checkbox id=m-ja-jpblog20250526windows-sshe383aae383a2e383bce38388e383ade382b0e382a4e383b3-check>
<label for=m-ja-jpblog20250526windows-sshe383aae383a2e383bce38388e383ade382b0e382a4e383b3-check><a href=/ja-jp/blog/2025/05/26/windows-ssh%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%AD%E3%82%B0%E3%82%A4%E3%83%B3/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250526windows-sshe383aae383a2e383bce38388e383ade382b0e382a4e383b3><span>Windows SSHリモートログイン</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250524androide9968be799ba-li><input type=checkbox id=m-ja-jpblog20250524androide9968be799ba-check>
<label for=m-ja-jpblog20250524androide9968be799ba-check><a href=/ja-jp/blog/2025/05/24/android%E9%96%8B%E7%99%BA/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250524androide9968be799ba><span>Android開発</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250425cnamee381a8txte381aee7abb6e59088e381abe38288e3828be8a8bce6988ee69bb8e794b3e8ab8be5958fe9a18c-li><input type=checkbox id=m-ja-jpblog20250425cnamee381a8txte381aee7abb6e59088e381abe38288e3828be8a8bce6988ee69bb8e794b3e8ab8be5958fe9a18c-check>
<label for=m-ja-jpblog20250425cnamee381a8txte381aee7abb6e59088e381abe38288e3828be8a8bce6988ee69bb8e794b3e8ab8be5958fe9a18c-check><a href=/ja-jp/blog/2025/04/25/cname%E3%81%A8txt%E3%81%AE%E7%AB%B6%E5%90%88%E3%81%AB%E3%82%88%E3%82%8B%E8%A8%BC%E6%98%8E%E6%9B%B8%E7%94%B3%E8%AB%8B%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250425cnamee381a8txte381aee7abb6e59088e381abe38288e3828be8a8bce6988ee69bb8e794b3e8ab8be5958fe9a18c><span>CNAMEとTXTの競合による証明書申請問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250330cline-e3818be38289e381aee38397e383ade383b3e38397e38388-e382ace382a4e38389-li><input type=checkbox id=m-ja-jpblog20250330cline-e3818be38289e381aee38397e383ade383b3e38397e38388-e382ace382a4e38389-check>
<label for=m-ja-jpblog20250330cline-e3818be38289e381aee38397e383ade383b3e38397e38388-e382ace382a4e38389-check><a href=/ja-jp/blog/2025/03/30/cline-%E3%81%8B%E3%82%89%E3%81%AE%E3%83%97%E3%83%AD%E3%83%B3%E3%83%97%E3%83%88-%E3%82%AC%E3%82%A4%E3%83%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250330cline-e3818be38289e381aee38397e383ade383b3e38397e38388-e382ace382a4e38389><span>Cline からのプロンプト ガイド</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250327e6809de88083e38384e383bce383ab-li><input type=checkbox id=m-ja-jpblog20250327e6809de88083e38384e383bce383ab-check>
<label for=m-ja-jpblog20250327e6809de88083e38384e383bce383ab-check><a href=/ja-jp/blog/2025/03/27/%E6%80%9D%E8%80%83%E3%83%84%E3%83%BC%E3%83%AB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250327e6809de88083e38384e383bce383ab><span>思考ツール</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250319e3838fe3838be382abe383a0e38292e59b9ee981bfe38199e3828be696b9e6b395-li><input type=checkbox id=m-ja-jpblog20250319e3838fe3838be382abe383a0e38292e59b9ee981bfe38199e3828be696b9e6b395-check>
<label for=m-ja-jpblog20250319e3838fe3838be382abe383a0e38292e59b9ee981bfe38199e3828be696b9e6b395-check><a href=/ja-jp/blog/2025/03/19/%E3%83%8F%E3%83%8B%E3%82%AB%E3%83%A0%E3%82%92%E5%9B%9E%E9%81%BF%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250319e3838fe3838be382abe383a0e38292e59b9ee981bfe38199e3828be696b9e6b395><span>ハニカムを回避する方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250317esae381a7cnamee383a2e383bce38389e381a7e383afe382a4e383abe38389e382abe383bce38389e8a8bce6988ee69bb8e38292e58f96e5be97e38199e3828be696b9e6b395-li><input type=checkbox id=m-ja-jpblog20250317esae381a7cnamee383a2e383bce38389e381a7e383afe382a4e383abe38389e382abe383bce38389e8a8bce6988ee69bb8e38292e58f96e5be97e38199e3828be696b9e6b395-check>
<label for=m-ja-jpblog20250317esae381a7cnamee383a2e383bce38389e381a7e383afe382a4e383abe38389e382abe383bce38389e8a8bce6988ee69bb8e38292e58f96e5be97e38199e3828be696b9e6b395-check><a href=/ja-jp/blog/2025/03/17/esa%E3%81%A7cname%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E3%83%AF%E3%82%A4%E3%83%AB%E3%83%89%E3%82%AB%E3%83%BC%E3%83%89%E8%A8%BC%E6%98%8E%E6%9B%B8%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250317esae381a7cnamee383a2e383bce38389e381a7e383afe382a4e383abe38389e382abe383bce38389e8a8bce6988ee69bb8e38292e58f96e5be97e38199e3828be696b9e6b395><span>ESAでCNAMEモードでワイルドカード証明書を取得する方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250317aie382a2e382b7e382b9e382bfe383b3e38388e381afe7a781e38288e3828ae381afe3828be3818be381abe8b3a2e38184-li><input type=checkbox id=m-ja-jpblog20250317aie382a2e382b7e382b9e382bfe383b3e38388e381afe7a781e38288e3828ae381afe3828be3818be381abe8b3a2e38184-check>
<label for=m-ja-jpblog20250317aie382a2e382b7e382b9e382bfe383b3e38388e381afe7a781e38288e3828ae381afe3828be3818be381abe8b3a2e38184-check><a href=/ja-jp/blog/2025/03/17/ai%E3%82%A2%E3%82%B7%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%88%E3%81%AF%E7%A7%81%E3%82%88%E3%82%8A%E3%81%AF%E3%82%8B%E3%81%8B%E3%81%AB%E8%B3%A2%E3%81%84/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250317aie382a2e382b7e382b9e382bfe383b3e38388e381afe7a781e38288e3828ae381afe3828be3818be381abe8b3a2e38184><span>AIアシスタントは私よりはるかに賢い</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250304github-copilote69c89e69699e383a2e38387e383abe6af94e8bc83-li><input type=checkbox id=m-ja-jpblog20250304github-copilote69c89e69699e383a2e38387e383abe6af94e8bc83-check>
<label for=m-ja-jpblog20250304github-copilote69c89e69699e383a2e38387e383abe6af94e8bc83-check><a href=/ja-jp/blog/2025/03/04/github-copilot%E6%9C%89%E6%96%99%E3%83%A2%E3%83%87%E3%83%AB%E6%AF%94%E8%BC%83/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250304github-copilote69c89e69699e383a2e38387e383abe6af94e8bc83><span>Github Copilot有料モデル比較</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250228github-copilot-agente383a2e383bce38389e4bdbfe794a8e7b58ce9a893e585b1e69c89-li><input type=checkbox id=m-ja-jpblog20250228github-copilot-agente383a2e383bce38389e4bdbfe794a8e7b58ce9a893e585b1e69c89-check>
<label for=m-ja-jpblog20250228github-copilot-agente383a2e383bce38389e4bdbfe794a8e7b58ce9a893e585b1e69c89-check><a href=/ja-jp/blog/2025/02/28/github-copilot-agent%E3%83%A2%E3%83%BC%E3%83%89%E4%BD%BF%E7%94%A8%E7%B5%8C%E9%A8%93%E5%85%B1%E6%9C%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250228github-copilot-agente383a2e383bce38389e4bdbfe794a8e7b58ce9a893e585b1e69c89><span>Github Copilot Agentモード使用経験共有</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250228e38391e38396e383aae38383e382af-ipv6-e38292e38288e3828ae5ae89e585a8e381abe4bdbfe794a8e38199e3828be3819fe38281e381aee38184e3818fe381a4e3818be381aee696b9e6b395-li><input type=checkbox id=m-ja-jpblog20250228e38391e38396e383aae38383e382af-ipv6-e38292e38288e3828ae5ae89e585a8e381abe4bdbfe794a8e38199e3828be3819fe38281e381aee38184e3818fe381a4e3818be381aee696b9e6b395-check>
<label for=m-ja-jpblog20250228e38391e38396e383aae38383e382af-ipv6-e38292e38288e3828ae5ae89e585a8e381abe4bdbfe794a8e38199e3828be3819fe38281e381aee38184e3818fe381a4e3818be381aee696b9e6b395-check><a href=/ja-jp/blog/2025/02/28/%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF-ipv6-%E3%82%92%E3%82%88%E3%82%8A%E5%AE%89%E5%85%A8%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E3%81%AE%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250228e38391e38396e383aae38383e382af-ipv6-e38292e38288e3828ae5ae89e585a8e381abe4bdbfe794a8e38199e3828be3819fe38281e381aee38184e3818fe381a4e3818be381aee696b9e6b395><span>パブリック IPv6 をより安全に使用するためのいくつかの方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250220e5ba83e5918ae38396e383ade38383e382afe381aee696b0e981b8e68a9ee882a2--adguardprivate-li><input type=checkbox id=m-ja-jpblog20250220e5ba83e5918ae38396e383ade38383e382afe381aee696b0e981b8e68a9ee882a2--adguardprivate-check>
<label for=m-ja-jpblog20250220e5ba83e5918ae38396e383ade38383e382afe381aee696b0e981b8e68a9ee882a2--adguardprivate-check><a href=/ja-jp/blog/2025/02/20/%E5%BA%83%E5%91%8A%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E6%96%B0%E9%81%B8%E6%8A%9E%E8%82%A2--adguardprivate/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250220e5ba83e5918ae38396e383ade38383e382afe381aee696b0e981b8e68a9ee882a2--adguardprivate><span>広告ブロックの新選択肢--AdGuardPrivate</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250220curle38292e4bdbfe794a8e38197e381a6dnse7b590e69e9ce38292e58f96e5be97e38199e3828b-li><input type=checkbox id=m-ja-jpblog20250220curle38292e4bdbfe794a8e38197e381a6dnse7b590e69e9ce38292e58f96e5be97e38199e3828b-check>
<label for=m-ja-jpblog20250220curle38292e4bdbfe794a8e38197e381a6dnse7b590e69e9ce38292e58f96e5be97e38199e3828b-check><a href=/ja-jp/blog/2025/02/20/curl%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6dns%E7%B5%90%E6%9E%9C%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250220curle38292e4bdbfe794a8e38197e381a6dnse7b590e69e9ce38292e58f96e5be97e38199e3828b><span>curlを使用してDNS結果を取得する</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250220binge382a4e383b3e382bfe383bce3838ae382b7e383a7e3838ae383abe78988e381aee4bdbfe38184e696b9-li><input type=checkbox id=m-ja-jpblog20250220binge382a4e383b3e382bfe383bce3838ae382b7e383a7e3838ae383abe78988e381aee4bdbfe38184e696b9-check>
<label for=m-ja-jpblog20250220binge382a4e383b3e382bfe383bce3838ae382b7e383a7e3838ae383abe78988e381aee4bdbfe38184e696b9-check><a href=/ja-jp/blog/2025/02/20/bing%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8A%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E7%89%88%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250220binge382a4e383b3e382bfe383bce3838ae382b7e383a7e3838ae383abe78988e381aee4bdbfe38184e696b9><span>Bingインターナショナル版の使い方</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250219e4b880e888ace79a84e381aaddnse382b5e38396e38389e383a1e382a4e383b3e38292e4bdbfe794a8e38199e3828be381a8e99bbbe4bfa1e38396e383ade383bce38389e38390e383b3e38389e382b5e383bce38393e382b9e3818ce58aa3e58c96e38199e3828be58fafe883bde680a7e3818ce38182e3828b-li><input type=checkbox id=m-ja-jpblog20250219e4b880e888ace79a84e381aaddnse382b5e38396e38389e383a1e382a4e383b3e38292e4bdbfe794a8e38199e3828be381a8e99bbbe4bfa1e38396e383ade383bce38389e38390e383b3e38389e382b5e383bce38393e382b9e3818ce58aa3e58c96e38199e3828be58fafe883bde680a7e3818ce38182e3828b-check>
<label for=m-ja-jpblog20250219e4b880e888ace79a84e381aaddnse382b5e38396e38389e383a1e382a4e383b3e38292e4bdbfe794a8e38199e3828be381a8e99bbbe4bfa1e38396e383ade383bce38389e38390e383b3e38389e382b5e383bce38393e382b9e3818ce58aa3e58c96e38199e3828be58fafe883bde680a7e3818ce38182e3828b-check><a href=/ja-jp/blog/2025/02/19/%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AAddns%E3%82%B5%E3%83%96%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%A8%E9%9B%BB%E4%BF%A1%E3%83%96%E3%83%AD%E3%83%BC%E3%83%89%E3%83%90%E3%83%B3%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%8C%E5%8A%A3%E5%8C%96%E3%81%99%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250219e4b880e888ace79a84e381aaddnse382b5e38396e38389e383a1e382a4e383b3e38292e4bdbfe794a8e38199e3828be381a8e99bbbe4bfa1e38396e383ade383bce38389e38390e383b3e38389e382b5e383bce38393e382b9e3818ce58aa3e58c96e38199e3828be58fafe883bde680a7e3818ce38182e3828b><span>一般的なDDnsサブドメインを使用すると、電信ブロードバンドサービスが劣化する可能性がある</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250217e5aeb6e5baade3838de38383e38388e383afe383bce382afe381aee383aae38390e383bce382b9e38397e383ade382ade382b7e381abe996a2e38199e3828be382b3e383b3e38397e383a9e382a4e382a2e383b3e382b9e6a49ce8a88e-li><input type=checkbox id=m-ja-jpblog20250217e5aeb6e5baade3838de38383e38388e383afe383bce382afe381aee383aae38390e383bce382b9e38397e383ade382ade382b7e381abe996a2e38199e3828be382b3e383b3e38397e383a9e382a4e382a2e383b3e382b9e6a49ce8a88e-check>
<label for=m-ja-jpblog20250217e5aeb6e5baade3838de38383e38388e383afe383bce382afe381aee383aae38390e383bce382b9e38397e383ade382ade382b7e381abe996a2e38199e3828be382b3e383b3e38397e383a9e382a4e382a2e383b3e382b9e6a49ce8a88e-check><a href=/ja-jp/blog/2025/02/17/%E5%AE%B6%E5%BA%AD%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AE%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%97%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%82%B9%E6%A4%9C%E8%A8%8E/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250217e5aeb6e5baade3838de38383e38388e383afe383bce382afe381aee383aae38390e383bce382b9e38397e383ade382ade382b7e381abe996a2e38199e3828be382b3e383b3e38397e383a9e382a4e382a2e383b3e382b9e6a49ce8a88e><span>家庭ネットワークのリバースプロキシに関するコンプライアンス検討</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20250117personal-domain-security-practices-li><input type=checkbox id=m-ja-jpblog20250117personal-domain-security-practices-check>
<label for=m-ja-jpblog20250117personal-domain-security-practices-check><a href=/ja-jp/blog/2025/01/17/personal-domain-security-practices/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20250117personal-domain-security-practices><span>個人ドメインセキュリティ実践：スキャン攻撃から防护戦略まで</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241231vpse381aee4ba88e7b484e383a1e383a2e383aae38292e8a7a3e694bee38199e3828b-li><input type=checkbox id=m-ja-jpblog20241231vpse381aee4ba88e7b484e383a1e383a2e383aae38292e8a7a3e694bee38199e3828b-check>
<label for=m-ja-jpblog20241231vpse381aee4ba88e7b484e383a1e383a2e383aae38292e8a7a3e694bee38199e3828b-check><a href=/ja-jp/blog/2024/12/31/vps%E3%81%AE%E4%BA%88%E7%B4%84%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%92%E8%A7%A3%E6%94%BE%E3%81%99%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241231vpse381aee4ba88e7b484e383a1e383a2e383aae38292e8a7a3e694bee38199e3828b><span>VPSの予約メモリを解放する</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241213e69f90e38399e383b3e38380e383bce381aednse38396e383ade38383e382ade383b3e382b0e998b2e6ada2e7ad96-li><input type=checkbox id=m-ja-jpblog20241213e69f90e38399e383b3e38380e383bce381aednse38396e383ade38383e382ade383b3e382b0e998b2e6ada2e7ad96-check>
<label for=m-ja-jpblog20241213e69f90e38399e383b3e38380e383bce381aednse38396e383ade38383e382ade383b3e382b0e998b2e6ada2e7ad96-check><a href=/ja-jp/blog/2024/12/13/%E6%9F%90%E3%83%99%E3%83%B3%E3%83%80%E3%83%BC%E3%81%AEdns%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0%E9%98%B2%E6%AD%A2%E7%AD%96/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241213e69f90e38399e383b3e38380e383bce381aednse38396e383ade38383e382ade383b3e382b0e998b2e6ada2e7ad96><span>某ベンダーのDNSブロッキング防止策</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241205e5beaee4bfa1e8aaade69bb8e887aae58b95e38381e382a7e38383e382afe382a4e383b3e887aae58b95e8aaade69bb8e69982e99693e5a297e58aa0e38384e383bce383ab-li><input type=checkbox id=m-ja-jpblog20241205e5beaee4bfa1e8aaade69bb8e887aae58b95e38381e382a7e38383e382afe382a4e383b3e887aae58b95e8aaade69bb8e69982e99693e5a297e58aa0e38384e383bce383ab-check>
<label for=m-ja-jpblog20241205e5beaee4bfa1e8aaade69bb8e887aae58b95e38381e382a7e38383e382afe382a4e383b3e887aae58b95e8aaade69bb8e69982e99693e5a297e58aa0e38384e383bce383ab-check><a href=/ja-jp/blog/2024/12/05/%E5%BE%AE%E4%BF%A1%E8%AA%AD%E6%9B%B8%E8%87%AA%E5%8B%95%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF%E3%82%A4%E3%83%B3%E8%87%AA%E5%8B%95%E8%AA%AD%E6%9B%B8%E6%99%82%E9%96%93%E5%A2%97%E5%8A%A0%E3%83%84%E3%83%BC%E3%83%AB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241205e5beaee4bfa1e8aaade69bb8e887aae58b95e38381e382a7e38383e382afe382a4e383b3e887aae58b95e8aaade69bb8e69982e99693e5a297e58aa0e38384e383bce383ab><span>微信読書自動チェックイン・自動読書時間増加ツール</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241203e4bd8ee383aae382b9e382afe382afe383ade383bce383aae383b3e382b0e381aee688a6e795a5e79a84e58886e69e90e58f8ee79b8ae381a8e382a2e38397e383ade383bce38381-li><input type=checkbox id=m-ja-jpblog20241203e4bd8ee383aae382b9e382afe382afe383ade383bce383aae383b3e382b0e381aee688a6e795a5e79a84e58886e69e90e58f8ee79b8ae381a8e382a2e38397e383ade383bce38381-check>
<label for=m-ja-jpblog20241203e4bd8ee383aae382b9e382afe382afe383ade383bce383aae383b3e382b0e381aee688a6e795a5e79a84e58886e69e90e58f8ee79b8ae381a8e382a2e38397e383ade383bce38381-check><a href=/ja-jp/blog/2024/12/03/%E4%BD%8E%E3%83%AA%E3%82%B9%E3%82%AF%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E6%88%A6%E7%95%A5%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%8E%E7%9B%8A%E3%81%A8%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241203e4bd8ee383aae382b9e382afe382afe383ade383bce383aae383b3e382b0e381aee688a6e795a5e79a84e58886e69e90e58f8ee79b8ae381a8e382a2e38397e383ade383bce38381><span>低リスククローリングの戦略的分析：収益とアプローチ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241118e79c81e99bbbe58a9be381aee3819fe38281e381abe78bace7ab8bgpue38292e382aae38395e381abe38199e3828b-li><input type=checkbox id=m-ja-jpblog20241118e79c81e99bbbe58a9be381aee3819fe38281e381abe78bace7ab8bgpue38292e382aae38395e381abe38199e3828b-check>
<label for=m-ja-jpblog20241118e79c81e99bbbe58a9be381aee3819fe38281e381abe78bace7ab8bgpue38292e382aae38395e381abe38199e3828b-check><a href=/ja-jp/blog/2024/11/18/%E7%9C%81%E9%9B%BB%E5%8A%9B%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB%E7%8B%AC%E7%AB%8Bgpu%E3%82%92%E3%82%AA%E3%83%95%E3%81%AB%E3%81%99%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241118e79c81e99bbbe58a9be381aee3819fe38281e381abe78bace7ab8bgpue38292e382aae38395e381abe38199e3828b><span>省電力のために独立GPUをオフにする</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241115google-e7bfbbe8a8b3-api-e381aee4bdbfe794a8e38381e383a5e383bce38388e383aae382a2e383ab-li><input type=checkbox id=m-ja-jpblog20241115google-e7bfbbe8a8b3-api-e381aee4bdbfe794a8e38381e383a5e383bce38388e383aae382a2e383ab-check>
<label for=m-ja-jpblog20241115google-e7bfbbe8a8b3-api-e381aee4bdbfe794a8e38381e383a5e383bce38388e383aae382a2e383ab-check><a href=/ja-jp/blog/2024/11/15/google-%E7%BF%BB%E8%A8%B3-api-%E3%81%AE%E4%BD%BF%E7%94%A8%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241115google-e7bfbbe8a8b3-api-e381aee4bdbfe794a8e38381e383a5e383bce38388e383aae382a2e383ab><span>Google 翻訳 API の使用チュートリアル</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241112e38396e383ade382b0e381a7e5808be4babae68385e5a0b1e38292e6bc8fe38289e38195e381aae38184e696b9e6b395-li><input type=checkbox id=m-ja-jpblog20241112e38396e383ade382b0e381a7e5808be4babae68385e5a0b1e38292e6bc8fe38289e38195e381aae38184e696b9e6b395-check>
<label for=m-ja-jpblog20241112e38396e383ade382b0e381a7e5808be4babae68385e5a0b1e38292e6bc8fe38289e38195e381aae38184e696b9e6b395-check><a href=/ja-jp/blog/2024/11/12/%E3%83%96%E3%83%AD%E3%82%B0%E3%81%A7%E5%80%8B%E4%BA%BA%E6%83%85%E5%A0%B1%E3%82%92%E6%BC%8F%E3%82%89%E3%81%95%E3%81%AA%E3%81%84%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241112e38396e383ade382b0e381a7e5808be4babae68385e5a0b1e38292e6bc8fe38289e38195e381aae38184e696b9e6b395><span>ブログで個人情報を漏らさない方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20241106windows-server-2019e3818ce995b7e69c9fe99693e5ae9fe8a18ce38195e3828ce381a6e38184e3828be381a8e3818de381abipv6e3818ce58887e696ade38195e3828ce3828be5958fe9a18c-li><input type=checkbox id=m-ja-jpblog20241106windows-server-2019e3818ce995b7e69c9fe99693e5ae9fe8a18ce38195e3828ce381a6e38184e3828be381a8e3818de381abipv6e3818ce58887e696ade38195e3828ce3828be5958fe9a18c-check>
<label for=m-ja-jpblog20241106windows-server-2019e3818ce995b7e69c9fe99693e5ae9fe8a18ce38195e3828ce381a6e38184e3828be381a8e3818de381abipv6e3818ce58887e696ade38195e3828ce3828be5958fe9a18c-check><a href=/ja-jp/blog/2024/11/06/windows-server-2019%E3%81%8C%E9%95%B7%E6%9C%9F%E9%96%93%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%ABipv6%E3%81%8C%E5%88%87%E6%96%AD%E3%81%95%E3%82%8C%E3%82%8B%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20241106windows-server-2019e3818ce995b7e69c9fe99693e5ae9fe8a18ce38195e3828ce381a6e38184e3828be381a8e3818de381abipv6e3818ce58887e696ade38195e3828ce3828be5958fe9a18c><span>Windows Server 2019が長期間実行されているときにIPv6が切断される問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628snort-li><input type=checkbox id=m-ja-jpblog20240628snort-check>
<label for=m-ja-jpblog20240628snort-check><a href=/ja-jp/blog/2024/06/28/snort/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628snort><span>snort</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628linuxe5b08ee8a6a7-li><input type=checkbox id=m-ja-jpblog20240628linuxe5b08ee8a6a7-check>
<label for=m-ja-jpblog20240628linuxe5b08ee8a6a7-check><a href=/ja-jp/blog/2024/06/28/linux%E5%B0%8E%E8%A6%A7/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628linuxe5b08ee8a6a7><span>linux導覧</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e382b5e383bce38389e38391e383bce38386e382a3e383a9e382a4e38396e383a9e383aae381aee890bde381a8e38197e7a9b4-li><input type=checkbox id=m-ja-jpblog20240628e382b5e383bce38389e38391e383bce38386e382a3e383a9e382a4e38396e383a9e383aae381aee890bde381a8e38197e7a9b4-check>
<label for=m-ja-jpblog20240628e382b5e383bce38389e38391e383bce38386e382a3e383a9e382a4e38396e383a9e383aae381aee890bde381a8e38197e7a9b4-check><a href=/ja-jp/blog/2024/06/28/%E3%82%B5%E3%83%BC%E3%83%89%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e382b5e383bce38389e38391e383bce38386e382a3e383a9e382a4e38396e383a9e383aae381aee890bde381a8e38197e7a9b4><span>サードパーティライブラリの落とし穴</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e696b9e6a188e8aebee8aea1e6a8a1e69dbf-li><input type=checkbox id=m-ja-jpblog20240628e696b9e6a188e8aebee8aea1e6a8a1e69dbf-check>
<label for=m-ja-jpblog20240628e696b9e6a188e8aebee8aea1e6a8a1e69dbf-check><a href=/ja-jp/blog/2024/06/28/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e696b9e6a188e8aebee8aea1e6a8a1e69dbf><span>方案设计模板</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e6a78be69687e8a68fe58987-li><input type=checkbox id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e6a78be69687e8a68fe58987-check>
<label for=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e6a78be69687e8a68fe58987-check><a href=/ja-jp/blog/2024/06/28/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E6%A7%8B%E6%96%87%E8%A6%8F%E5%89%87/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e6a78be69687e8a68fe58987><span>コマンドライン構文規則</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e3839ee3838be383a5e382a2e383abe381a7e381aee8a792e68bace5bca7e381aee6848fe591b3-li><input type=checkbox id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e3839ee3838be383a5e382a2e383abe381a7e381aee8a792e68bace5bca7e381aee6848fe591b3-check>
<label for=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e3839ee3838be383a5e382a2e383abe381a7e381aee8a792e68bace5bca7e381aee6848fe591b3-check><a href=/ja-jp/blog/2024/06/28/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%9E%E3%83%8B%E3%83%A5%E3%82%A2%E3%83%AB%E3%81%A7%E3%81%AE%E8%A7%92%E6%8B%AC%E5%BC%A7%E3%81%AE%E6%84%8F%E5%91%B3/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e382b3e3839ee383b3e38389e383a9e382a4e383b3e3839ee3838be383a5e382a2e383abe381a7e381aee8a792e68bace5bca7e381aee6848fe591b3><span>コマンドラインマニュアルでの角括弧の意味</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-ja-jpblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-li><input type=checkbox id=m-ja-jpblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check checked>
<label for=m-ja-jpblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check><a href=/ja-jp/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83><span class=td-sidebar-nav-active-item>华为C++编程规范</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e4b8ade59bbde794b5e4bfa1ipv6e381aee38184e3818fe381a4e3818be381aee789b9e5beb4-li><input type=checkbox id=m-ja-jpblog20240628e4b8ade59bbde794b5e4bfa1ipv6e381aee38184e3818fe381a4e3818be381aee789b9e5beb4-check>
<label for=m-ja-jpblog20240628e4b8ade59bbde794b5e4bfa1ipv6e381aee38184e3818fe381a4e3818be381aee789b9e5beb4-check><a href=/ja-jp/blog/2024/06/28/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1ipv6%E3%81%AE%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E3%81%AE%E7%89%B9%E5%BE%B4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e4b8ade59bbde794b5e4bfa1ipv6e381aee38184e3818fe381a4e3818be381aee789b9e5beb4><span>中国电信IPv6のいくつかの特徴</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628tcp-e381aee88083e38188e38292-udp-e381abe5bd93e381a6e381afe38281e3828be381b9e3818de381a7e381afe381aae38184e79086e794b1-li><input type=checkbox id=m-ja-jpblog20240628tcp-e381aee88083e38188e38292-udp-e381abe5bd93e381a6e381afe38281e3828be381b9e3818de381a7e381afe381aae38184e79086e794b1-check>
<label for=m-ja-jpblog20240628tcp-e381aee88083e38188e38292-udp-e381abe5bd93e381a6e381afe38281e3828be381b9e3818de381a7e381afe381aae38184e79086e794b1-check><a href=/ja-jp/blog/2024/06/28/tcp-%E3%81%AE%E8%80%83%E3%81%88%E3%82%92-udp-%E3%81%AB%E5%BD%93%E3%81%A6%E3%81%AF%E3%82%81%E3%82%8B%E3%81%B9%E3%81%8D%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E7%90%86%E7%94%B1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628tcp-e381aee88083e38188e38292-udp-e381abe5bd93e381a6e381afe38281e3828be381b9e3818de381a7e381afe381aae38184e79086e794b1><span>TCP の考えを UDP に当てはめるべきではない理由</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628openvpne3838de38383e38388e383afe383bce382afe4b88de9809a-li><input type=checkbox id=m-ja-jpblog20240628openvpne3838de38383e38388e383afe383bce382afe4b88de9809a-check>
<label for=m-ja-jpblog20240628openvpne3838de38383e38388e383afe383bce382afe4b88de9809a-check><a href=/ja-jp/blog/2024/06/28/openvpn%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E4%B8%8D%E9%80%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628openvpne3838de38383e38388e383afe383bce382afe4b88de9809a><span>openvpnネットワーク不通</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse3838de38383e38388e383afe383bce382afe381aee79086e8a7a3_wfp-li><input type=checkbox id=m-ja-jpblog20240628windowse3838de38383e38388e383afe383bce382afe381aee79086e8a7a3_wfp-check>
<label for=m-ja-jpblog20240628windowse3838de38383e38388e383afe383bce382afe381aee79086e8a7a3_wfp-check><a href=/ja-jp/blog/2024/06/28/windows%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AE%E7%90%86%E8%A7%A3_wfp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse3838de38383e38388e383afe383bce382afe381aee79086e8a7a3_wfp><span>Windowsネットワークの理解_WFP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse382a4e38399e383b3e38388e38388e383ace383bce382b9e381aee79086e8a7a3_etw-li><input type=checkbox id=m-ja-jpblog20240628windowse382a4e38399e383b3e38388e38388e383ace383bce382b9e381aee79086e8a7a3_etw-check>
<label for=m-ja-jpblog20240628windowse382a4e38399e383b3e38388e38388e383ace383bce382b9e381aee79086e8a7a3_etw-check><a href=/ja-jp/blog/2024/06/28/windows%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9%E3%81%AE%E7%90%86%E8%A7%A3_etw/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse382a4e38399e383b3e38388e38388e383ace383bce382b9e381aee79086e8a7a3_etw><span>Windowsイベントトレースの理解_ETW</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628wireguarde8a8ade5ae9a-li><input type=checkbox id=m-ja-jpblog20240628wireguarde8a8ade5ae9a-check>
<label for=m-ja-jpblog20240628wireguarde8a8ade5ae9a-check><a href=/ja-jp/blog/2024/06/28/wireguard%E8%A8%AD%E5%AE%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628wireguarde8a8ade5ae9a><span>wireguard設定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse38396e383ade38383e382afe3838de38383e38388e383afe383bce382afe38388e383a9e38395e382a3e38383e382afe381aee58f96e5be97-li><input type=checkbox id=m-ja-jpblog20240628windowse38396e383ade38383e382afe3838de38383e38388e383afe383bce382afe38388e383a9e38395e382a3e38383e382afe381aee58f96e5be97-check>
<label for=m-ja-jpblog20240628windowse38396e383ade38383e382afe3838de38383e38388e383afe383bce382afe38388e383a9e38395e382a3e38383e382afe381aee58f96e5be97-check><a href=/ja-jp/blog/2024/06/28/windows%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%88%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%81%AE%E5%8F%96%E5%BE%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse38396e383ade38383e382afe3838de38383e38388e383afe383bce382afe38388e383a9e38395e382a3e38383e382afe381aee58f96e5be97><span>Windowsブロックネットワークトラフィックの取得</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse38395e382a1e382a4e382a2e382a6e382a9e383bce383abe7aea1e79086-netsh-li><input type=checkbox id=m-ja-jpblog20240628windowse38395e382a1e382a4e382a2e382a6e382a9e383bce383abe7aea1e79086-netsh-check>
<label for=m-ja-jpblog20240628windowse38395e382a1e382a4e382a2e382a6e382a9e383bce383abe7aea1e79086-netsh-check><a href=/ja-jp/blog/2024/06/28/windows%E3%83%95%E3%82%A1%E3%82%A4%E3%82%A2%E3%82%A6%E3%82%A9%E3%83%BC%E3%83%AB%E7%AE%A1%E7%90%86-netsh/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse38395e382a1e382a4e382a2e382a6e382a9e383bce383abe7aea1e79086-netsh><span>Windowsファイアウォール管理-netsh</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse996a2e980a3e383aae382bde383bce382b9-li><input type=checkbox id=m-ja-jpblog20240628windowse996a2e980a3e383aae382bde383bce382b9-check>
<label for=m-ja-jpblog20240628windowse996a2e980a3e383aae382bde383bce382b9-check><a href=/ja-jp/blog/2024/06/28/windows%E9%96%A2%E9%80%A3%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse996a2e980a3e383aae382bde383bce382b9><span>Windows関連リソース</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628windowse5b08ee8a6a7-li><input type=checkbox id=m-ja-jpblog20240628windowse5b08ee8a6a7-check>
<label for=m-ja-jpblog20240628windowse5b08ee8a6a7-check><a href=/ja-jp/blog/2024/06/28/windows%E5%B0%8E%E8%A6%A7/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628windowse5b08ee8a6a7><span>Windows導覧</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628window-message-li><input type=checkbox id=m-ja-jpblog20240628window-message-check>
<label for=m-ja-jpblog20240628window-message-check><a href=/ja-jp/blog/2024/06/28/window-message/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628window-message><span>window-message</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628win-to-go-li><input type=checkbox id=m-ja-jpblog20240628win-to-go-check>
<label for=m-ja-jpblog20240628win-to-go-check><a href=/ja-jp/blog/2024/06/28/win-to-go/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628win-to-go><span>Win-to-go</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e4bbaee683b3e383a1e383a2e383aae38387e382a3e382b9e382afe381aee8a8ade5ae9a-li><input type=checkbox id=m-ja-jpblog20240628e4bbaee683b3e383a1e383a2e383aae38387e382a3e382b9e382afe381aee8a8ade5ae9a-check>
<label for=m-ja-jpblog20240628e4bbaee683b3e383a1e383a2e383aae38387e382a3e382b9e382afe381aee8a8ade5ae9a-check><a href=/ja-jp/blog/2024/06/28/%E4%BB%AE%E6%83%B3%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E8%A8%AD%E5%AE%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e4bbaee683b3e383a1e383a2e383aae38387e382a3e382b9e382afe381aee8a8ade5ae9a><span>仮想メモリディスクの設定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628wsl-li><input type=checkbox id=m-ja-jpblog20240628wsl-check>
<label for=m-ja-jpblog20240628wsl-check><a href=/ja-jp/blog/2024/06/28/wsl/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628wsl><span>wsl</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628letsencrypte381aee8a8bce6988ee69bb8e794b3e8ab8be588b6e99990-li><input type=checkbox id=m-ja-jpblog20240628letsencrypte381aee8a8bce6988ee69bb8e794b3e8ab8be588b6e99990-check>
<label for=m-ja-jpblog20240628letsencrypte381aee8a8bce6988ee69bb8e794b3e8ab8be588b6e99990-check><a href=/ja-jp/blog/2024/06/28/letsencrypt%E3%81%AE%E8%A8%BC%E6%98%8E%E6%9B%B8%E7%94%B3%E8%AB%8B%E5%88%B6%E9%99%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628letsencrypte381aee8a8bce6988ee69bb8e794b3e8ab8be588b6e99990><span>letsencryptの証明書申請制限</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e7b0a1e69893-server-client-e382b3e383bce38389-li><input type=checkbox id=m-ja-jpblog20240628e7b0a1e69893-server-client-e382b3e383bce38389-check>
<label for=m-ja-jpblog20240628e7b0a1e69893-server-client-e382b3e383bce38389-check><a href=/ja-jp/blog/2024/06/28/%E7%B0%A1%E6%98%93-server-client-%E3%82%B3%E3%83%BC%E3%83%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e7b0a1e69893-server-client-e382b3e383bce38389><span>簡易 server-client コード</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628calico-exploration-li><input type=checkbox id=m-ja-jpblog20240628calico-exploration-check>
<label for=m-ja-jpblog20240628calico-exploration-check><a href=/ja-jp/blog/2024/06/28/calico-exploration/ title="Calico ネットワークプラグインの探索と実践" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628calico-exploration><span>Calico 探索</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628dockere7b4b9e4bb8b-li><input type=checkbox id=m-ja-jpblog20240628dockere7b4b9e4bb8b-check>
<label for=m-ja-jpblog20240628dockere7b4b9e4bb8b-check><a href=/ja-jp/blog/2024/06/28/docker%E7%B4%B9%E4%BB%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628dockere7b4b9e4bb8b><span>docker紹介</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628copilote4bdbfe794a8e585a5e99680-li><input type=checkbox id=m-ja-jpblog20240628copilote4bdbfe794a8e585a5e99680-check>
<label for=m-ja-jpblog20240628copilote4bdbfe794a8e585a5e99680-check><a href=/ja-jp/blog/2024/06/28/copilot%E4%BD%BF%E7%94%A8%E5%85%A5%E9%96%80/ title=Copilot使用入門 class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628copilote4bdbfe794a8e585a5e99680><span>Copilotの使い方共有</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628chatgpt-user-guide-li><input type=checkbox id=m-ja-jpblog20240628chatgpt-user-guide-check>
<label for=m-ja-jpblog20240628chatgpt-user-guide-check><a href=/ja-jp/blog/2024/06/28/chatgpt-user-guide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628chatgpt-user-guide><span>ChatGPT 使用ガイド</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e4bfa1e9a0bce381a7e3818de3828be38387e382b6e382a4e383b3-li><input type=checkbox id=m-ja-jpblog20240628e4bfa1e9a0bce381a7e3818de3828be38387e382b6e382a4e383b3-check>
<label for=m-ja-jpblog20240628e4bfa1e9a0bce381a7e3818de3828be38387e382b6e382a4e383b3-check><a href=/ja-jp/blog/2024/06/28/%E4%BF%A1%E9%A0%BC%E3%81%A7%E3%81%8D%E3%82%8B%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e4bfa1e9a0bce381a7e3818de3828be38387e382b6e382a4e383b3><span>信頼できるデザイン</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e38395e382a1e383bce382a6e382a7e382a4e381aee4bfa1e9a0bce680a7e6a682e5bfb5-li><input type=checkbox id=m-ja-jpblog20240628e38395e382a1e383bce382a6e382a7e382a4e381aee4bfa1e9a0bce680a7e6a682e5bfb5-check>
<label for=m-ja-jpblog20240628e38395e382a1e383bce382a6e382a7e382a4e381aee4bfa1e9a0bce680a7e6a682e5bfb5-check><a href=/ja-jp/blog/2024/06/28/%E3%83%95%E3%82%A1%E3%83%BC%E3%82%A6%E3%82%A7%E3%82%A4%E3%81%AE%E4%BF%A1%E9%A0%BC%E6%80%A7%E6%A6%82%E5%BF%B5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e38395e382a1e383bce382a6e382a7e382a4e381aee4bfa1e9a0bce680a7e6a682e5bfb5><span>ファーウェイの信頼性概念</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628e88fafe782bae7a4bee58685e3838de38383e38388e383afe383bce382afe382bbe382ade383a5e383aae38386e382a3e58886e69e90-li><input type=checkbox id=m-ja-jpblog20240628e88fafe782bae7a4bee58685e3838de38383e38388e383afe383bce382afe382bbe382ade383a5e383aae38386e382a3e58886e69e90-check>
<label for=m-ja-jpblog20240628e88fafe782bae7a4bee58685e3838de38383e38388e383afe383bce382afe382bbe382ade383a5e383aae38386e382a3e58886e69e90-check><a href=/ja-jp/blog/2024/06/28/%E8%8F%AF%E7%82%BA%E7%A4%BE%E5%86%85%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%88%86%E6%9E%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628e88fafe782bae7a4bee58685e3838de38383e38388e383afe383bce382afe382bbe382ade383a5e383aae38386e382a3e58886e69e90><span>華為社内ネットワークセキュリティ分析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628about-child-protection-li><input type=checkbox id=m-ja-jpblog20240628about-child-protection-check>
<label for=m-ja-jpblog20240628about-child-protection-check><a href=/ja-jp/blog/2024/06/28/about-child-protection/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628about-child-protection><span>子どもたちのインターネット保護</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240628dose5afbee7ad96-li><input type=checkbox id=m-ja-jpblog20240628dose5afbee7ad96-check>
<label for=m-ja-jpblog20240628dose5afbee7ad96-check><a href=/ja-jp/blog/2024/06/28/dos%E5%AF%BE%E7%AD%96/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240628dose5afbee7ad96><span>DoS対策</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240618ingress-nginxe381a8nginx-ingresse381afe5908ce38198e38282e381aee381a7e381afe381aae38184-li><input type=checkbox id=m-ja-jpblog20240618ingress-nginxe381a8nginx-ingresse381afe5908ce38198e38282e381aee381a7e381afe381aae38184-check>
<label for=m-ja-jpblog20240618ingress-nginxe381a8nginx-ingresse381afe5908ce38198e38282e381aee381a7e381afe381aae38184-check><a href=/ja-jp/blog/2024/06/18/ingress-nginx%E3%81%A8nginx-ingress%E3%81%AF%E5%90%8C%E3%81%98%E3%82%82%E3%81%AE%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240618ingress-nginxe381a8nginx-ingresse381afe5908ce38198e38282e381aee381a7e381afe381aae38184><span>ingress-nginxとnginx ingressは同じものではない</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240614e887aae5bbbak8se382afe383a9e382b9e382bfe381a7e381aealibaba-cloude58886e695a3e382b9e38388e383ace383bce382b8e381aee4bdbfe794a8-li><input type=checkbox id=m-ja-jpblog20240614e887aae5bbbak8se382afe383a9e382b9e382bfe381a7e381aealibaba-cloude58886e695a3e382b9e38388e383ace383bce382b8e381aee4bdbfe794a8-check>
<label for=m-ja-jpblog20240614e887aae5bbbak8se382afe383a9e382b9e382bfe381a7e381aealibaba-cloude58886e695a3e382b9e38388e383ace383bce382b8e381aee4bdbfe794a8-check><a href=/ja-jp/blog/2024/06/14/%E8%87%AA%E5%BB%BAk8s%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%81%A7%E3%81%AEalibaba-cloud%E5%88%86%E6%95%A3%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8%E3%81%AE%E4%BD%BF%E7%94%A8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240614e887aae5bbbak8se382afe383a9e382b9e382bfe381a7e381aealibaba-cloude58886e695a3e382b9e38388e383ace383bce382b8e381aee4bdbfe794a8><span>自建K8SクラスタでのAlibaba Cloud分散ストレージの使用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240612dnse382b5e383bce38393e382b9e38292e4bdbfe794a8e38197e381a6e3838de38383e38388e383afe383bce382afe382b5e383bce38393e382b9e38292e382b9e383a0e383bce382bae381abe58887e3828ae69bbfe38188e3828b-li><input type=checkbox id=m-ja-jpblog20240612dnse382b5e383bce38393e382b9e38292e4bdbfe794a8e38197e381a6e3838de38383e38388e383afe383bce382afe382b5e383bce38393e382b9e38292e382b9e383a0e383bce382bae381abe58887e3828ae69bbfe38188e3828b-check>
<label for=m-ja-jpblog20240612dnse382b5e383bce38393e382b9e38292e4bdbfe794a8e38197e381a6e3838de38383e38388e383afe383bce382afe382b5e383bce38393e382b9e38292e382b9e383a0e383bce382bae381abe58887e3828ae69bbfe38188e3828b-check><a href=/ja-jp/blog/2024/06/12/dns%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%82%92%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AB%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240612dnse382b5e383bce38393e382b9e38292e4bdbfe794a8e38197e381a6e3838de38383e38388e383afe383bce382afe382b5e383bce38393e382b9e38292e382b9e383a0e383bce382bae381abe58887e3828ae69bbfe38188e3828b><span>DNSサービスを使用してネットワークサービスをスムーズに切り替える</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20240605e3839ce383aae383a5e383bce383a0e381aee58886e9a19ee381a8e696b9e6b395e8ab96-li><input type=checkbox id=m-ja-jpblog20240605e3839ce383aae383a5e383bce383a0e381aee58886e9a19ee381a8e696b9e6b395e8ab96-check>
<label for=m-ja-jpblog20240605e3839ce383aae383a5e383bce383a0e381aee58886e9a19ee381a8e696b9e6b395e8ab96-check><a href=/ja-jp/blog/2024/06/05/%E3%83%9C%E3%83%AA%E3%83%A5%E3%83%BC%E3%83%A0%E3%81%AE%E5%88%86%E9%A1%9E%E3%81%A8%E6%96%B9%E6%B3%95%E8%AB%96/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20240605e3839ce383aae383a5e383bce383a0e381aee58886e9a19ee381a8e696b9e6b395e8ab96><span>ボリュームの分類と方法論</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20230627okre381aee890bde381a8e38197e7a9b4e381a8e694afe68fb4-li><input type=checkbox id=m-ja-jpblog20230627okre381aee890bde381a8e38197e7a9b4e381a8e694afe68fb4-check>
<label for=m-ja-jpblog20230627okre381aee890bde381a8e38197e7a9b4e381a8e694afe68fb4-check><a href=/ja-jp/blog/2023/06/27/okr%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4%E3%81%A8%E6%94%AF%E6%8F%B4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20230627okre381aee890bde381a8e38197e7a9b4e381a8e694afe68fb4><span>OKRの落とし穴と支援</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20230506windowse38396e383aae38383e382b8e69982e381aeipv6e5958fe9a18c-li><input type=checkbox id=m-ja-jpblog20230506windowse38396e383aae38383e382b8e69982e381aeipv6e5958fe9a18c-check>
<label for=m-ja-jpblog20230506windowse38396e383aae38383e382b8e69982e381aeipv6e5958fe9a18c-check><a href=/ja-jp/blog/2023/05/06/windows%E3%83%96%E3%83%AA%E3%83%83%E3%82%B8%E6%99%82%E3%81%AEipv6%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20230506windowse38396e383aae38383e382b8e69982e381aeipv6e5958fe9a18c><span>Windowsブリッジ時のIPv6問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20221113vs-remote-debug-li><input type=checkbox id=m-ja-jpblog20221113vs-remote-debug-check>
<label for=m-ja-jpblog20221113vs-remote-debug-check><a href=/ja-jp/blog/2022/11/13/vs-remote-debug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20221113vs-remote-debug><span>vs-remote-debug</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-li><input type=checkbox id=m-ja-jpblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-check>
<label for=m-ja-jpblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-check><a href=/ja-jp/blog/2019/01/05/%E6%B0%B8%E8%BF%9C%E5%8B%87%E6%95%A2%E9%9D%A2%E5%AF%B9%E7%94%9F%E6%B4%BB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb><span>常に勇敢に人生と向き合う</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ja-jpblog20190105face-life-bravely-li><input type=checkbox id=m-ja-jpblog20190105face-life-bravely-check>
<label for=m-ja-jpblog20190105face-life-bravely-check><a href=/ja-jp/blog/2019/01/05/face-life-bravely/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ja-jpblog20190105face-life-bravely><span>人生に常に勇敢に向き合う</span></a></label></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"></div><div class=td-toc data-proofer-ignore><div class=td-toc-title><span class=td-toc-title__text></span>
<a class=td-toc-title__link title href=#></a></div><nav id=TableOfContents><ul><li><a href=#目的>目的</a></li><li><a href=#总体原则>总体原则</a></li><li><a href=#重点关注>重点关注</a></li><li><a href=#约定>约定</a></li><li><a href=#例外>例外</a></li></ul><ul><li><a href=#通用命名>通用命名</a></li><li><a href=#文件命名>文件命名</a><ul><li><a href=#规则221-c文件以cpp结尾头文件以h结尾>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</a></li><li><a href=#规则222-c文件名和类名保持一致>规则2.2.2 C++文件名和类名保持一致</a></li></ul></li><li><a href=#函数命名>函数命名</a></li><li><a href=#类型命名>类型命名</a><ul><li><a href=#建议241-避免滥用-typedef或者define-对基本类型起别名>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</a></li></ul></li><li><a href=#变量命名>变量命名</a><ul><li><a href=#规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀>规则2.5.1 全局变量应增加 ‘g_’ 前缀，静态变量命名不需要加特殊前缀</a></li><li><a href=#规则252-类的成员变量命名以小驼峰加后下划线组成>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</a></li></ul></li><li><a href=#宏常量枚举命名>宏、常量、枚举命名</a></li></ul><ul><li><a href=#行宽>行宽</a><ul><li><a href=#规则311-行宽不超过-120-个字符>规则3.1.1 行宽不超过 120 个字符</a></li></ul></li><li><a href=#缩进>缩进</a><ul><li><a href=#规则321-使用空格进行缩进每次缩进4个空格>规则3.2.1 使用空格进行缩进，每次缩进4个空格</a></li></ul></li><li><a href=#大括号>大括号</a><ul><li><a href=#规则331-使用-kr-缩进风格>规则3.3.1 使用 K&amp;R 缩进风格</a></li></ul></li><li><a href=#函数声明和定义>函数声明和定义</a><ul><li><a href=#规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</a></li></ul></li><li><a href=#函数调用>函数调用</a><ul><li><a href=#规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</a></li></ul></li><li><a href=#if语句>if语句</a><ul><li><a href=#规则361-if语句必须要使用大括号>规则3.6.1 if语句必须要使用大括号</a></li><li><a href=#规则362-禁止-ifelseelse-if-写在同一行>规则3.6.2 禁止 if/else/else if 写在同一行</a></li></ul></li><li><a href=#循环语句>循环语句</a><ul><li><a href=#规则371-循环语句必须使用大括号>规则3.7.1 循环语句必须使用大括号</a></li></ul></li><li><a href=#switch语句>switch语句</a><ul><li><a href=#规则381-switch-语句的-casedefault-要缩进一层>规则3.8.1 switch 语句的 case/default 要缩进一层</a></li></ul></li><li><a href=#表达式>表达式</a><ul><li><a href=#建议391-表达式换行要保持换行的一致性运算符放行末>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</a></li></ul></li><li><a href=#变量赋值>变量赋值</a><ul><li><a href=#规则3101-多个变量定义和赋值语句不允许写在一行>规则3.10.1 多个变量定义和赋值语句不允许写在一行</a></li></ul></li><li><a href=#初始化>初始化</a><ul><li><a href=#规则3111-初始化换行时要有缩进并进行合理对齐>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</a></li></ul></li><li><a href=#指针与引用>指针与引用</a><ul><li><a href=#建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.1 指针类型"<code>*</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li><li><a href=#建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.2 引用类型"<code>&</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li></ul></li><li><a href=#编译预处理>编译预处理</a><ul><li><a href=#规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进>规则3.13.1 编译预处理的”#“统一放在行首，嵌套编译预处理语句时，”#“可以进行缩进</a></li><li><a href=#规则3132-避免使用宏>规则3.13.2 避免使用宏</a></li><li><a href=#规则3133-禁止使用宏来表示常量>规则3.13.3 禁止使用宏来表示常量</a></li><li><a href=#规则3134-禁止使用函数式宏>规则3.13.4 禁止使用函数式宏</a></li></ul></li><li><a href=#空格和空行>空格和空行</a><ul><li><a href=#规则3141-水平空格应该突出关键字和重要信息避免不必要的留白>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</a></li><li><a href=#建议3141-合理安排空行保持代码紧凑>建议3.14.1 合理安排空行，保持代码紧凑</a></li></ul></li><li><a href=#类>类</a><ul><li><a href=#规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</a></li><li><a href=#规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</a></li></ul></li></ul><ul><li><a href=#注释风格>注释风格</a></li><li><a href=#文件头注释>文件头注释</a><ul><li><a href=#规则31-文件头注释必须包含版权许可>规则3.1 文件头注释必须包含版权许可</a></li></ul></li><li><a href=#函数头注释>函数头注释</a><ul><li><a href=#规则431-公有public函数必须编写函数头注释>规则4.3.1 公有（public）函数必须编写函数头注释</a></li><li><a href=#规则432-禁止空有格式的函数头注释>规则4.3.2 禁止空有格式的函数头注释</a></li></ul></li><li><a href=#代码注释>代码注释</a><ul><li><a href=#规则441-代码注释放于对应代码的上方或右边>规则4.4.1 代码注释放于对应代码的上方或右边</a></li><li><a href=#规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</a></li><li><a href=#规则443-不用的代码段直接删除不要注释掉>规则4.4.3 不用的代码段直接删除，不要注释掉</a></li></ul></li></ul><ul><li><a href=#头文件职责>头文件职责</a><ul><li><a href=#建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</a></li></ul></li><li><a href=#头文件依赖>头文件依赖</a><ul><li><a href=#规则521-禁止头文件循环依赖>规则5.2.1 禁止头文件循环依赖</a></li><li><a href=#规则522-头文件必须编写define保护防止重复包含>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</a></li><li><a href=#规则523-禁止通过声明的方式引用外部函数接口变量>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</a></li><li><a href=#规则524-禁止在extern-c中包含头文件>规则5.2.4 禁止在extern “C"中包含头文件</a></li><li><a href=#建议521尽量避免使用前置声明而是通过include来包含头文件>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</a></li></ul></li></ul><ul><li><a href=#命名空间>命名空间</a><ul><li><a href=#建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</a></li><li><a href=#规则611-不要在头文件中或者include之前使用using导入命名空间>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</a></li></ul></li><li><a href=#全局函数和静态成员函数>全局函数和静态成员函数</a><ul><li><a href=#建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</a></li></ul></li><li><a href=#全局常量和静态成员常量>全局常量和静态成员常量</a><ul><li><a href=#建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</a></li></ul></li><li><a href=#全局变量>全局变量</a><ul><li><a href=#建议641-尽量避免使用全局变量考虑使用单例模式>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</a></li></ul></li></ul><ul><li><a href=#构造拷贝构造赋值和析构函数>构造，拷贝构造，赋值和析构函数</a><ul><li><a href=#规则711-类的成员变量必须显式初始化>规则7.1.1 类的成员变量必须显式初始化</a></li><li><a href=#建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</a></li><li><a href=#规则712-为避免隐式转换将单参数构造函数声明为explicit>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</a></li><li><a href=#规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</a></li><li><a href=#规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则715-移动构造和移动赋值操作符应该是成对出现或者禁止>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则716-禁止在构造函数和析构函数中调用虚函数>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</a></li><li><a href=#规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</a></li></ul></li><li><a href=#继承>继承</a><ul><li><a href=#规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</a></li><li><a href=#ルール722-仮想関数にデフォルト引数値を使用しないこと>ルール7.2.2 仮想関数にデフォルト引数値を使用しないこと</a></li><li><a href=#ルール723-継承された非仮想関数を再定義しないこと>ルール7.2.3 継承された非仮想関数を再定義しないこと</a></li></ul></li><li><a href=#多重継承>多重継承</a><ul><li><a href=#提案731-インタフェースの分離と多役割の組み合わせに多重継承を使用する>提案7.3.1 インタフェースの分離と多役割の組み合わせに多重継承を使用する</a></li></ul></li><li><a href=#オーバーロード>オーバーロード</a></li></ul><ul><li><a href=#関数設計>関数設計</a><ul><li><a href=#ルール811-関数が長くなりすぎないようにし関数は50行以内空行とコメントを除くにする>ルール8.1.1 関数が長くなりすぎないようにし、関数は50行以内（空行とコメントを除く）にする</a></li></ul></li><li><a href=#インライン関数>インライン関数</a><ul><li><a href=#提案821-インライン関数は10行以内空行とコメントを除くにする>提案8.2.1 インライン関数は10行以内（空行とコメントを除く）にする</a></li></ul></li><li><a href=#関数パラメータ>関数パラメータ</a><ul><li><a href=#提案831-参照を使用してポインタを置き換える>提案8.3.1 参照を使用してポインタを置き換える</a></li><li><a href=#提案832-強い型のパラメータを使用しvoidを使用しないこと>提案8.3.2 強い型のパラメータを使用し、void*を使用しないこと</a></li><li><a href=#提案833-関数のパラメータ数は5つ以下にする>提案8.3.3 関数のパラメータ数は5つ以下にする</a></li></ul></li></ul><ul><li><a href=#定数と初期化>定数と初期化</a><ul><li><a href=#ルール911-マクロを使用して定数を表すことを禁止する>ルール9.1.1 マクロを使用して定数を表すことを禁止する</a></li><li><a href=#提案911-関連する整数定数のグループは列挙型として定義する>提案9.1.1 関連する整数定数のグループは列挙型として定義する</a></li><li><a href=#ルール912-デビルナンバーを使用しないこと>ルール9.1.2 デビルナンバーを使用しないこと</a></li><li><a href=#ルール913-定数は単一責任の原則に従うべき>ルール9.1.3 定数は単一責任の原則に従うべき</a></li><li><a href=#ルール914-podオブジェクト以外にmemcpy_smemset_sを使用して初期化しないこと>ルール9.1.4 PODオブジェクト以外にmemcpy_s、memset_sを使用して初期化しないこと</a></li><li><a href=#提案912-変数は使用時に宣言し初期化する>提案9.1.2 変数は使用時に宣言し、初期化する</a></li></ul></li><li><a href=#式>式</a><ul><li><a href=#ルール921-変数のインクリメントまたはデクリメント演算を含む式で同じ変数を再度参照してはいけない>ルール9.2.1 変数のインクリメントまたはデクリメント演算を含む式で、同じ変数を再度参照してはいけない</a></li><li><a href=#ルール922-switch文には必ずdefault節を含める>ルール9.2.2 switch文には必ずdefault節を含める</a></li><li><a href=#提案921-式の比較では左側は変化しやすく右側は変化しにくいという原則に従うべきです>提案9.2.1 式の比較では、左側は変化しやすく、右側は変化しにくいという原則に従うべきです</a></li><li><a href=#提案922-演算子の優先順位を明確にするために括弧を使用する>提案9.2.2 演算子の優先順位を明確にするために括弧を使用する</a></li></ul></li><li><a href=#型変換>型変換</a><ul><li><a href=#ルール931-型変換を使用する必要がある場合はcが提供する型変換を使用しcスタイルの型変換を使用しないこと>ルール9.3.1 型変換を使用する必要がある場合は、C++が提供する型変換を使用し、Cスタイルの型変換を使用しないこと</a></li><li><a href=#提案931-dynamic_castの使用を避けること>提案9.3.1 <code>dynamic_cast</code>の使用を避けること</a></li><li><a href=#提案932-reinterpret_castの使用を避けること>提案9.3.2 <code>reinterpret_cast</code>の使用を避けること</a></li><li><a href=#提案933-const_castの使用を避けること>提案9.3.3 <code>const_cast</code>の使用を避けること</a></li></ul></li><li><a href=#リソースの割り当てと解放>リソースの割り当てと解放</a><ul><li><a href=#ルール941-単一オブジェクトの解放にはdeleteを使用し配列オブジェクトの解放にはdelete-を使用する>ルール9.4.1 単一オブジェクトの解放にはdeleteを使用し、配列オブジェクトの解放にはdelete []を使用する</a></li><li><a href=#提案941-raii特性を使用して動的割り当てを追跡するのを助ける>提案9.4.1 RAII特性を使用して動的割り当てを追跡するのを助ける</a></li></ul></li><li><a href=#標準ライブラリ>標準ライブラリ</a><ul><li><a href=#ルール951-stdstringのc_strが返すポインタを保存しないこと>ルール9.5.1 std::stringのc_str()が返すポインタを保存しないこと</a></li><li><a href=#提案951-stdstringをcharの代わりに使用する>提案9.5.1 std::stringをchar*の代わりに使用する</a></li><li><a href=#ルール952-auto_ptrの使用を禁止する>ルール9.5.2 auto_ptrの使用を禁止する</a></li><li><a href=#提案952-新しい標準ヘッダファイルを使用する>提案9.5.2 新しい標準ヘッダファイルを使用する</a></li></ul></li><li><a href=#constの使用方法>constの使用方法</a><ul><li><a href=#ルール961-ポインタと参照型のパラメータが変更されない場合はconstを使用する>ルール9.6.1 ポインタと参照型のパラメータが変更されない場合は、constを使用する</a></li><li><a href=#ルール962-メンバー変数を変更しないメンバー関数にはconst修飾子を使用する>ルール9.6.2 メンバー変数を変更しないメンバー関数にはconst修飾子を使用する</a></li><li><a href=#提案961-初期化後に変更されないメンバー変数はconstとして定義する>提案9.6.1 初期化後に変更されないメンバー変数はconstとして定義する</a></li></ul></li><li><a href=#例外処理>例外処理</a><ul><li><a href=#提案971-c11では例外を投げない関数はnoexceptとして宣言する>提案9.7.1 C++11では、例外を投げない関数は<code>noexcept</code>として宣言する</a></li></ul></li><li><a href=#テンプレートとジェネリックプログラミング>テンプレートとジェネリックプログラミング</a><ul><li><a href=#ルール981-openharmonyプロジェクトでのジェネリックプログラミングを禁止する>ルール9.8.1 OpenHarmonyプロジェクトでのジェネリックプログラミングを禁止する</a></li></ul></li><li><a href=#マクロ>マクロ</a></li></ul><ul><li><a href=#コードの簡潔性と安全性の向上>コードの簡潔性と安全性の向上</a><ul><li><a href=#提案1011-autoを適切に使用する>提案10.1.1 <code>auto</code>を適切に使用する</a></li><li><a href=#ルール1011-仮想関数をオーバーライドするときはoverrideまたはfinalキーワードを使用する>ルール10.1.1 仮想関数をオーバーライドするときは<code>override</code>または<code>final</code>キーワードを使用する</a></li><li><a href=#ルール1012-deleteキーワードを使用して関数を削除する>ルール10.1.2 <code>delete</code>キーワードを使用して関数を削除する</a></li><li><a href=#ルール1013-nullptrを使用しnullや0は使用しないこと>ルール10.1.3 <code>nullptr</code>を使用し、<code>NULL</code>や<code>0</code>は使用しないこと</a></li><li><a href=#ルール1014-usingを使用しtypedefは使用しないこと>ルール10.1.4 <code>using</code>を使用し、<code>typedef</code>は使用しないこと</a></li><li><a href=#ルール1015-constオブジェクトに対してstdmoveを使用しないこと>ルール10.1.5 constオブジェクトに対してstd::moveを使用しないこと</a></li></ul></li><li><a href=#スマートポインタ>スマートポインタ</a><ul><li><a href=#ルール1021-所有権が複数で共有されないシングルトンやクラスのメンバーなどはスマートポインタではなく生ポインタを優先する>ルール10.2.1 所有権が複数で共有されないシングルトンやクラスのメンバーなどは、スマートポインタではなく生ポインタを優先する</a></li><li><a href=#ルール1022-newではなくstdmake_uniqueを使用してunique_ptrを作成する>ルール10.2.2 <code>new</code>ではなく<code>std::make_unique</code>を使用して<code>unique_ptr</code>を作成する</a></li><li><a href=#ルール1024-newではなくstdmake_sharedを使用してshared_ptrを作成する>ルール10.2.4 <code>new</code>ではなく<code>std::make_shared</code>を使用して<code>shared_ptr</code>を作成する</a></li></ul></li><li><a href=#lambda>Lambda</a><ul><li><a href=#提案1031-関数が動作しない場合はlambdaローカル変数をキャプチャするまたはローカル関数を書くを選択する>提案10.3.1 関数が動作しない場合は<code>lambda</code>(ローカル変数をキャプチャする、またはローカル関数を書く)を選択する</a></li><li><a href=#ルール1031-非ローカルスコープでlambdasを使用する場合参照キャプチャは避けること>ルール10.3.1 非ローカルスコープで<code>lambdas</code>を使用する場合、参照キャプチャは避けること</a></li><li><a href=#提案1032-thisをキャプチャする場合はすべての変数を明示的にキャプチャする>提案10.3.2 <code>this</code>をキャプチャする場合は、すべての変数を明示的にキャプチャする</a></li><li><a href=#提案1033-デフォルトキャプチャモードの使用を避ける>提案10.3.3 デフォルトキャプチャモードの使用を避ける</a></li></ul></li><li><a href=#インタフェース>インタフェース</a><ul><li><a href=#提案1041-所有権を伴わないシナリオではスマートポインタではなくtまたはtを引数として使用する>提案10.4.1 所有権を伴わないシナリオでは、スマートポインタではなく<code>T*</code>または<code>T&</code>を引数として使用する</a></li></ul></li></ul></nav></div><div class="taxonomy taxonomy-terms-cloud taxo-tags"><h5 class=taxonomy-title>Taxonomy Cloud</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/2019/ data-taxonomy-term=2019><span class=taxonomy-label>2019</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/2025/ data-taxonomy-term=2025><span class=taxonomy-label>2025</span><span class=taxonomy-count>10</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/2026/ data-taxonomy-term=2026><span class=taxonomy-label>2026</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/adguard%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=adguard%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>Adguardシリーズ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>15</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/ai%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%94%AF%E6%8F%B4/ data-taxonomy-term=ai%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%94%AF%E6%8F%B4><span class=taxonomy-label>AIプログラミング支援</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/alibaba-cloud/ data-taxonomy-term=alibaba-cloud><span class=taxonomy-label>Alibaba Cloud</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/api/ data-taxonomy-term=api><span class=taxonomy-label>API</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/blog/ data-taxonomy-term=blog><span class=taxonomy-label>Blog</span><span class=taxonomy-count>9</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/calico/ data-taxonomy-term=calico><span class=taxonomy-label>Calico</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/cdn/ data-taxonomy-term=cdn><span class=taxonomy-label>CDN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/cdp/ data-taxonomy-term=cdp><span class=taxonomy-label>CDP</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/chrome/ data-taxonomy-term=chrome><span class=taxonomy-label>Chrome</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/claude-code/ data-taxonomy-term=claude-code><span class=taxonomy-label>Claude Code</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/cline/ data-taxonomy-term=cline><span class=taxonomy-label>Cline</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/codex/ data-taxonomy-term=codex><span class=taxonomy-label>Codex</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/copilot%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=copilot%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>Copilotシリーズ</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/cursor/ data-taxonomy-term=cursor><span class=taxonomy-label>Cursor</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/deepseek/ data-taxonomy-term=deepseek><span class=taxonomy-label>DeepSeek</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/dns/ data-taxonomy-term=dns><span class=taxonomy-label>DNS</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/docker/ data-taxonomy-term=docker><span class=taxonomy-label>Docker</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/environment/ data-taxonomy-term=environment><span class=taxonomy-label>Environment</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/esa/ data-taxonomy-term=esa><span class=taxonomy-label>ESA</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/gemini/ data-taxonomy-term=gemini><span class=taxonomy-label>Gemini</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/github/ data-taxonomy-term=github><span class=taxonomy-label>GitHub</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/github-pages/ data-taxonomy-term=github-pages><span class=taxonomy-label>GitHub Pages</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/google/ data-taxonomy-term=google><span class=taxonomy-label>Google</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/gpt-5.3/ data-taxonomy-term=gpt-5.3><span class=taxonomy-label>GPT-5.3</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/ipv6/ data-taxonomy-term=ipv6><span class=taxonomy-label>IPv6</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/isp/ data-taxonomy-term=isp><span class=taxonomy-label>ISP</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/k8s/ data-taxonomy-term=k8s><span class=taxonomy-label>K8s</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/kubenetes%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=kubenetes%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>Kubenetesクラスタシリーズ</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/kubenetes%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=kubenetes%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>Kubenetesシリーズ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/linux/ data-taxonomy-term=linux><span class=taxonomy-label>Linux</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/llm/ data-taxonomy-term=llm><span class=taxonomy-label>Llm</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/massgrave/ data-taxonomy-term=massgrave><span class=taxonomy-label>Massgrave</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/moonshot/ data-taxonomy-term=moonshot><span class=taxonomy-label>Moonshot</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/openai/ data-taxonomy-term=openai><span class=taxonomy-label>OpenAI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/prompt/ data-taxonomy-term=prompt><span class=taxonomy-label>Prompt</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/token/ data-taxonomy-term=token><span class=taxonomy-label>Token</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/udp-qos/ data-taxonomy-term=udp-qos><span class=taxonomy-label>UDP QoS</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/vpn/ data-taxonomy-term=vpn><span class=taxonomy-label>VPN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/vs-code%E6%8B%A1%E5%BC%B5%E6%A9%9F%E8%83%BD/ data-taxonomy-term=vs-code%E6%8B%A1%E5%BC%B5%E6%A9%9F%E8%83%BD><span class=taxonomy-label>VS Code拡張機能</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/vscode/ data-taxonomy-term=vscode><span class=taxonomy-label>VSCode</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>12</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/win%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87/ data-taxonomy-term=win%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87><span class=taxonomy-label>Win疑難雑症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/wireguard/ data-taxonomy-term=wireguard><span class=taxonomy-label>WireGuard</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/wsl/ data-taxonomy-term=wsl><span class=taxonomy-label>Wsl</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/z-ai/ data-taxonomy-term=z-ai><span class=taxonomy-label>Z-AI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%81%82%E3%81%A1%E3%81%93%E3%81%A1/ data-taxonomy-term=%E3%81%82%E3%81%A1%E3%81%93%E3%81%A1><span class=taxonomy-label>あちこち</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%88%E3%81%86%E3%81%AA%E5%95%8F%E9%A1%8C/ data-taxonomy-term=%E3%82%88%E3%81%86%E3%81%AA%E5%95%8F%E9%A1%8C><span class=taxonomy-label>ような問題</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3/ data-taxonomy-term=%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3><span class=taxonomy-label>アイコン</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%99%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%99%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB><span class=taxonomy-label>アクティベーショントール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%A2%E3%83%AA%E3%83%90%E3%83%90%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=%E3%82%A2%E3%83%AA%E3%83%90%E3%83%90%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>アリババクラウドシリーズ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/ data-taxonomy-term=%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9><span class=taxonomy-label>インデックス</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4/ data-taxonomy-term=%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4><span class=taxonomy-label>エッセイ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%96%E3%83%AD%E3%82%B0/ data-taxonomy-term=%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%96%E3%83%AD%E3%82%B0><span class=taxonomy-label>オープンソースブログ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88/ data-taxonomy-term=%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88><span class=taxonomy-label>オープンソースプロジェクト</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9><span class=taxonomy-label>クラウドサービス</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF><span class=taxonomy-label>クラスタ</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC><span class=taxonomy-label>クラスター</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AF%E3%83%AA%E3%82%A8%E3%82%A4%E3%82%BF%E3%83%BC%E3%83%97%E3%83%A9%E3%83%83%E3%83%88%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0/ data-taxonomy-term=%E3%82%AF%E3%83%AA%E3%82%A8%E3%82%A4%E3%82%BF%E3%83%BC%E3%83%97%E3%83%A9%E3%83%83%E3%83%88%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0><span class=taxonomy-label>クリエイタープラットフォーム</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC/ data-taxonomy-term=%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC><span class=taxonomy-label>クローラー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%B3%E3%82%B9%E3%83%88/ data-taxonomy-term=%E3%82%B3%E3%82%B9%E3%83%88><span class=taxonomy-label>コスト</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%B5%E3%82%A4%E3%83%90%E3%83%BC%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E3%82%B5%E3%82%A4%E3%83%90%E3%83%BC%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>サイバーセキュリティ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%B5%E3%83%BC%E3%83%89%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%83%99%E3%83%B3%E3%83%80%E3%83%BC/ data-taxonomy-term=%E3%82%B5%E3%83%BC%E3%83%89%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%83%99%E3%83%B3%E3%83%80%E3%83%BC><span class=taxonomy-label>サードパーティベンダー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/ data-taxonomy-term=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0><span class=taxonomy-label>システム</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9/ data-taxonomy-term=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9><span class=taxonomy-label>システムメンテナンス</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>セキュリティ</span><span class=taxonomy-count>12</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB/ data-taxonomy-term=%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB><span class=taxonomy-label>チュートリアル</span><span class=taxonomy-count>18</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>ツール</span><span class=taxonomy-count>17</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%86%E3%82%B9%E3%83%88%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E3%83%86%E3%82%B9%E3%83%88%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>テストツール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3/ data-taxonomy-term=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3><span class=taxonomy-label>デザイン</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E3%83%AA%E3%83%86%E3%83%A9%E3%82%B7%E3%83%BC/ data-taxonomy-term=%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E3%83%AA%E3%83%86%E3%83%A9%E3%82%B7%E3%83%BC><span class=taxonomy-label>デジタルリテラシー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%87%E3%83%90%E3%83%83%E3%82%B0/ data-taxonomy-term=%E3%83%87%E3%83%90%E3%83%83%E3%82%B0><span class=taxonomy-label>デバッグ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>ドメインセキュリティ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF><span class=taxonomy-label>ネットワーク</span><span class=taxonomy-count>22</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>ネットワークセキュリティ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%8A%80%E8%A1%93><span class=taxonomy-label>ネットワーク技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%9C%80%E9%81%A9%E5%8C%96/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%9C%80%E9%81%A9%E5%8C%96><span class=taxonomy-label>ネットワーク最適化</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%90%E3%83%88%E3%83%AB/ data-taxonomy-term=%E3%83%90%E3%83%88%E3%83%AB><span class=taxonomy-label>バトル</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96/ data-taxonomy-term=%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96><span class=taxonomy-label>パフォーマンス最適化</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%97%E3%83%A9%E3%82%A4%E3%83%90%E3%82%B7%E3%83%BC/ data-taxonomy-term=%E3%83%97%E3%83%A9%E3%82%A4%E3%83%90%E3%82%B7%E3%83%BC><span class=taxonomy-label>プライバシー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%97%E3%83%A9%E3%82%A4%E3%83%90%E3%82%B7%E3%83%BC%E4%BF%9D%E8%AD%B7/ data-taxonomy-term=%E3%83%97%E3%83%A9%E3%82%A4%E3%83%90%E3%82%B7%E3%83%BC%E4%BF%9D%E8%AD%B7><span class=taxonomy-label>プライバシー保護</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E/ data-taxonomy-term=%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E><span class=taxonomy-label>プログラマ</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC/ data-taxonomy-term=%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC><span class=taxonomy-label>プログラマー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%97%E3%83%AD%E3%83%B3%E3%83%97%E3%83%88%E3%81%A7%E5%AD%A6%E3%81%B6%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/ data-taxonomy-term=%E3%83%97%E3%83%AD%E3%83%B3%E3%83%97%E3%83%88%E3%81%A7%E5%AD%A6%E3%81%B6%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3><span class=taxonomy-label>プロンプトで学ぶアーキテクチャ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%99%E3%83%BC%E3%82%BF%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ data-taxonomy-term=%E3%83%99%E3%83%BC%E3%82%BF%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA><span class=taxonomy-label>ベータシリーズ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%83%94%E3%83%B3%E7%95%99%E3%82%81/ data-taxonomy-term=%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%83%94%E3%83%B3%E7%95%99%E3%82%81><span class=taxonomy-label>ユーザーピン留め</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%AA%E3%82%B5%E3%83%BC%E3%83%81/ data-taxonomy-term=%E3%83%AA%E3%82%B5%E3%83%BC%E3%83%81><span class=taxonomy-label>リサーチ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/ data-taxonomy-term=%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7><span class=taxonomy-label>リバースプロキシ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%87%E3%83%90%E3%83%83%E3%82%B0/ data-taxonomy-term=%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%87%E3%83%90%E3%83%83%E3%82%B0><span class=taxonomy-label>リモートデバッグ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC/ data-taxonomy-term=%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC><span class=taxonomy-label>レビュー</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%A9%E3%82%A4%E3%82%BC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/ data-taxonomy-term=%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%A9%E3%82%A4%E3%82%BC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3><span class=taxonomy-label>ローカライゼーション</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E4%B8%80%E8%88%AC%E6%95%99%E9%A4%8A/ data-taxonomy-term=%E4%B8%80%E8%88%AC%E6%95%99%E9%A4%8A><span class=taxonomy-label>一般教養</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E4%BA%BA%E5%B7%A5%E7%9F%A5%E8%83%BD%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ data-taxonomy-term=%E4%BA%BA%E5%B7%A5%E7%9F%A5%E8%83%BD%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0><span class=taxonomy-label>人工知能プログラミング</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E4%BA%BA%E7%94%9F/ data-taxonomy-term=%E4%BA%BA%E7%94%9F><span class=taxonomy-label>人生</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E4%BB%95%E6%A7%98%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA/ data-taxonomy-term=%E4%BB%95%E6%A7%98%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA><span class=taxonomy-label>仕様駆動開発</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E5%85%90%E7%AB%A5%E4%BF%9D%E8%AD%B7/ data-taxonomy-term=%E5%85%90%E7%AB%A5%E4%BF%9D%E8%AD%B7><span class=taxonomy-label>児童保護</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%83%85%E5%A0%B1%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E6%83%85%E5%A0%B1%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>情報セキュリティ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E6%8A%80%E8%A1%93><span class=taxonomy-label>技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%94%BB%E9%98%B2/ data-taxonomy-term=%E6%94%BB%E9%98%B2><span class=taxonomy-label>攻防</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%9C%AA%E5%88%86%E9%A1%9E/ data-taxonomy-term=%E6%9C%AA%E5%88%86%E9%A1%9E><span class=taxonomy-label>未分類</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%B3%95%E5%BE%8B/ data-taxonomy-term=%E6%B3%95%E5%BE%8B><span class=taxonomy-label>法律</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E7%84%A1%E6%96%99%E3%83%88%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%AB/ data-taxonomy-term=%E7%84%A1%E6%96%99%E3%83%88%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%AB><span class=taxonomy-label>無料トライアル</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87/ data-taxonomy-term=%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87><span class=taxonomy-label>疑難雑症</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E7%BF%BB%E8%A8%B3%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E7%BF%BB%E8%A8%B3%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>翻訳ツール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E8%A6%AA%E6%A8%A9%E8%80%85%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E8%A6%AA%E6%A8%A9%E8%80%85%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB><span class=taxonomy-label>親権者コントロール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E8%A9%95%E4%BE%A1/ data-taxonomy-term=%E8%A9%95%E4%BE%A1><span class=taxonomy-label>評価</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E8%AA%BF%E6%9F%BB/ data-taxonomy-term=%E8%AA%BF%E6%9F%BB><span class=taxonomy-label>調査</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%81%8B%E5%96%B6%E4%BF%9D%E5%AE%88/ data-taxonomy-term=%E9%81%8B%E5%96%B6%E4%BF%9D%E5%AE%88><span class=taxonomy-label>運営・保守</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%81%8B%E7%94%A8/ data-taxonomy-term=%E9%81%8B%E7%94%A8><span class=taxonomy-label>運用</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%81%8B%E7%94%A8%E7%AE%A1%E7%90%86/ data-taxonomy-term=%E9%81%8B%E7%94%A8%E7%AE%A1%E7%90%86><span class=taxonomy-label>運用管理</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>開発ツール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%9A%8F%E7%AD%86/ data-taxonomy-term=%E9%9A%8F%E7%AD%86><span class=taxonomy-label>随筆</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%9B%91%E7%AD%86/ data-taxonomy-term=%E9%9B%91%E7%AD%86><span class=taxonomy-label>雑筆</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E9%9B%91%E8%AB%87/ data-taxonomy-term=%E9%9B%91%E8%AB%87><span class=taxonomy-label>雑談</span><span class=taxonomy-count>1</span></a></li></ul></div><div class="taxonomy taxonomy-terms-cloud taxo-categories"><h5 class=taxonomy-title>Categories</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/markdown/ data-taxonomy-term=markdown><span class=taxonomy-label>Markdown</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/win%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87/ data-taxonomy-term=win%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87><span class=taxonomy-label>Win疑難雑症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/ data-taxonomy-term=%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9><span class=taxonomy-label>インデックス</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4/ data-taxonomy-term=%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4><span class=taxonomy-label>エッセイ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88/ data-taxonomy-term=%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88><span class=taxonomy-label>オープンソースプロジェクト</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%AD%E3%83%A3%E3%83%B3%E3%83%9A%E3%83%BC%E3%83%B3/ data-taxonomy-term=%E3%82%AD%E3%83%A3%E3%83%B3%E3%83%9A%E3%83%BC%E3%83%B3><span class=taxonomy-label>キャンペーン</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9><span class=taxonomy-label>クラウドサービス</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF><span class=taxonomy-label>クラスタ</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC/ data-taxonomy-term=%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC><span class=taxonomy-label>クラスター</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/ data-taxonomy-term=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0><span class=taxonomy-label>システム</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%99%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/ data-taxonomy-term=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%99%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3><span class=taxonomy-label>システムアクティベーション</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/ data-taxonomy-term=%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3><span class=taxonomy-label>セキュリティ</span><span class=taxonomy-count>8</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB/ data-taxonomy-term=%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB><span class=taxonomy-label>チュートリアル</span><span class=taxonomy-count>19</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>ツール</span><span class=taxonomy-count>17</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%84%E3%83%BC%E3%83%AB%E6%8E%A8%E5%A5%A8/ data-taxonomy-term=%E3%83%84%E3%83%BC%E3%83%AB%E6%8E%A8%E5%A5%A8><span class=taxonomy-label>ツール推奨</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3/ data-taxonomy-term=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3><span class=taxonomy-label>デザイン</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF><span class=taxonomy-label>ネットワーク</span><span class=taxonomy-count>21</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E6%8A%80%E8%A1%93><span class=taxonomy-label>ネットワーク技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%90%E3%83%88%E3%83%AB/ data-taxonomy-term=%E3%83%90%E3%83%88%E3%83%AB><span class=taxonomy-label>バトル</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC/ data-taxonomy-term=%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC><span class=taxonomy-label>プログラマー</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%80%E3%82%A6%E3%83%B3/ data-taxonomy-term=%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%80%E3%82%A6%E3%83%B3><span class=taxonomy-label>マークダウン</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%AA%E3%82%B5%E3%83%BC%E3%83%81/ data-taxonomy-term=%E3%83%AA%E3%82%B5%E3%83%BC%E3%83%81><span class=taxonomy-label>リサーチ</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC/ data-taxonomy-term=%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC><span class=taxonomy-label>レビュー</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E4%B8%80%E8%88%AC%E6%95%99%E9%A4%8A/ data-taxonomy-term=%E4%B8%80%E8%88%AC%E6%95%99%E9%A4%8A><span class=taxonomy-label>一般教養</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E4%BA%BA%E7%94%9F/ data-taxonomy-term=%E4%BA%BA%E7%94%9F><span class=taxonomy-label>人生</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E6%8A%80%E8%A1%93-%E3%83%87%E3%83%90%E3%83%83%E3%82%B0-ai/ data-taxonomy-term=%E6%8A%80%E8%A1%93-%E3%83%87%E3%83%90%E3%83%83%E3%82%B0-ai><span class=taxonomy-label>技術, デバッグ, AI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E6%97%A5%E5%B8%B8/ data-taxonomy-term=%E6%97%A5%E5%B8%B8><span class=taxonomy-label>日常</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E6%9C%AA%E5%88%86%E9%A1%9E/ data-taxonomy-term=%E6%9C%AA%E5%88%86%E9%A1%9E><span class=taxonomy-label>未分類</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87/ data-taxonomy-term=%E7%96%91%E9%9B%A3%E9%9B%91%E7%97%87><span class=taxonomy-label>疑難雑症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E8%A6%96%E7%82%B9/ data-taxonomy-term=%E8%A6%96%E7%82%B9><span class=taxonomy-label>視点</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E8%A9%95%E4%BE%A1/ data-taxonomy-term=%E8%A9%95%E4%BE%A1><span class=taxonomy-label>評価</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E8%AA%AD%E6%9B%B8/ data-taxonomy-term=%E8%AA%AD%E6%9B%B8><span class=taxonomy-label>読書</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E8%AA%BF%E6%9F%BB/ data-taxonomy-term=%E8%AA%BF%E6%9F%BB><span class=taxonomy-label>調査</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E9%81%8B%E5%96%B6%E4%BF%9D%E5%AE%88/ data-taxonomy-term=%E9%81%8B%E5%96%B6%E4%BF%9D%E5%AE%88><span class=taxonomy-label>運営・保守</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E9%81%8B%E7%94%A8/ data-taxonomy-term=%E9%81%8B%E7%94%A8><span class=taxonomy-label>運用</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E9%81%8B%E7%94%A8%E7%AE%A1%E7%90%86/ data-taxonomy-term=%E9%81%8B%E7%94%A8%E7%AE%A1%E7%90%86><span class=taxonomy-label>運用管理</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB/ data-taxonomy-term=%E9%96%8B%E7%99%BA%E3%83%84%E3%83%BC%E3%83%AB><span class=taxonomy-label>開発ツール</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E9%9A%8F%E7%AD%86/ data-taxonomy-term=%E9%9A%8F%E7%AD%86><span class=taxonomy-label>随筆</span><span class=taxonomy-count>3</span></a></li></ul></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><a class=td-rss-button title=RSS href=/ja-jp/blog/index.xml target=_blank rel=noopener><i class="fa-solid fa-rss" aria-hidden=true></i></a><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/ja-jp/blog/>ブログ</a></li><li class="breadcrumb-item active" aria-current=page>华为C++编程规范</li></ol></nav><div class=td-content><h1>华为C++编程规范</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><header class=article-meta><div class="taxonomy taxonomy-terms-article taxo-tags"><h5 class=taxonomy-title>Tags:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span></a></li></ul></div><div class="taxonomy taxonomy-terms-article taxo-categories"><h5 class=taxonomy-title>Categories:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ja-jp/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li></ul></div></header><ul><li><input disabled type=checkbox> 华为C++编程规范</li></ul><h1 id=c语言编程规范>C++语言编程规范</h1><h2 id=目的><a name=c0-1></a>目的</h2><p>规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。
参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。</p><ol><li>了解C++语言的ISO标准；</li><li>熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性；</li><li>了解C++语言的标准库；</li></ol><h2 id=总体原则><a name=c0-2></a>总体原则</h2><p>代码需要在保证功能正确的前提下，满足<strong>可读、可维护、安全、可靠、可测试、高效、可移植</strong>的特征要求。</p><h2 id=重点关注><a name=c0-2></a>重点关注</h2><ol><li>约定C++语言的编程风格，比如命名，排版等。</li><li>C++语言的模块化设计，如何设计头文件，类，接口和函数。</li><li>C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。</li><li>现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。</li><li>本规范优先适于用C++17版本。</li></ol><h2 id=约定><a name=c0-3></a>约定</h2><p><strong>规则</strong>：编程时必须遵守的约定(must)</p><p><strong>建议</strong>：编程时应该遵守的约定(should)</p><p>本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。</p><h2 id=例外><a name=c0-4></a>例外</h2><p>无论是&rsquo;规则&rsquo;还是&rsquo;建议&rsquo;，都必须理解该条目这么规定的原因，并努力遵守。
但是，有些规则和建议可能会有例外。</p><p>在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。
例外破坏了代码的一致性，请尽量避免。&lsquo;规则&rsquo;的例外应该是极少的。</p><p>下列情况，应风格一致性原则优先：
<strong>修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。</strong></p><h1 id=2-命名><a name=c2></a>2 命名</h1><h2 id=通用命名><a name=c2-1></a>通用命名</h2><p><strong>驼峰风格(CamelCase)</strong>
大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。
按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)</p><table><thead><tr><th>类型</th><th>命名风格</th></tr></thead><tbody><tr><td>类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称</td><td>大驼峰</td></tr><tr><td>函数(包括全局函数，作用域函数，成员函数)</td><td>大驼峰</td></tr><tr><td>全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量</td><td>小驼峰</td></tr><tr><td>宏，常量(const)，枚举值，goto 标签</td><td>全大写，下划线分割</td></tr></tbody></table><p>注意：
上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。
上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。</p><h2 id=文件命名><a name=c2-2></a>文件命名</h2><h3 id=规则221-c文件以cpp结尾头文件以h结尾><a name=r2-2-1></a>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</h3><p>我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。
我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。</p><p>目前业界还有一些其他的后缀的表示方法：</p><ul><li>头文件： .hh, .hpp, .hxx</li><li>cpp文件：.cc, .cxx, .c</li></ul><p>如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。
但是对于本文档，我们默认使用.h和.cpp作为后缀。</p><h3 id=规则222-c文件名和类名保持一致><a name=r2-2-2></a>规则2.2.2 C++文件名和类名保持一致</h3><p>C++的头文件和cpp文件名和类名保持一致，使用下划线小写风格。</p><p>如果有一个类叫DatabaseConnection，那么对应的文件名：</p><ul><li>database_connection.h</li><li>database_connection.cpp</li></ul><p>结构体，命名空间，枚举等定义的文件名类似。</p><h2 id=函数命名><a name=c2-3></a>函数命名</h2><p>函数命名统一使用大驼峰风格，一般采用动词或者动宾结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>AddElement</span><span class=p>(</span><span class=k>const</span> <span class=n>Element</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Element</span> <span class=nf>GetElement</span><span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteUser</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类型命名><a name=c2-4></a>类型命名</h2><p>类型命名采用大驼峰命名风格。
所有类型命名——类、结构体、联合体、类型定义（typedef）、枚举——使用相同约定，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// classes, structs and unions
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTable</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTableTester</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UrlTableProperties</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>Packet</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedefs
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>UrlTableProperties</span><span class=o>*&gt;</span> <span class=n>PropertiesMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// enums
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>UrlTableErrors</span> <span class=p>{</span> <span class=p>...</span>
</span></span></code></pre></div><p>对于命名空间的命名，建议使用大驼峰：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// namespace
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>OsUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FileUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=建议241-避免滥用-typedef或者define-对基本类型起别名><a name=a2-4-1></a>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</h3><p>除有明确的必要性，否则不要用 typedef/#define 对基本数据类型进行重定义。
优先使用<code>&lt;cstdint></code>头文件中的基本类型：</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有/无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有/无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有/无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有/无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有/无符号整数类型</td></tr></tbody></table><h2 id=变量命名><a name=c2-5></a>变量命名</h2><p>通用变量命名采用小驼峰，包括全局变量，函数形参，局部变量，成员变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tableName</span><span class=p>;</span>  <span class=c1>// Good: 推荐此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tablename</span><span class=p>;</span>  <span class=c1>// Bad: 禁止此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span>       <span class=c1>// Good: 只有一个单词时，小驼峰为全小写
</span></span></span></code></pre></div><h3 id=规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀><a name=r2-5-1></a>规则2.5.1 全局变量应增加 &lsquo;g_&rsquo; 前缀，静态变量命名不需要加特殊前缀</h3><p>全局变量是应当尽量少使用的，使用时应特别注意，所以加上前缀用于视觉上的突出，促使开发人员对这些变量的使用更加小心。</p><ul><li>全局静态变量命名与全局变量相同。</li><li>函数内的静态变量命名与普通局部变量相同。</li><li>类的静态成员变量和普通成员变量相同。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_activeConnectCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>packetCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则252-类的成员变量命名以小驼峰加后下划线组成><a name=r2-5-2></a>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileName_</span><span class=p>;</span>   <span class=c1>// 添加_后缀，类似于K&amp;R命名风格
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>对于struct/union的成员变量，仍采用小驼峰不加后缀的命名方式，与局部变量命名风格一致。</p><h2 id=宏常量枚举命名><a name=c2-6></a>宏、常量、枚举命名</h2><p>宏、枚举值采用全大写，下划线连接的格式。
全局作用域内，有名和匿名namespace内的 const 常量，类的静态成员常量，全大写，下划线连接；函数局部 const 常量和类的普通const成员变量，使用小驼峰命名风格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX(a, b)   (((a) &lt; (b)) ? (b) : (a)) </span><span class=c1>// 仅对宏命名举例，并不推荐用宏实现此类功能
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TintColor</span> <span class=p>{</span>    <span class=c1>// 注意，枚举类型名用大驼峰，其下面的取值是全大写，下划线相连
</span></span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DARK_RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>GREEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LIGHT_GREEN</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>    <span class=c1>// 函数局部常量
</span></span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>DEFAULT_FILE_SIZE_KB</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>        <span class=c1>// 全局常量
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=3-格式><a name=c3></a>3 格式</h1><h2 id=行宽><a name=c3-1></a>行宽</h2><h3 id=规则311-行宽不超过-120-个字符><a name=r3-1-1></a>规则3.1.1 行宽不超过 120 个字符</h3><p>建议每行字符数不要超过 120 个。如果超过120个字符，请选择合理的方式进行换行。</p><p>例外:</p><ul><li>如果一行注释包含了超过120 个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；</li><li>包含长路径的 #include 语句可以超出120 个字符，但是也需要尽量避免；</li><li>编译预处理中的error信息可以超出一行。
预处理的 error 信息在一行便于阅读和理解，即使超过 120 个字符。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef XXX_YYY_ZZZ
</span></span></span><span class=line><span class=cl><span class=cp>#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 id=缩进><a name=c3-2></a>缩进</h2><h3 id=规则321-使用空格进行缩进每次缩进4个空格><a name=r3-2-1></a>规则3.2.1 使用空格进行缩进，每次缩进4个空格</h3><p>只允许使用空格(space)进行缩进，每次缩进为 4 个空格。不允许使用Tab符进行缩进。
当前几乎所有的集成开发环境（IDE）都支持配置将Tab符自动扩展为4空格输入；请配置你的IDE支持使用空格进行缩进。</p><h2 id=大括号><a name=c3-3></a>大括号</h2><h3 id=规则331-使用-kr-缩进风格><a name=r3-3-1></a>规则3.3.1 使用 K&amp;R 缩进风格</h3><p><strong>K&amp;R风格</strong>
换行时，函数（不包括lambda表达式）左大括号另起一行放行首，并独占一行；其他左大括号跟随语句放行末。
右大括号独占一行，除非后面跟着同一语句的剩余部分，如 do 语句中的 while，或者 if 语句的 else/else if，或者逗号、分号。</p><p>如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span> <span class=p>{</span>     <span class=c1>// 跟随语句放行末，前置1空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                   <span class=c1>// 函数左大括号独占一行，放行首
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>推荐这种风格的理由：</p><ul><li>代码更紧凑；</li><li>相比另起一行，放行末使代码阅读节奏感上更连续；</li><li>符合后来语言的习惯，符合业界主流习惯；</li><li>现代集成开发环境（IDE）都具有代码缩进对齐显示的辅助功能，大括号放在行尾并不会对缩进和范围产生理解上的影响。</li></ul><p>对于空函数体，可以将大括号放在同一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=函数声明和定义><a name=c3-4></a>函数声明和定义</h2><h3 id=规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐><a name=r3-4-1></a>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</h3><p>在声明和定义函数的时候，函数的返回值类型应该和函数名在同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。
参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>FunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>)</span>   <span class=c1>// Good：全在同一行
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>VeryVeryVeryLongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span>     <span class=c1>// 行宽不满足所有参数，进行换行
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span>     <span class=c1>// Good：和上一行参数对齐
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>LongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=c1>// 行宽限制，进行换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName5</span><span class=p>)</span>     <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>ReallyReallyReallyReallyLongFunctionName</span><span class=p>(</span>            <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span> <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=函数调用><a name=c3-5></a>函数调用</h2><h3 id=规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐><a name=r3-5-1></a>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</h3><p>函数调用时，函数参数列表放在一行。参数列表如果超过行宽，需要换行并进行合理的参数对齐。
左圆括号总是跟函数名，右圆括号总是跟最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>);</span>   <span class=c1>// Good：函数参数放在一行
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>paramName2</span><span class=p>,</span>                <span class=c1>// Good：保持与上方参数对齐
</span></span></span><span class=line><span class=cl>                                 <span class=n>paramName3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>paramName3</span><span class=p>,</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>paramName5</span><span class=p>);</span>                    <span class=c1>// Good：参数换行，4 空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>VeryVeryVeryLongFunctionName</span><span class=p>(</span>           <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>paramName3</span><span class=p>);</span>                    <span class=c1>// 换行后，4 空格缩进
</span></span></span></code></pre></div><p>如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Good：每行的参数代表一组相关性较强的数据结构，放在一行便于理解
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DealWithStructureLikeParams</span><span class=p>(</span><span class=n>left</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>left</span><span class=p>.</span><span class=n>y</span><span class=p>,</span>     <span class=c1>// 表示一组相关参数
</span></span></span><span class=line><span class=cl>                                         <span class=n>right</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>right</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>  <span class=c1>// 表示另外一组相关参数
</span></span></span></code></pre></div><h2 id=if语句><a name=c3-6></a>if语句</h2><h3 id=规则361-if语句必须要使用大括号><a name=r3-6-1></a>规则3.6.1 if语句必须要使用大括号</h3><p>我们要求if语句都需要使用大括号，即便只有一条语句。</p><p>理由：</p><ul><li>代码逻辑直观，易读；</li><li>在已有条件语句代码上增加新代码时不容易出错；</li><li>对于在if语句中使用函数式宏时，有大括号保护不易出错（如果宏定义时遗漏了大括号）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>objectIsNotExist</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Good：单行条件语句也加大括号
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>CreateNewObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则362-禁止-ifelseelse-if-写在同一行><a name=r3-6-2></a>规则3.6.2 禁止 if/else/else if 写在同一行</h3><p>条件语句中，若有多个分支，应该写在不同行。</p><p>如下是正确的写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// Good: else 与 if 在不同行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是不符合规范的案例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=c1>// Bad: else 与 if 在同一行
</span></span></span></code></pre></div><h2 id=循环语句><a name=c3-7></a>循环语句</h2><h3 id=规则371-循环语句必须使用大括号><a name=r3-7-1></a>规则3.7.1 循环语句必须使用大括号</h3><p>和条件表达式类似，我们要求for/while循环语句必须加上大括号，即便循环体是空的，或循环语句只有一条。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// Good: 使用了大括号
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>   <span class=c1>// Good：循环体是空，使用大括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>continue</span><span class=p>;</span>           <span class=c1>// Good：continue 表示空逻辑，使用大括号
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>      <span class=c1>// Bad: 应该加上括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>);</span>      <span class=c1>// Bad：使用分号容易让人误解是while语句中的一部分
</span></span></span></code></pre></div><h2 id=switch语句><a name=c3-8></a>switch语句</h2><h3 id=规则381-switch-语句的-casedefault-要缩进一层><a name=r3-8-1></a>规则3.8.1 switch 语句的 case/default 要缩进一层</h3><p>switch 语句的缩进风格如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>             <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething1</span><span class=p>();</span> <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span>           <span class=c1>// Good: 带大括号格式
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=o>:</span>                 <span class=c1>// Bad: case 未缩进
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span>                <span class=c1>// Bad: default 未缩进
</span></span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=表达式><a name=c3-9></a>表达式</h2><h3 id=建议391-表达式换行要保持换行的一致性运算符放行末><a name=a3-9-1></a>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><p>较长的表达式，不满足行宽要求的时候，需要在适当的地方换行。一般在较低优先级运算符或连接符后面截断，运算符或连接符放在行末。
运算符、连接符放在行末，表示“未结束，后续还有”。
例：</p><p>// 假设下面第一行已经不满足行宽要求</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>currentValue</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span>  <span class=c1>// Good：换行后，逻辑操作符放在行尾
</span></span></span><span class=line><span class=cl>    <span class=n>someCondition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>reallyReallyLongVariableName1</span> <span class=o>+</span>    <span class=c1>// Good
</span></span></span><span class=line><span class=cl>             <span class=n>reallyReallyLongVariableName2</span><span class=p>;</span>
</span></span></code></pre></div><p>表达式换行后，注意保持合理对齐，或者4空格缩进。参考下面例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>         <span class=c1>// Good: 4空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>          <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>   <span class=c1>// Good: 保持对齐
</span></span></span></code></pre></div><h2 id=变量赋值><a name=c3-10></a>变量赋值</h2><h3 id=规则3101-多个变量定义和赋值语句不允许写在一行><a name=r3-10-1></a>规则3.10.1 多个变量定义和赋值语句不允许写在一行</h3><p>每行只有一个变量初始化的语句，更容易阅读和理解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span></code></pre></div><p>下面是不符合规范的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Bad：多个变量初始化需要分开放在多行，每行一个变量初始化
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Bad：多个变量定义需要分行，每行一个
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>pointX</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>pointY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Bad：多个变量赋值语句放同一行
</span></span></span></code></pre></div><p>例外：for 循环头、if 初始化语句（C++17）、结构化绑定语句（C++17）中可以声明和初始化多个变量。这些语句中的多个变量声明有较强关联，如果强行分成多行会带来作用域不一致，声明和初始化割裂等问题。</p><h2 id=初始化><a name=c3-11></a>初始化</h2><p>初始化包括结构体、联合体、及数组的初始化</p><h3 id=规则3111-初始化换行时要有缩进并进行合理对齐><a name=r3-11-1></a>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</h3><p>结构体或数组初始化时，如果换行应保持4空格缩进。
从可读性角度出发，选择换行点和对齐位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=指针与引用><a name=c3-12></a>指针与引用</h2><h3 id=建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-1></a>建议3.12.1 指针类型"<code>*</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>指针命名: <code>*</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Bad
</span></span></span></code></pre></div><p>例外：当变量被 const 修饰时，"<code>*</code>&rdquo; 无法跟随变量，此时也不要跟随类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>VERSION</span> <span class=o>=</span> <span class=s>&#34;V100&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-2></a>建议3.12.2 引用类型"<code>&</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>引用命名：<code>&</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*&amp;</span> <span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随类型
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随变量名
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，* 跟随类型，&amp; 跟随变量名
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>      <span class=c1>// Bad
</span></span></span></code></pre></div><h2 id=编译预处理><a name=c3-13></a>编译预处理</h2><h3 id=规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进><a name=r3-13-1></a>规则3.13.1 编译预处理的&rdquo;#&ldquo;统一放在行首，嵌套编译预处理语句时，&rdquo;#&ldquo;可以进行缩进</h3><p>编译预处理的&rdquo;#&ldquo;统一放在行首，即使编译预处理的代码是嵌入在函数体中的，&rdquo;#&ldquo;也应该放在行首。</p><h3 id=规则3132-避免使用宏><a name=r3-13-2></a>规则3.13.2 避免使用宏</h3><p>宏会忽略作用域，类型系统以及各种规则，容易引发问题。应尽量避免使用宏定义，如果必须使用宏，要保证证宏名的唯一性。
在C++中，有许多方式来避免使用宏：</p><ul><li>用const或enum定义易于理解的常量</li><li>用namespace避免名字冲突</li><li>用inline函数避免函数调用的开销</li><li>用template函数来处理多种类型</li></ul><p>在文件头保护宏、条件编译、日志记录等必要场景中可以使用宏。</p><h3 id=规则3133-禁止使用宏来表示常量><a name=r3-13-3></a>规则3.13.3 禁止使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名； 宏没有类型检查，不安全； 宏没有作用域。</p><h3 id=规则3134-禁止使用函数式宏><a name=r3-13-4></a>规则3.13.4 禁止使用函数式宏</h3><p>宏义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。
函数式宏的缺点如下：</p><ul><li>函数式宏缺乏类型检查，不如函数调用检查严格</li><li>宏展开时宏参数不求值，可能会产生非预期结果</li><li>宏没有独立的作用域</li><li>宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性</li><li>在特定场景中必须用编译器对宏的扩展语法，如GCC的statement expression，影响可移植性</li><li>宏在预编译阶段展开后，在期后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题</li><li>对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀</li></ul><p>函数没有宏的上述缺点。但是，函数相比宏，最大的劣势是执行效率不高（增加函数调用的开销和编译器优化的难度）。
为此，可以在必要时使用内联函数。内联函数跟宏类似，也是在调用点展开。不同之处在于内联函数是在编译时展开。</p><p>内联函数兼具函数和宏的优点：</p><ul><li>内联函数执行严格的类型检查</li><li>内联函数的参数求值只会进行一次</li><li>内联函数就地展开，没有函数调用的开销</li><li>内联函数比函数优化得更好</li></ul><p>对于性能要求高的产品代码，可以考虑用内联函数代替函数。</p><p>例外：
在日志记录场景中，需要通过函数式宏保持调用点的文件名（<strong>FILE</strong>）、行号（<strong>LINE</strong>）等信息。</p><h2 id=空格和空行><a name=c3-14></a>空格和空行</h2><h3 id=规则3141-水平空格应该突出关键字和重要信息避免不必要的留白><a name=r3-14-1></a>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</h3><p>水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。总体规则如下：</p><ul><li>if, switch, case, do, while, for等关键字之后加空格；</li><li>小括号内部的两侧，不要加空格；</li><li>大括号内部两侧有无空格，左右必须保持一致；</li><li>一元操作符（& * + ‐ ~ !）之后不要加空格；</li><li>二元操作符（= + ‐ &lt; > * / % | & ^ &lt;= >= == != ）左右两侧加空格</li><li>三目运算符（? :）符号两侧均需要空格</li><li>前置和后置的自增、自减（++ &ndash;）和变量之间不加空格</li><li>结构体成员操作符（. ->）前后不加空格</li><li>逗号(,)前面不加空格，后面增加空格</li><li>对于模板和类型转换(&lt;>)和类型之间不要添加空格</li><li>域操作符(::)前后不要添加空格</li><li>冒号(:)前后根据情况来判断是否要添加空格</li></ul><p>常规情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：大括号前应该留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Good：变量初始化时，=前后应该有空格，分号前面不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>    <span class=c1>// Good：大括号内两侧都无空格
</span></span></span></code></pre></div><p>函数定义和函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>^</span>    <span class=c1>// Bad: 逗号后面需要增加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                 <span class=o>^</span>          <span class=o>^</span>  <span class=c1>// Bad: 函数参数列表的左括号后面不应该有空格，右括号前面不应该有空格
</span></span></span></code></pre></div><p>指针和取地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>     <span class=c1>// Good：*操作符和指针p之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：&amp;操作符和变量x之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>    <span class=c1>// Good：通过.访问成员变量时不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>   <span class=c1>// Good：通过-&gt;访问成员变量时不加空格
</span></span></span></code></pre></div><p>操作符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// Good：赋值操作的=前后都要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5</span><span class=p>;</span>  <span class=c1>// Good：负数的符号和数值之前不要加空格
</span></span></span><span class=line><span class=cl><span class=o>++</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：前置和后置的++/--和变量之间不要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>y</span><span class=p>)</span>  <span class=c1>// Good：布尔操作符前后要加上空格，！操作和变量之间不要空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>/</span> <span class=n>z</span><span class=p>;</span>  <span class=c1>// Good：二元操作符前后要加空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>z</span><span class=p>);</span>    <span class=c1>// Good：括号内的表达式前后不需要加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>  <span class=c1>// Good: 三目运算符， ？和：前后需要添加空格
</span></span></span></code></pre></div><p>循环和条件语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：if关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>           <span class=c1>// Good：else关键字和大括号之间加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{}</span>   <span class=c1>// Good：while关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：for关键字和括号之间加空格，分号之后加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: switch 关键字后面有1空格
</span></span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>     <span class=c1>// Good：case语句条件和冒号之间不加空格
</span></span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>模板和转换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在类型与指针操作符之间留空格也可以, 但要保持一致.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>域操作符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>    <span class=c1>// Good: 命名空间访问，不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>GetValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{}</span>  <span class=c1>// Good: 对于成员函数定义，不要留空格
</span></span></span></code></pre></div><p>冒号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 类的派生需要留有空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 构造函数初始化列表需要留有空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 位域表示也留有空格
</span></span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>XX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 对于public:, private:这种类访问权限的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对于switch-case的case和default后面的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意：当前的集成开发环境（IDE）可以设置删除行尾的空格，请正确配置。</p><h3 id=建议3141-合理安排空行保持代码紧凑><a name=a3-14-1></a>建议3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：</p><ul><li>根据上下内容的相关程度，合理安排空行；</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不使用连续 <strong>3</strong> 个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但namespace的大括号内不作要求。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Bar</span><span class=p>()</span>  <span class=c1>// Bad：最多使用连续2个空行。
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行首不要加入空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行尾不要加入空行
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：函数体内行首不要加空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类><a name=c3-15></a>类</h2><h3 id=规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐><a name=r3-15-1></a>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>      <span class=c1>// 注意没有缩进
</span></span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>();</span>  <span class=c1>// 标准的4空格缩进
</span></span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunctionThatDoesNothing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetVar</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=p>{</span> <span class=n>someVar_</span> <span class=o>=</span> <span class=n>var</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVar</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>someVar_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>SomeInternalFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someOtherVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在各个部分中，建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它成员函数, 数据成员。</p><h3 id=规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行><a name=r3-15-2></a>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 如果所有变量能放在同一行:
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果不能放在同一行,
</span></span></span><span class=line><span class=cl><span class=c1>// 必须置于冒号后, 并缩进4个空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span> <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Good: 逗号后面留有空格
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果初始化列表需要置于多行, 需要逐行对齐
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span>             <span class=c1>// 缩进4个空格
</span></span></span><span class=line><span class=cl>      <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=4-注释><a name=c4></a>4 注释</h1><p>一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明。
注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，<strong>按需注释</strong>。</p><p>注释内容要简洁、明了、无二义性，信息全面且不冗余。</p><p><strong>注释跟代码一样重要。</strong>
写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释，即注释解释代码难以表达的意图，不要重复代码信息。
修改代码时，也要保证其相关注释的一致性。只改代码，不改注释是一种不文明行为，破坏了代码与注释的一致性，让阅读者迷惑、费解，甚至误解。</p><p>使用英文进行注释。</p><h2 id=注释风格><a name=c3-1></a>注释风格</h2><p>在 C++ 代码中，使用 <code>/*</code> <code>*/</code>和 <code>//</code> 都是可以的。
按注释的目的和位置，注释可分为不同的类型，如文件头注释、函数头注释、代码注释等等；
同一类型的注释应该保持统一的风格。</p><p>注意：本文示例代码中，大量使用 &lsquo;//&rsquo; 后置注释只是为了更精确的描述问题，并不代表这种注释风格更好。</p><h2 id=文件头注释><a name=c4-2></a>文件头注释</h2><h3 id=规则31-文件头注释必须包含版权许可><a name=r3-1></a>规则3.1 文件头注释必须包含版权许可</h3><p>/*</p><ul><li>Copyright (c) 2020 XXX</li><li>Licensed under the Apache License, Version 2.0 (the &ldquo;License&rdquo;);</li><li>you may not use this file except in compliance with the License.</li><li>You may obtain a copy of the License at
*</li><li><pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre></li></ul><p>*</p><ul><li>Unless required by applicable law or agreed to in writing, software</li><li>distributed under the License is distributed on an &ldquo;AS IS&rdquo; BASIS,</li><li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li><li>See the License for the specific language governing permissions and</li><li>limitations under the License.
*/</li></ul><h2 id=函数头注释><a name=c4-3></a>函数头注释</h2><h3 id=规则431-公有public函数必须编写函数头注释><a name=r4-3-1></a>规则4.3.1 公有（public）函数必须编写函数头注释</h3><p>公有函数属于类对外提供的接口，调用者需要了解函数的功能、参数的取值范围、返回的结果、注意事项等信息才能正常使用。
特别是参数的取值范围、返回的结果、注意事项等都无法做到自注示，需要编写函数头注释辅助说明。</p><h3 id=规则432-禁止空有格式的函数头注释><a name=r4-3-2></a>规则4.3.2 禁止空有格式的函数头注释</h3><p>并不是所有的函数都需要函数头注释；
函数签名无法表达的信息，加函数头注释辅助说明;</p><p>函数头注释统一放在函数声明或定义上方，使用如下风格之一：
使用<code>//</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 单行函数头
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 多行函数头
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>使用<code>/* */</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 单行函数头 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种单行函数头
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 多行函数头
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func3</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>函数尽量通过函数名自注释，按需写函数头注释。
不要写无用、信息冗余的函数头；不要写空有格式的函数头。</p><p>函数头注释内容可选，但不限于：功能说明、返回值，性能约束、用法、内存约定、算法实现、可重入的要求等等。
模块对外头文件中的函数接口声明，其函数头注释，应当将重要、有用的信息表达清楚。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 返回实际写入的字节数，-1表示写入失败
</span></span></span><span class=line><span class=cl><span class=cm> * 注意，内存 buf 由调用者负责释放
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 函数名：WriteString
</span></span></span><span class=line><span class=cl><span class=cm> * 功能：写入字符串
</span></span></span><span class=line><span class=cl><span class=cm> * 参数：
</span></span></span><span class=line><span class=cl><span class=cm> * 返回值：
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>上面例子中的问题：</p><ul><li>参数、返回值，空有格式没内容</li><li>函数名信息冗余</li><li>关键的 buf 由谁释放没有说清楚</li></ul><h2 id=代码注释><a name=c4-4></a>代码注释</h2><h3 id=规则441-代码注释放于对应代码的上方或右边><a name=r4-4-1></a>规则4.4.1 代码注释放于对应代码的上方或右边</h3><h3 id=规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格><a name=r4-4-2></a>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</h3><p>代码上方的注释，应该保持对应代码一样的缩进。
选择并统一使用如下风格之一：
使用<code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是单行注释
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是多行注释
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>使用<code>/*' '*/</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 这是单行注释 */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种方式的多行注释
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>代码右边的注释，与代码之间，至少留1空格，建议不超过4空格。
通常使用扩展后的 TAB 键即可实现 1-4 空格的缩进。</p><p>选择并统一使用如下风格之一：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>  <span class=c1>// 放右边的注释
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>bar</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>  <span class=cm>/* 放右边的注释 */</span>
</span></span></code></pre></div><p>右置格式在适当的时候，上下对齐会更美观。
对齐后的注释，离左边代码最近的那一行，保证1-4空格的间隔。
例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>A_CONST</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>         <span class=cm>/* 相关的同类注释，可以考虑上下对齐 */</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>ANOTHER_CONST</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>   <span class=cm>/* 上下对齐时，与左侧代码保持间隔 */</span>
</span></span></code></pre></div><p>当右置的注释超过行宽时，请考虑将注释置于代码上方。</p><h3 id=规则443-不用的代码段直接删除不要注释掉><a name=r4-4-3></a>规则4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。
正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 /* */ 和 //，还包括 #if 0， #ifdef NEVER_DEFINED 等等。</p><h1 id=5-头文件><a name=c5></a>5 头文件</h1><h2 id=头文件职责><a name=c5-1></a>头文件职责</h2><p>头文件是模块或文件的对外接口，头文件的设计体现了大部分的系统设计。
头文件中适合放置接口的声明，不适合放置实现（内联函数除外）。对于cpp文件中内部才需要使用的函数、宏、枚举、结构定义等不要放在头文件中。
头文件应当职责单一。头文件过于复杂，依赖过于复杂还是导致编译时间过长的主要原因。</p><h3 id=建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口><a name=a5-1-1></a>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</h3><p>通常情况下，每个.cpp文件都有一个相应的.h，用于放置对外提供的函数声明、宏定义、类型定义等。
如果一个.cpp文件不需要对外公布任何接口，则其就不应当存在。
例外：<strong>程序的入口（如main函数所在的文件），单元测试代码，动态库代码。</strong></p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifndef FOO_H
</span></span></span><span class=line><span class=cl><span class=cp>#define FOO_H
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Foo.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span> <span class=c1>// Good: 对内函数的声明放在.cpp文件的头部，并声明为匿名namespace或者static限制其作用域
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=头文件依赖><a name=c5-2></a>头文件依赖</h2><h3 id=规则521-禁止头文件循环依赖><a name=r5-2-1></a>规则5.2.1 禁止头文件循环依赖</h3><p>头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。</p><p>头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。</p><h3 id=规则522-头文件必须编写define保护防止重复包含><a name=r5-2-4></a>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</h3><p>为防止头文件被重复包含，所有头文件都应当使用 #define 保护；不要使用 #pragma once</p><p>定义包含保护符时，应该遵守如下规则：
1）保护符使用唯一名称；
2）不要在受保护部分的前后放置代码或者注释，文件头注释除外。</p><p>示例：假定timer模块的timer.h，其目录为timer/include/timer.h,应按如下方式保护：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp>#define TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h3 id=规则523-禁止通过声明的方式引用外部函数接口变量><a name=r5-2-5></a>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。
通过 extern 声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。
同时这种隐式依赖，容易导致架构腐化。</p><p>不符合规范的案例：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>   <span class=c1>// Bad: 通过extern的方式使用外部函数
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>应该改为：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>   </span><span class=c1>// Good: 通过包含头文件的方式使用其他.cpp提供的接口
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例外，有些场景需要引用其内部函数，但并不想侵入代码时，可以 extern 声明方式引用。
如：
针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数；
当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数。</p><h3 id=规则524-禁止在extern-c中包含头文件><a name=r5-2-6></a>规则5.2.4 禁止在extern &ldquo;C"中包含头文件</h3><p>在 extern &ldquo;C&rdquo; 中包含头文件，有可能会导致 extern &ldquo;C&rdquo; 嵌套，部分编译器对 extern &ldquo;C&rdquo; 嵌套层次有限制，嵌套层次太多会编译错误。</p><p>在C，C++混合编程的情况下，在extern &ldquo;C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。</p><p>示例，存在a.h和b.h两个头文件：</p><p>// a.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define A(value) Foo(value)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>使用C++预处理器展开b.h，将会得到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按照 a.h 作者的本意，函数 Foo 是一个 C++ 自由函数，其链接规范为 &ldquo;C++"。
但在 b.h 中，由于 <code>#include "a.h"</code> 被放到了 <code>extern "C"</code> 的内部，函数 Foo 的链接规范被不正确地更改了。</p><p>例外：
如果在 C++ 编译环境中，想引用纯C的头文件，这些C头文件并没有<code> extern "C"</code> 修饰。非侵入式的做法是，在 <code>extern "C"</code> 中去包含C头文件。</p><h3 id=建议521尽量避免使用前置声明而是通过include来包含头文件><a name=a5-2-1></a>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</h3><p>前置声明（forward declaration）通常指类、模板的纯粹声明，没伴随着其定义。</p><ul><li>优点：<ol><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li></ol></li><li>缺点：<ol><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li><li>前置声明可能会被库的后续更改所破坏。前置声明模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间<code> std::</code> 的 symbol 时，其行为未定义（在C++11标准规范中明确说明）。</li><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</li><li>很难判断什么时候该用前置声明，什么时候该用<code>#include</code>，某些场景下面前置声明和<code>#include</code>互换以后会导致意想不到的结果。</li></ol></li></ul><p>所以我们尽可能避免使用前置声明，而是使用#include头文件来保证依赖关系。</p><h1 id=6-作用域><a name=c6></a>6 作用域</h1><h2 id=命名空间><a name=c6-1></a>命名空间</h2><h3 id=建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰><a name=a6-1-1></a>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</h3><p>在C++ 2003标准规范中，使用static修饰文件作用域的变量，函数等被标记为deprecated特性，所以更推荐使用匿名namespace。</p><p>主要原因如下：</p><ol><li>static在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数，静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li>static只能保证变量，常量和函数的文件作用域，但是namespace还可以封装类型等。</li><li>统一namespace来处理C++的作用域，而不需要同时使用static和namespace来管理。</li><li>static修饰的函数不能用来实例化模板，而匿名namespace可以。</li></ol><p>但是不要在 .h 中使用中使用匿名namespace或者static。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_COUNT</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InternalFun</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>MAX_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则611-不要在头文件中或者include之前使用using导入命名空间><a name=r6-1-1></a>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</h3><p>说明：使用using导入命名空间会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using导入命名空间。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件a.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件b.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Fun</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 源代码a.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>G</span><span class=p>();</span> <span class=c1>// using namespace NamespaceA在#include “b.h”之前，引发歧义：NamespaceA::Fun，NamespaceB::Fun调用不明确
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于在头文件中使用using导入单个符号或定义别名，允许在模块自定义名字空间中使用，但禁止在全局名字空间中使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fancy/string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Bad，禁止向全局名字空间导入符号
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Good，可以在模块自定义名字空间中导入符号
</span></span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>MyVector</span> <span class=o>=</span> <span class=n>fancy</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>  <span class=c1>// Good，C++11可在自定义名字空间中定义别名
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=全局函数和静态成员函数><a name=c6-2></a>全局函数和静态成员函数</h2><h3 id=建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数><a name=a6-2-1></a>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</h3><p>说明：非成员函数放在名字空间内可避免污染全局作用域， 也不要用类+静态成员方法来简单管理全局函数。 如果某个全局函数和某个类有紧密联系， 那么可以作为类的静态成员函数。</p><p>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>File</span> <span class=n>CreateTempFile</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局常量和静态成员常量><a name=c6-3></a>全局常量和静态成员常量</h2><h3 id=建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量><a name=a6-3-1></a>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</h3><p>说明：全局常量放在命名空间内可避免污染全局作用域， 也不要用类+静态成员常量来简单管理全局常量。 如果某个全局常量和某个类有紧密联系， 那么可以作为类的静态成员常量。</p><p>如果你需要定义一些全局常量，只给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>SEPARATOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局变量><a name=c6-4></a>全局变量</h2><h3 id=建议641-尽量避免使用全局变量考虑使用单例模式><a name=a6-4-1></a>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>说明：全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_counter</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>使用单实例模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Counter</span><span class=o>&amp;</span> <span class=n>GetInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Counter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  <span class=c1>// 单实例实现简单举例
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Increase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Print</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Counter</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Print</span><span class=p>();</span>
</span></span></code></pre></div><p>实现单例模式以后，实现了全局唯一一个实例，和全局变量同样的效果，并且单实例提供了更好的封装性。</p><p>例外：有的时候全局变量的作用域仅仅是模块内部，这样进程空间里面就会有多个全局变量实例，每个模块持有一份，这种场景下是无法使用单例模式解决的。</p><h1 id=7-类><a name=c7></a>7 类</h1><h2 id=构造拷贝构造赋值和析构函数><a name=c7-1></a>构造，拷贝构造，赋值和析构函数</h2><p>构造，拷贝，移动和析构函数提供了对象的生命周期管理方法：</p><ul><li>构造函数（constructor）： <code>X()</code></li><li>拷贝构造函数（copy constructor）：<code>X(const X&)</code></li><li>拷贝赋值操作符（copy assignment）：<code>operator=(const X&)</code></li><li>移动构造函数（move constructor）：<code>X(X&&)</code> <em>C++11以后提供</em></li><li>移动赋值操作符（move assignment）：<code>operator=(X&&)</code> <em>C++11以后提供</em></li><li>析构函数（destructor）：<code>~X()</code></li></ul><h3 id=规则711-类的成员变量必须显式初始化><a name=r7-1-1></a>规则7.1.1 类的成员变量必须显式初始化</h3><p>说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。</p><p>例外：</p><ul><li>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化。</li></ul><p>示例：如下代码没有构造函数，私有数据成员无法初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//…
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Message</span> <span class=n>message</span><span class=p>;</span>   <span class=c1>// message成员变量没有初始化
</span></span></span><span class=line><span class=cl><span class=n>message</span><span class=p>.</span><span class=n>ProcessOutMsg</span><span class=p>();</span>   <span class=c1>// 后续使用存在隐患
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因此，有必要定义默认构造函数，如下：
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgID_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgBuffer_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// …
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span> <span class=c1>// 具有默认构造函数，不需要显式初始化
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化><a name=a7-1-1></a>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</h3><p>说明：C++11的声明时初始化可以一目了然的看出成员初始值，应当优先使用。如果成员初始化值和构造函数相关，或者不支持C++11，则应当优先使用构造函数初始化列表来初始化成员。相比起在构造函数体中对成员赋值，初始化列表的代码更简洁，执行性能更好，而且可以对const成员和引用成员初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1>// Good，优先使用初始化列表
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>msgBuffer_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Bad，不推荐在构造函数中赋值
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>  <span class=c1>// Good，C++11中使用
</span></span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则712-为避免隐式转换将单参数构造函数声明为explicit><a name=r7-1-2></a>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</h3><p>说明：单参数构造函数如果没有用explicit声明，则会成为隐式转换函数。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span><span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ProcessFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFoo</span><span class=p>(</span><span class=n>test</span><span class=p>);</span>  <span class=c1>// 编译不通过
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码编译不通过，因为<code>ProcessFoo</code>需要的参数是Foo类型，传入的string类型不匹配。</p><p>如果将Foo构造函数的explicit关键字移除，那么调用<code>ProcessFoo</code>传入的string就会触发隐式转换，生成一个临时的Foo对象。往往这种隐式转换是让人迷惑的，并且容易隐藏Bug，得到了一个不期望的类型转换。所以对于单参数的构造函数是要求explicit声明。</p><h3 id=规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止><a name=r7-1-3></a>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</h3><p>说明：如果用户不定义，编译器默认会生成拷贝构造函数和拷贝赋值操作符， 移动构造和移动赋值操作符（移动语义的函数C++11以后才有）。
如果我们不要使用拷贝构造函数，或者赋值操作符，请明确拒绝：</p><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li><p>使用C++11提供的delete, 请参见后面现代C++的相关章节。</p></li><li><p>推荐继承NoCopyable、NoMovable，禁止使用DISALLOW_COPY_AND_MOVE，DISALLOW_COPY，DISALLOW_MOVE等宏。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NoCopyable</span><span class=p>,</span> <span class=k>public</span> <span class=n>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>NoCopyable和NoMovable的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoCopyable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止><a name=r7-1-4></a>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><p>拷贝构造函数和拷贝赋值操作符都是具有拷贝语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, C++11可以使用delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则715-移动构造和移动赋值操作符应该是成对出现或者禁止><a name=r7-1-5></a>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</h3><p>在C++11中增加了move操作，如果需要某个类支持移动操作，那么需要实现移动构造和移动赋值操作符。</p><p>移动构造函数和移动赋值操作符都是具有移动语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, 使用C++11的delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则716-禁止在构造函数和析构函数中调用虚函数><a name=r7-1-6></a>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>说明：在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。
在C++中，一个基类一次只构造一个完整的对象。</p><p>示例：类Base是基类，Sub是派生类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Log</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// 不同的派生类调用不同的日志文件
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>()</span>         <span class=c1>// 基类构造函数
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Log</span><span class=p>();</span>           <span class=c1>// 调用虚函数Log
</span></span></span><span class=line><span class=cl><span class=p>}</span>                                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Log</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当执行如下语句：
<code>Sub sub;</code>
会先执行Sub的构造函数，但首先调用Base的构造函数，由于Base的构造函数调用虚函数Log，此时Log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为。
同样的道理也适用于析构函数。</p><h3 id=规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数><a name=r7-1-7></a>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</h3><p>如果报一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。
【反例】
如下代码中，基类没有定义拷贝构造函数或拷贝赋值操作符，编译器会自动生成这两个特殊成员函数，
如果派生类对象赋值给基类对象时就发生切片。可以将此例中的拷贝构造函数和拷贝赋值操作符声明为delete，编译器可检查出此类赋值行为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=o>&amp;</span><span class=n>base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>other</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span> <span class=c1>// 不符合：发生切片
</span></span></span><span class=line><span class=cl>    <span class=n>other</span><span class=p>.</span><span class=n>Fun</span><span class=p>();</span> <span class=c1>// 调用的时Base类的Fun函数
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// 传入的是派生类对象
</span></span></span></code></pre></div><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><h2 id=继承><a name=c7-2></a>继承</h2><h3 id=规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final><a name=r7-2-1></a>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</h3><p>说明：只有基类析构函数是virtual，通过多态调用的时候才能保证派生类的析构函数被调用。</p><p>示例：基类的析构函数没有声明为virtual导致了内存泄漏。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=n>cpp</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=p>()</span> <span class=o>:</span> <span class=n>numbers_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Sub&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>size_t</span> <span class=n>numberCount</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers_</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=n>numberCount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>numbers_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>args</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>基底クラスBaseのデストラクタがvirtualで宣言されていないため、オブジェクトが破棄されたときに派生クラスSubのデストラクタが呼び出されず、メモリリークが発生します。
例外：
NoCopyable、NoMovableのように何の振る舞いもなく、単なる識別子として使用するクラスは、virtualデストラクタやfinalの定義が不要です。</p><h3 id=ルール722-仮想関数にデフォルト引数値を使用しないこと><a name=r7-2-2></a>ルール7.2.2 仮想関数にデフォルト引数値を使用しないこと</h3><p>説明：C++では、仮想関数は動的にバインドされますが、関数のデフォルト引数はコンパイル時に静的にバインドされます。つまり、最終的に実行される関数は、派生クラスで定義されたものですが、基底クラスのデフォルト引数値を使用することになります。仮想関数のオーバーロード時に、引数宣言が一致しないことで使用者に混乱や問題を引き起こすのを避けるため、すべての仮想関数にデフォルト引数値を宣言しないように規定しています。
例：仮想関数displayのデフォルト引数値textはコンパイル時に決定され、実行時には決定されません。これによりポリモーフィズムの目的が達成されません：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Base!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span>  <span class=o>=</span> <span class=s>&#34;Sub!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Sub</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>  <span class=c1>// プログラム出力結果: Base! 期待する出力：Sub!
</span></span></span><span class=line><span class=cl>    <span class=n>sub</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>   <span class=c1>// プログラム出力結果: Sub!
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=ルール723-継承された非仮想関数を再定義しないこと><a name=r7-2-3></a>ルール7.2.3 継承された非仮想関数を再定義しないこと</h3><p>説明：非仮想関数は動的バインドを実装できないため、仮想関数だけが動的バインドを実装できます：基底クラスへのポインタを操作するだけで、正しい結果を得ることができます。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>                    
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sub</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>    <span class=c1>// 子クラスのFunを呼び出す                 
</span></span></span><span class=line><span class=cl><span class=n>base</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>   <span class=c1>// 親クラスのFunを呼び出す
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><h2 id=多重継承><a name=c7-3></a>多重継承</h2><p>実際の開発プロセスでは、多重継承を使用するシナリオは比較的少ないです。なぜなら、多重継承の使用には以下のような典型的な問題があるからです：</p><ol><li>菱形継承によるデータの重複と名前の曖昧性。そのため、C++はvirtual継承を導入してこの問題を解決しています。</li><li>菱形継承でなくても、複数の親クラス間で名前が衝突し、曖昧性を引き起こす可能性がある。</li><li>子クラスが複数の親クラスのメソッドを拡張または書き換える必要がある場合、子クラスの責任が不明瞭になり、意味が混乱する。</li><li>委任に比べて、継承はホワイトボックス再利用であり、子クラスは親クラスのprotectedメンバーにアクセスでき、これによりより強い結合が生じます。そして多重継承は、複数の親クラスを結合するため、単一継承に比べてさらに強い結合関係を生み出します。</li></ol><p>多重継承には以下の利点があります：
多重継承は、複数のインターフェースやクラスを組み合わせて再利用するためのよりシンプルな方法を提供します。</p><p>したがって、多重継承は以下のいくつかの状況でのみ使用が許可されています。</p><h3 id=提案731-インタフェースの分離と多役割の組み合わせに多重継承を使用する><a name=a7-3-1></a>提案7.3.1 インタフェースの分離と多役割の組み合わせに多重継承を使用する</h3><p>特定のクラスが多重インターフェースを実装する必要がある場合、多重継承を使用して複数の分離したインターフェースを組み合わせることができます。これは、scala言語のtraits混入に似ています。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role1</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role2</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role3</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object1</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role1</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role2</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>C++標準ライブラリでも同様の実装例があります：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_istream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_ostream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_iostream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>basic_istream</span><span class=p>,</span> <span class=k>public</span> <span class=n>basic_ostream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=オーバーロード><a name=c7-4></a>オーバーロード</h2><p>オペレータのオーバーロードには十分な理由が必要であり、オペレータの元の意味を変えないでください。たとえば、減算演算に&rsquo;+&lsquo;演算子を使用しないでください。
オペレータのオーバーロードはコードをより直感的にしますが、いくつかの欠点もあります：</p><ul><li>直感を惑わせ、内蔵型と同様に高性能であると誤解し、性能低下の可能性を無視する。</li><li>問題の特定時に直感的ではなく、関数名で検索する方が演算子で検索するより明らかに便利です。</li><li>オペレータの振る舞いが直感的でない場合（たとえば&rsquo;+&lsquo;演算子を減算に使用する）、コードが混乱します。</li><li>代入演算子のオーバーロードで導入された暗黙の変換は、深いバグを隠す可能性があります。=,==演算子の代わりに、Equals()、CopyFrom()などの関数を定義できます。</li></ul><h1 id=8-関数><a name=c8></a>8 関数</h1><h2 id=関数設計><a name=c8-1></a>関数設計</h2><h3 id=ルール811-関数が長くなりすぎないようにし関数は50行以内空行とコメントを除くにする><a name=r8-1-1></a>ルール8.1.1 関数が長くなりすぎないようにし、関数は50行以内（空行とコメントを除く）にする</h3><p>関数は1画面で表示できるようにすべきです（50行以内）、一つのことに集中し、それを完璧にこなすべきです。</p><p>長すぎる関数は、関数の機能が単一ではなく、過度に複雑であるか、過度に詳細を提示しているか、さらに抽象化されていないことを意味している可能性があります。</p><p>例外：アルゴリズムを実装する特定の関数は、アルゴリズムの凝集性と機能の包括性のために、50行を超える可能性があります。</p><p>長い関数が現在非常にうまく動作していても、誰かが変更したときに新しい問題が発生し、発見しにくいバグを引き起こす可能性があります。
それをより短く、より管理しやすいいくつかの関数に分割して、他人がコードを読んだり変更したりしやすくすることを強くお勧めします。</p><h2 id=インライン関数><a name=c8-2></a>インライン関数</h2><h3 id=提案821-インライン関数は10行以内空行とコメントを除くにする><a name=a8-2-1></a>提案8.2.1 インライン関数は10行以内（空行とコメントを除く）にする</h3><p><strong>説明</strong>：インライン関数は通常の関数の特性を持ち、関数呼び出しの処理に関してのみ通常の関数と異なります。通常の関数を呼び出すときは、プログラムの実行権を呼び出された関数に移し、その後呼び出し元の関数に戻ります。一方、インライン関数は呼び出し時に、呼び出し式をインライン関数本体で置き換えます。</p><p>インライン関数は1〜10行程度の小さな関数に適しています。多くの文を含む大きな関数の場合、関数呼び出しと返却のオーバーヘッドは比較的小さく、インライン関数を使用する必要はありません。通常のコンパイラはインライン化を放棄し、通常の方法で関数を呼び出します。</p><p>インライン関数にループ、分岐（switch）、try-catchなどの複雑な制御構造が含まれる場合、通常のコンパイラはその関数を通常の関数として扱います。</p><p><strong>仮想関数と再帰関数はインライン関数として使用できません</strong>。</p><h2 id=関数パラメータ><a name=c8-3></a>関数パラメータ</h2><h3 id=提案831-参照を使用してポインタを置き換える><a name=a8-3-1></a>提案8.3.1 参照を使用してポインタを置き換える</h3><p><strong>説明</strong>：参照はポインタよりも安全です。なぜなら、参照は必ずnullではなく、必ず他の対象を指すことはなく、nullポインタのチェックは不要だからです。</p><p>パラメータが変更されないようにconstを使用し、コードの読者がそのパラメータが変更されないことを明確に理解できるようにすることで、コードの可読性が大幅に向上します。</p><p>例外：コンパイル時に長さが不明な配列を入力パラメータとして渡す場合は、参照ではなくポインタを使用できます。</p><h3 id=提案832-強い型のパラメータを使用しvoidを使用しないこと><a name=a8-3-2></a>提案8.3.2 強い型のパラメータを使用し、void*を使用しないこと</h3><p>異なる言語は強い型と弱い型に対して独自の見解を持っていますが、一般的にC/C++は強い型の言語であると考えられています。使用している言語が強い型であるなら、そのスタイルを維持すべきです。
利点はできるだけ早くコンパイラが型の不一致を検出することです。</p><p>強い型を使用することで、コンパイラがエラーを発見するのを助けます。以下のコードでは、関数FooListAddNodeの使用に注意してください：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FooNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BarNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FooListAddNode</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span> <span class=c1>// Bad: ここでは void * 型でパラメータを渡しています
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=p>(</span><span class=n>FooNode</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAppend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_FooList</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>foo</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MakeTheList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BarNode</span> <span class=o>*</span><span class=n>bar</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FooListAddNode</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span>        <span class=c1>// Wrong: ここでは foo を渡すつもりでしたが、誤って bar を渡してしまいましたが、エラーが発生しませんでした
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>テンプレート関数を使用してパラメータの型の変化を実装できます。</li><li>ポリモーフィズムを実装するために基底クラスのポインタを使用できます。</li></ol><h3 id=提案833-関数のパラメータ数は5つ以下にする><a name=a8-3-3></a>提案8.3.3 関数のパラメータ数は5つ以下にする</h3><p>関数のパラメータが多すぎると、外部の変化に対して関数が敏感になり、保守作業に影響を与えます。関数のパラメータが多すぎると、テスト作業も増大します。</p><p>もし5つ以上になる場合は、以下を検討してください:</p><ul><li>関数を分割できるか検討する</li><li>関連するパラメータをまとめて構造体を定義できるか検討する</li></ul><h1 id=9-cのその他の機能><a name=c9></a>9 C++のその他の機能</h1><h2 id=定数と初期化><a name=c9-1></a>定数と初期化</h2><p>変更されない値は理解しやすく、追跡しやすく、分析しやすいので、変数の代わりにできるだけ定数を使用すべきです。値を定義するときは、const をデフォルトの選択肢として使用すべきです。</p><h3 id=ルール911-マクロを使用して定数を表すことを禁止する><a name=r9-1-1></a>ルール9.1.1 マクロを使用して定数を表すことを禁止する</h3><p><strong>説明</strong>：マクロは単なるテキスト置換であり、プリプロセス段階で完了し、ランタイムエラー時に直接値を報告します。デバッグトレース時も値のみを表示し、マクロ名は表示しません。マクロには型チェックがなく、安全ではありません。マクロにはスコープがありません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_MSISDN_LEN 20    </span><span class=c1>// 悪い例
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++ではconst定数を使用してください
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 良い例
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++11以降のバージョンでは、constexprを使用できます
</span></span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=提案911-関連する整数定数のグループは列挙型として定義する><a name=a9-1-1></a>提案9.1.1 関連する整数定数のグループは列挙型として定義する</h3><p><strong>説明</strong>：列挙型は<code>#define</code>や<code>const int</code>よりも安全です。コンパイラはパラメータ値が列挙型の範囲内にあるかどうかをチェックし、エラーを防ぎます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 良い例：
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Week</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUNDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MONDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TUESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WEDNESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>THURSDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FRIDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SATURDAY</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLACK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=n>Week</span> <span class=n>today</span><span class=p>,</span> <span class=n>Color</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// コンパイルエラー、パラメータの型が間違っています
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 悪い例:
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SUNDAY</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MONDAY</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLACK</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLUE</span>   <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=kt>int</span> <span class=n>today</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// エラーになりません
</span></span></span></code></pre></div><p>列挙値が特定の数値に対応する必要がある場合は、宣言時に明示的に値を割り当てる必要があります。そうでない場合は、明示的に値を割り当てないようにし、値の重複を避け、メンテナンス作業（メンバーの追加や削除）を軽減してください。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 良い例：Sプロトコルで定義されたデバイスID値、デバイスタイプを識別するために使用されます
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>DeviceType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_UNKNOWN</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_DSMP</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_ISMG</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_WAPPORTAL</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>プログラム内部で使用され、分類のみを目的とする場合は、明示的に値を割り当ててはいけません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 良い例：プログラム内でセッションステータスを識別するために使用される列挙型の定義
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>SessionState</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INIT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WAITING_FOR_RESPONSE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>重複する列挙値をできるだけ避け、必要であれば既に定義された列挙値を使用して修飾する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RTCPType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SR</span> <span class=o>=</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MIN_TYPE</span> <span class=o>=</span> <span class=n>RTCP_SR</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RR</span>    <span class=o>=</span> <span class=mi>201</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SDES</span>  <span class=o>=</span> <span class=mi>202</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_BYE</span>   <span class=o>=</span> <span class=mi>203</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_APP</span>   <span class=o>=</span> <span class=mi>204</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RTPFB</span> <span class=o>=</span> <span class=mi>205</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PSFB</span>  <span class=o>=</span> <span class=mi>206</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_XR</span>  <span class=o>=</span> <span class=mi>207</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RSI</span> <span class=o>=</span> <span class=mi>208</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PUBPORTS</span> <span class=o>=</span> <span class=mi>209</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MAX_TYPE</span> <span class=o>=</span> <span class=n>RTCP_PUBPORTS</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=ルール912-デビルナンバーを使用しないこと><a name=r9-1-2></a>ルール9.1.2 デビルナンバーを使用しないこと</h3><p>デビルナンバーとは、理解不能で難解な数字のことです。</p><p>デビルナンバーは白か黒かの概念ではなく、理解不能にも程度があり、自分で判断する必要があります。
例えば、数字の12は、文脈によって状況が異なります：
type = 12; は理解できませんが、 <code>monthsCount = yearsCount * 12</code>; は理解できます。
数字の0も場合によってはデビルナンバーになり得ます。例えば、<code>status = 0</code>; では何のステータスか分かりません。</p><p>解決策：
局所的に使用される数字には、コメントを追加して説明する。
複数箇所で使用される数字には、const定数を定義し、シンボル名で自己文書化を行う。</p><p>以下のことは禁止です：
数字の意味を説明するシンボルを使用しないこと。例えば <code>const int ZERO = 0</code>
シンボルの名前が値の範囲を制限すること。例えば <code>const int XX_TIMER_INTERVAL_300MS = 300</code>、直接 <code>XX_TIMER_INTERVAL_MS</code> を使用して、その定数がタイマーの間隔であることを示す。</p><h3 id=ルール913-定数は単一責任の原則に従うべき><a name=r9-1-3></a>ルール9.1.3 定数は単一責任の原則に従うべき</h3><p><strong>説明</strong>：定数は特定の機能のみを表し、一つの定数に複数の用途を持たせてはいけません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 良い例：プロトコルAとプロトコルBにおいて、MSISDNの長さはどちらも20です。
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>A_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>B_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// または異なる名前空間を使用：
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=ルール914-podオブジェクト以外にmemcpy_smemset_sを使用して初期化しないこと><a name=r9-1-4></a>ルール9.1.4 PODオブジェクト以外にmemcpy_s、memset_sを使用して初期化しないこと</h3><p><strong>説明</strong>：<code>POD</code>は<code>Plain Old Data</code>の略で、C++ 98標準(ISO/IEC 14882, first edition, 1998-09-01)で導入された概念で、<code>POD</code>型は主に<code>int</code>, <code>char</code>, <code>float</code>，<code>double</code>，<code>enumeration</code>，<code>void</code>，ポインタ等の基本型と集合型を含み、カプセル化やオブジェクト指向の特性（ユーザ定義のコンストラクタ/代入/デストラクタ、基底クラス、仮想関数等）を使用できません。</p><p>非POD型（例えば非集合型のclassオブジェクト）は仮想関数を含む可能性があり、メモリレイアウトは不確定で、コンパイラに依存し、不適切なメモリコピーは重大な問題を引き起こす可能性があります。</p><p>集合型のclassであっても、直接のメモリコピーと比較を使用することは、情報隠蔽とデータ保護の役割を損なうため、<code>memcpy_s</code>や<code>memset_s</code>操作は推奨されません。</p><p>POD型の詳細な説明は付録を参照してください。</p><h3 id=提案912-変数は使用時に宣言し初期化する><a name=a9-1-2></a>提案9.1.2 変数は使用時に宣言し、初期化する</h3><p><strong>説明</strong>：変数が使用前に初期値が設定されていないことは、一般的な初歩的なプログラミングミスです。使用時に変数を宣言し、同時に初期化することで、このような初歩的なミスを簡単に回避できます。</p><p>関数の開始位置で変数を宣言し、後で使用する場合、スコープは関数の実装全体をカバーし、次のような問題を引き起こしやすくなります。</p><ul><li>プログラムは理解と保守が困難になる：変数の定義と使用が分離される。</li><li>変数を適切に初期化することが困難になる：関数の開始時に十分な情報がなく、しばしばデフォルトの空値（例えばゼロ）で初期化され、これはしばしば無駄であり、変数が有効な値で設定される前に使用されるとエラーを引き起こす可能性がある。</li></ul><p>変数のスコープを最小化する原則と近接宣言の原則に従い、変数の型と初期値を理解しやすくします。特に、初期化を使用して宣言と代入を分離すべきです。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 悪い例：宣言と初期化が分離している
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>        <span class=c1>// 宣言時に初期化されていない：デフォルトコンストラクタを呼び出す
</span></span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>;</span>  <span class=c1>// 再び代入演算子を呼び出す；宣言と定義が異なる場所にあるため、理解が難しい
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 良い例：宣言と初期化が一体で、理解しやすい
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=nf>name</span><span class=p>(</span><span class=s>&#34;zhangsan&#34;</span><span class=p>);</span>  <span class=c1>// コンストラクタを呼び出す
</span></span></span></code></pre></div><h2 id=式><a name=c9-2></a>式</h2><h3 id=ルール921-変数のインクリメントまたはデクリメント演算を含む式で同じ変数を再度参照してはいけない><a name=r9-2-1></a>ルール9.2.1 変数のインクリメントまたはデクリメント演算を含む式で、同じ変数を再度参照してはいけない</h3><p>変数のインクリメントまたはデクリメント演算を含む式で、その変数を再度参照すると、C++標準では結果が明確に定義されていません。各コンパイラや同じコンパイラの異なるバージョンの実装は異なる可能性があります。
より良い移植性のために、標準で定義されていない演算順序について何の仮定もしてはいけません。</p><p>注意してください、演算順序の問題は括弧を使用して解決することはできません。これは優先順位の問題ではないからです。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Bad: b[i]の演算とi++の順序は明確ではありません。
</span></span></span></code></pre></div><p>正しい書き方は、インクリメントまたはデクリメント演算を別行にすることです：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 別行にする
</span></span></span></code></pre></div><p>関数の引数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   <span class=c1>// Bad: 第2引数を渡すとき、インクリメント演算が発生したかどうかは不明です
</span></span></span></code></pre></div><p>正しい書き方</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 別行にする
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=ルール922-switch文には必ずdefault節を含める><a name=r9-2-2></a>ルール9.2.2 switch文には必ずdefault節を含める</h3><p>ほとんどの場合、switch文にはdefault節が必要です。これにより、caseラベルの処理が漏れた場合でも、デフォルトの処理が行われます。</p><p>例外：
switch条件変数が列挙型で、case分岐がすべての値をカバーしている場合、default節を追加するのはやや冗長です。
現代のコンパイラは、switch文で列挙値のcase分岐が漏れているかどうかをチェックする機能を持っており、対応するwarningを出すことができます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// switch条件変数が列挙型であるため、default処理分岐を追加する必要はありません
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>RED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoRedThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>BLUE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoBlueThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=提案921-式の比較では左側は変化しやすく右側は変化しにくいという原則に従うべきです><a name=a9-2-1></a>提案9.2.1 式の比較では、左側は変化しやすく、右側は変化しにくいという原則に従うべきです</h3><p>変数と定数を比較するとき、定数を左側に置くと、if (MAX == v) は読み慣れた形式ではなく、if (MAX > v) は理解しにくいです。
人の通常の読書習慣や表現習慣に従い、定数を右側に置くべきです。以下のように書くべきです：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>ただし、<code>if (MIN &lt; value && value &lt; MAX)</code> のように範囲を表す場合は、前半部分で定数が左側に置かれます。</p><p>&lsquo;==&rsquo; を &lsquo;=&rsquo; と誤って書く心配はありません。なぜなら<code> if (value = MAX)</code> にはコンパイル警告があり、他の静的チェックツールもエラーを報告するからです。ツールに任せましょう。コードは可読性第一です。</p><h3 id=提案922-演算子の優先順位を明確にするために括弧を使用する><a name=a9-2-2></a>提案9.2.2 演算子の優先順位を明確にするために括弧を使用する</h3><p>演算子の優先順位を括弧で明確にし、デフォルトの優先順位が設計思想と一致しないことによるプログラムエラーを防ぐ。また、コードをより明確に可読にする。しかし、括弧が多すぎると可読性が低下します。以下は括弧の使用に関する提案です。</p><ul><li>二項以上の演算子で、異なる演算子が混在する場合は括弧を使用する</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>         <span class=cm>/* 演算子が同じ場合は括弧不要 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>     <span class=cm>/* カンマで区切られた式は括弧不要 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>      <span class=cm>/* 演算子が異なる場合は括弧が必要 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=p>(</span><span class=n>b</span> <span class=o>/</span> <span class=mi>5</span><span class=p>);</span>       <span class=cm>/* 演算子が異なる場合は括弧が必要 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=p>(</span><span class=n>a</span> <span class=err>–</span> <span class=n>b</span><span class=p>);</span>    <span class=cm>/* 演算子が異なる場合は括弧が必要 */</span>
</span></span></code></pre></div><h2 id=型変換><a name=c9-3></a>型変換</h2><p>型分岐を使用して動作をカスタマイズすることは避けてください：型分岐を使用して動作をカスタマイズすることは、C++でCコードを書こうとしている明らかな兆候であり、非常に柔軟性の低い技術です。新しい型を追加するときに、すべての分岐を修正し忘れた場合でも、コンパイラは知らせてくれません。テンプレートと仮想関数を使用して、呼び出し側のコードではなく型自身に動作を決定させましょう。</p><p>型変換の使用を避けることをお勧めします。コードの型設計において、各データのデータ型を考慮すべきであり、型変換を過度に使用して問題を解決すべきではありません。基本型を設計する際には、以下の点を考慮してください：</p><ul><li>符号付きか符号なしのどちらか</li><li>floatかdoubleのどちらか</li><li>int8、int16、int32、int64のどれか、整数の長さを決定する</li></ul><p>しかし、型変換の使用を禁止することはできません。なぜなら、C++はマシン指向のプログラミング言語であり、ポインターやアドレスを扱い、さまざまなサードパーティや低レベルのAPIとやり取りするからです。それらのAPIの型設計が必ずしも合理的とは限らず、この適応過程で型変換が頻繁に発生します。</p><p>例外：関数を呼び出すとき、関数の結果を処理したくない場合は、それが最良の選択であるかどうかをまず検討する必要があります。もし本当に関数の返り値を処理したくない場合は、(void)変換を使用して解決することができます。</p><h3 id=ルール931-型変換を使用する必要がある場合はcが提供する型変換を使用しcスタイルの型変換を使用しないこと><a name=r9-3-1></a>ルール9.3.1 型変換を使用する必要がある場合は、C++が提供する型変換を使用し、Cスタイルの型変換を使用しないこと</h3><p><strong>説明</strong>：</p><p>C++が提供する型変換操作は、Cスタイルの変換よりも対象が明確で読みやすく、より安全です。C++が提供する変換には以下があります：</p><ul><li>型変換：</li></ul><ol><li><code>dynamic_cast</code>：継承体系の下行変換に主に使用され、<code>dynamic_cast</code>は型チェックの機能を持っていますので、基底クラスと派生クラスの設計をよく考えて、dynamic_castを使用して変換しないようにしましょう。</li><li><code>static_cast</code>：Cスタイルの変換と似ており、値の強制変換や上行変換（派生クラスのポインタや参照を基底クラスのポインタや参照に変換）が可能です。この変換は多重継承による型の曖昧さを解消するためによく使用され、比較的安全です。純粋な算術変換の場合は、後の波括弧変換方式を使用することをお勧めします。</li><li><code>reinterpret_cast</code>：関連のない型間の変換に使用されます。<code>reinterpret_cast</code>はコンパイラに特定の型のオブジェクトのメモリを別の型として再解釈させます。これは安全でない変換であり、<code>reinterpret_cast</code>の使用を最小限に抑えることをお勧めします。</li><li><code>const_cast</code>：オブジェクトの<code>const</code>属性を除去し、オブジェクトを変更可能にします。これはデータの不変性を破壊するため、できるだけ使用を控えることをお勧めします。</li></ol><ul><li>算術変換： （C++11以降サポート）
算術変換で型情報が失われない場合、例えばfloatからdouble、int32からint64への変換など、大括弧初期化方式を使用することを推奨します。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=n>someFloat</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>i</span><span class=p>{</span> <span class=n>someInt32</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=提案931-dynamic_castの使用を避けること><a name=a9-3-1></a>提案9.3.1 <code>dynamic_cast</code>の使用を避けること</h3><ol><li><code>dynamic_cast</code>はC++のRTTIに依存しており、実行時にC++クラスオブジェクトの型を認識できるようにします。</li><li><code>dynamic_cast</code>が現れるのは、基底クラスと派生クラスの設計に問題があることを示しており、派生クラスが基底クラスの契約を破壊し、<code>dynamic_cast</code>で派生クラスに変換して特別な処理を行う必要があるためです。この場合、<code>dynamic_cast</code>を使用して問題を解決するのではなく、クラスの設計を改善することをお勧めします。</li></ol><h3 id=提案932-reinterpret_castの使用を避けること><a name=a9-3-2></a>提案9.3.2 <code>reinterpret_cast</code>の使用を避けること</h3><p><strong>説明</strong>：<code>reinterpret_cast</code>は関連しない型間の変換に使用されます。<code>reinterpret_cast</code>を使用して一種類の型を別の型に強制的に変換しようとすると、型の安全性と信頼性が損なわれ、安全でない変換になります。異なる型間の変換はできるだけ避けてください。</p><h3 id=提案933-const_castの使用を避けること><a name=a9-3-3></a>提案9.3.3 <code>const_cast</code>の使用を避けること</h3><p><strong>説明</strong>：<code>const_cast</code>はオブジェクトの<code>const</code>と<code>volatile</code>性質を除去するために使用されます。</p><p>const_castを使用して変換されたポインターや参照でconstオブジェクトを変更すると、動作は未定義です。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 悪い例
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>2048</span><span class=p>;</span>      <span class=c1>// 未定義の動作
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 悪い例
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>  <span class=c1>// 未定義の動作
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=リソースの割り当てと解放><a name=c9-4></a>リソースの割り当てと解放</h2><h3 id=ルール941-単一オブジェクトの解放にはdeleteを使用し配列オブジェクトの解放にはdelete-を使用する><a name=r9-4-1></a>ルール9.4.1 単一オブジェクトの解放にはdeleteを使用し、配列オブジェクトの解放にはdelete []を使用する</h3><p>説明：単一オブジェクトの削除にはdeleteを使用し、配列オブジェクトの削除にはdelete []を使用します。理由：</p><ul><li>newが含む動作：システムからメモリを申請し、その型のコンストラクタを呼び出す。</li><li>new[n]が含む動作：n個のオブジェクトを収容できるメモリを申請し、それぞれのオブジェクトに対してコンストラクタを呼び出す。</li><li>deleteが含む動作：まず対応するデストラクタを呼び出し、その後メモリをシステムに返却する。</li><li>delete[]が含む動作：それぞれのオブジェクトに対してデストラクタを呼び出し、その後すべてのメモリを解放する。</li></ul><p>newとdeleteの形式が一致しない場合、結果は不明です。非class型の場合、newとdeleteはコンストラクタとデストラクタを呼び出しません。</p><p>誤った書き方：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>正しい書き方：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=提案941-raii特性を使用して動的割り当てを追跡するのを助ける><a name=a9-4-1></a>提案9.4.1 RAII特性を使用して動的割り当てを追跡するのを助ける</h3><p>説明：RAIIは「リソース取得は初期化である」の略で、オブジェクトのライフサイクルを使用してプログラムリソース（メモリ、ファイルハンドル、ネットワーク接続、ミューテックスなど）を制御するシンプルな技術です。</p><p>RAIIの一般的なやり方は次の通りです：オブジェクトの構築時にリソースを取得し、リソースへのアクセスを制御してオブジェクトのライフサイクル中常に有効に保ち、最後にオブジェクトの破棄時にリソースを解放します。このやり方には二つの大きな利点があります：</p><ul><li>明示的にリソースを解放する必要がありません。</li><li>オブジェクトが必要とするリソースはそのライフサイクル中常に有効です。これにより、リソースの有効性をチェックする問題を回避でき、ロジックを簡素化し、効率を向上させることができます。</li></ul><p>例：RAIIを使用してミューテックスリソースを明示的に解放する必要はありません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockGuard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span><span class=p>(</span><span class=k>const</span> <span class=n>LockType</span><span class=o>&amp;</span> <span class=n>lockType</span><span class=p>)</span><span class=o>:</span> <span class=n>lock_</span><span class=p>(</span><span class=n>lockType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Acquire</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>LockGuard</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockType</span> <span class=n>lock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span> <span class=n>lockGuard</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// データ操作
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=標準ライブラリ><a name=c9-5></a>標準ライブラリ</h2><p>STL標準テンプレートライブラリは異なる製品で使用される程度が異なるため、ここでは基本的なルールと提案をいくつか示し、各チームの参考とします。</p><h3 id=ルール951-stdstringのc_strが返すポインタを保存しないこと><a name=r9-5-1></a>ルール9.5.1 std::stringのc_str()が返すポインタを保存しないこと</h3><p>説明：C++標準ではstring::c_str()ポインタが永続的に有効であるとは規定されていないため、特定のSTL実装はstring::c_str()を呼び出すときに一時的なストレージ領域を返し、すぐに解放する可能性があります。したがって、移植性を保証するために、string::c_str()の結果を保存せず、必要に応じて直接呼び出すべきです。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>  <span class=c1>// 式が終了した後、nameのライフサイクルはまだ存続しているため、ポインタは有効
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 文字列の非constメンバー関数を呼び出すと、文字列が変更され、operator[]やbegin()などにより
</span></span></span><span class=line><span class=cl>    <span class=c1>// textの内容が利用できなくなるか、元の文字列でなくなる可能性がある
</span></span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;2&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// textポインタを使用すると、その文字列の内容はもはや&#34;demo&#34;ではない
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=p>(</span><span class=n>name</span> <span class=o>+</span> <span class=n>test</span><span class=p>).</span><span class=n>c_str</span><span class=p>();</span> <span class=c1>// 式が終了した後、+演算子が生成した一時オブジェクトは破棄され、ポインタは無効になる
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// textポインタを使用すると、それはもはや有効なメモリ空間を指していない
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例外：パフォーマンス要件が非常に高いコードでは、既に定義されたconst char*型の引数のみを受け入れる関数に適合させるために、一時的にstring::c_str()が返すポインタを保存することができます。しかし、stringオブジェクトのライフサイクルが保存されたポインタのライフサイクルよりも長いことを厳密に保証し、保存されたポインタのライフサイクル中、stringオブジェクトが変更されないことを保証しなければなりません。</p><h3 id=提案951-stdstringをcharの代わりに使用する><a name=a9-5-1></a>提案9.5.1 std::stringをchar*の代わりに使用する</h3><p>説明：stringをchar*の代わりに使用する利点はたくさんあります。例えば：</p><ol><li>終端の’\0’を考慮する必要がない；</li><li>+, =, ==などの演算子や他の文字列操作関数を直接使用できる；</li><li>明示的なnew/deleteやそれによって引き起こされるエラーを考慮する必要がない；</li></ol><p>注意すべき点は、一部のstl実装ではstringがコピー時書き込み戦略に基づいているため、これにより2つの問題が生じます。1つは、あるバージョンのコピー時書き込み戦略がスレッドセーフを実装していないため、マルチスレッド環境でプログラムがクラッシュする可能性があることです。2つ目は、動的リンクライブラリ間でコピー時書き込み戦略に基づくstringを相互に受け渡すと、動的リンクライブラリがアンロードされたときに参照カウントが減少しないため、ぶら下がりポインタが発生する可能性があることです。したがって、プログラムの安定性を保証するには、信頼できるstl実装を選択することが重要です。</p><p>例外：
システムや他のサードパーティライブラリのAPIを呼び出す際には、すでに定義されたインターフェースに対してはchar*を使用する必要があります。しかし、インターフェースを呼び出す前まではstringを使用でき、インターフェースを呼び出すときにstring::c_str()を使用して文字列ポインタを取得します。
スタック上に文字列配列をバッファとして使用する場合は、直接文字列配列を定義し、stringを使用する必要はありません。また、vector<char>などのコンテナを使用する必要もありません。</p><h3 id=ルール952-auto_ptrの使用を禁止する><a name=r9-5-2></a>ルール9.5.2 auto_ptrの使用を禁止する</h3><p>説明：stlライブラリのstd::auto_ptrは暗黙の所有権移転動作を持っています。以下のようなコード：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span>
</span></span></code></pre></div><p>2行目が実行されると、p1は1行目で割り当てられたオブジェクトを指さなくなり、nullptrになります。そのため、auto_ptrは様々な標準コンテナに置くことができません。
所有権移転動作は通常望ましい結果ではありません。所有権を移転する必要があるシナリオでは、暗黙の移転方法を使用すべきではありません。これは通常、auto_ptrを使用するコードに対して追加の慎重さを要求し、空ポインタへのアクセスによるバグを引き起こす可能性があります。
auto_ptrを使用する一般的な2つのシナリオがあります。1つ目は、auto_ptrをauto_ptrを生成する関数の外部に渡すために使用すること、2つ目は、auto_ptrをRAII管理クラスとして使用し、auto_ptrのライフサイクルが終了したときに自動的にリソースを解放することです。
1つ目のシナリオでは、std::shared_ptrを使用して置き換えることができます。
2つ目のシナリオでは、C++11標準のstd::unique_ptrを使用して置き換えることができます。std::unique_ptrはstd::auto_ptrの代替品で、明示的な所有権移転をサポートしています。</p><p>例外：
C++11標準が広く使用されるようになるまでは、所有権を必ず移転しなければならないシナリオでstd::auto_ptrを使用することができますが、auto_ptrをカプセル化し、カプセル化クラスのコピーコンストラクタと代入演算子を無効にして、このカプセル化クラスが標準コンテナで使用できないようにすることをお勧めします。</p><h3 id=提案952-新しい標準ヘッダファイルを使用する><a name=a9-5-2></a>提案9.5.2 新しい標準ヘッダファイルを使用する</h3><p>説明：
C++の標準ヘッダファイルを使用する際は、<code>&lt;cstdlib></code>のように使用し、<code>&lt;stdlib.h></code>のようには使用しないでください。</p><h2 id=constの使用方法><a name=c9-6></a>constの使用方法</h2><p>変数やパラメータの前にconstキーワードを付けることで、変数の値が変更されないことを示すことができます（例：<code>const int foo</code>）。クラスの関数にconst修飾子を付けることで、その関数がクラスメンバー変数の状態を変更しないことを示すことができます（例：<code>class Foo { int Bar(char c) const; };</code>）。const変数、データメンバー、関数、パラメータはコンパイル時の型検査に追加の保証を提供し、エラーを早期に発見するのに役立ちます。そのため、可能な限りconstを使用することを強くお勧めします。
時には、constexprを使用して真の定数を定義する方が良いかもしれません。</p><h3 id=ルール961-ポインタと参照型のパラメータが変更されない場合はconstを使用する><a name=r9-6-1></a>ルール9.6.1 ポインタと参照型のパラメータが変更されない場合は、constを使用する</h3><p>変更されない値は理解や追跡、分析が容易になるため、可能な限りconstをデフォルトとして使用してください。コンパイル時にチェックされ、コードがより堅牢で安全になります。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PrintFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=ルール962-メンバー変数を変更しないメンバー関数にはconst修飾子を使用する><a name=r9-6-2></a>ルール9.6.2 メンバー変数を変更しないメンバー関数にはconst修飾子を使用する</h3><p>可能な限りメンバー関数をconstとして宣言してください。アクセサ関数は常にconstであるべきです。データメンバーを変更しないメンバー関数はすべてconstとして宣言すべきです。
仮想関数については、設計上の意図から継承チェーン上のすべてのクラスでデータメンバーを変更する必要があるかどうかを考慮すべきであり、単一のクラスの実装だけを考慮すべきではありません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>PrintValue</span><span class=p>()</span> <span class=k>const</span> <span class=c1>// const修飾子付きメンバー関数、メンバー変数を変更しない
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetValue</span><span class=p>()</span> <span class=k>const</span>  <span class=c1>// const修飾子付きメンバー関数、メンバー変数を変更しない
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=提案961-初期化後に変更されないメンバー変数はconstとして定義する><a name=a9-6-1></a>提案9.6.1 初期化後に変更されないメンバー変数はconstとして定義する</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span> <span class=n>dataLength_</span><span class=p>(</span><span class=n>length</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>dataLength_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=例外処理><a name=c9-7></a>例外処理</h2><h3 id=提案971-c11では例外を投げない関数はnoexceptとして宣言する><a name=a9-7-1></a>提案9.7.1 C++11では、例外を投げない関数は<code>noexcept</code>として宣言する</h3><p><strong>理由</strong></p><ol><li>例外を投げない関数を<code>noexcept</code>として宣言することで、コンパイラが関数を最大限に最適化でき、実行パスを減らし、エラー終了の効率を向上させることができます。</li><li><code>vector</code>などのSTLコンテナは、インターフェースの堅牢性を保証するために、保存要素の<code>move演算子</code>が<code>noexcept</code>として宣言されていない場合、コンテナの拡張時に要素を移動する際に<code>moveメカニズム</code>ではなく<code>copyメカニズム</code>を使用し、パフォーマンス損失のリスクを引き起こします。関数が例外を投げない、または関数が投げた例外をキャッチして処理しない場合、新しい<code>noexcept</code>キーワードを使用して関数を修飾し、関数が例外を投げない、または投げられた例外がキャッチされて処理されないことを示すことができます。例：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>double</span> <span class=n>sqrt</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>  <span class=c1>// 常に例外を投げない
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 例外を投げても、noexceptを使用して宣言できる
</span></span></span><span class=line><span class=cl><span class=c1>// ここではメモリ枯渇の例外を処理しないので、単にnoexceptで関数を宣言する
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>MyComputation</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>noexcept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>    <span class=c1>// 例外を投げる可能性がある
</span></span></span><span class=line><span class=cl>    <span class=c1>// 何かをする
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>   <span class=c1>// 最大の最適化
</span></span></span><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>);</span>            <span class=c1>// 少ない最適化
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// std::vector の move 操作は noexcept を宣言する必要がある
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo1</span><span class=p>(</span><span class=n>Foo1</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>);</span>  <span class=c1>// noexceptなし
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo1</span><span class=o>&gt;</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>  <span class=c1>// コンテナが拡張され、既存要素を移動するときにcopy constructorが呼び出される
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo2</span><span class=p>(</span><span class=n>Foo2</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo2</span><span class=o>&gt;</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>  <span class=c1>// コンテナが拡張され、既存要素を移動するときにmove constructorが呼び出される
</span></span></span></code></pre></div><p><strong>注意</strong>
デフォルトコンストラクタ、デストラクタ、<code>swap</code>関数、<code>move演算子</code>は例外を投げてはいけません。</p><h2 id=テンプレートとジェネリックプログラミング><a name=c9-8></a>テンプレートとジェネリックプログラミング</h2><h3 id=ルール981-openharmonyプロジェクトでのジェネリックプログラミングを禁止する><a name=a9-8-1></a>ルール9.8.1 OpenHarmonyプロジェクトでのジェネリックプログラミングを禁止する</h3><p>ジェネリックプログラミングとオブジェクト指向プログラミングの思想、理念、テクニックは全く異なり、OpenHarmonyプロジェクトの主流はオブジェクト指向の思想を使用しています。</p><p>C++は非常に強力なジェネリックプログラミングメカニズムを提供しており、非常に柔軟で簡潔なタイプセーフなインターフェースを実装でき、タイプが異なるが振る舞いが同じコードの再利用を実現できます。</p><p>しかし、C++のジェネリックプログラミングには以下のような欠点があります：</p><ol><li>ジェネリックプログラミングにあまり熟練していない人は、オブジェクト指向のロジックをテンプレートとして書き、テンプレートパラメータに依存しないメンバーをテンプレートに書き込むなどして、ロジックの混乱やコードの肥大化を引き起こすことがよくあります。</li><li>テンプレートプログラミングで使用されるテクニックは、C++にあまり熟練していない人にとっては非常に難解で理解しにくいです。複雑な場所でテンプレートを使用したコードは、読むのがさらに難しくなり、デバッグやメンテナンスも非常に面倒になります。</li><li>テンプレートはコードが間違っているときに非常に不親切なコンパイルエラーメッセージを表示します：コードにエラーがあるとき、このインターフェースが非常にシンプルでも、テンプレート内部の複雑な実装の詳細がエラーメッセージに表示され、このコンパイルエラーメッセージを理解するのは非常に難しいです。</li><li>テンプレートが不適切に使用されると、実行時のコードが過度に肥大化する可能性があります。</li><li>テンプレートコードは変更やリファクタリングが困難です。テンプレートコードは多くの文脈で展開されるため、リファクタリングがすべての展開されたコードに有効かどうかを確認するのは非常に困難です。</li></ol><p>したがって、OpenHarmonyの大部分のコンポーネントはテンプレートプログラミングを禁止しており、ごく少数のコンポーネントのみがジェネリックプログラミングを使用でき、開発されたテンプレートには詳細なコメントが必要です。
例外：</p><ol><li>STLアダプテーションレイヤーはテンプレートを使用できます</li></ol><h2 id=マクロ><a name=c9-9></a>マクロ</h2><p>C++言語では、できるだけ複雑なマクロの使用を避けることを強くお勧めします。</p><ul><li>定数定義については、前述の章で述べたように、constまたはenumを使用してください。</li><li>マクロ関数については、できるだけシンプルにし、以下の原則に従ってください。また、inline関数やtemplate関数などで置き換えることを優先してください。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// マクロ関数の使用はお勧めしません
</span></span></span><span class=line><span class=cl><span class=cp>#define SQUARE(a, b) ((a) * (b))
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// テンプレート関数やインライン関数などを使用して置き換えてください。
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=n>Square</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><p>マクロを使用する必要がある場合は、C言語の規約の対応する章を参照してください。
<strong>例外</strong>：newやdeleteのラップ処理など、一般的かつ成熟したアプリケーションについては、マクロの使用を残すことができます。</p><h1 id=10-モダンcの機能><a name=c10></a>10 モダンC++の機能</h1><p>ISOが2011年にC++11言語標準を発表し、2017年3月にC++17を発表したことに伴い、モダンC++（C++11/14/17など）はプログラミング効率とコード品質を向上させる大量の新しい言語機能と標準ライブラリを追加しました。
この章では、チームがモダンC++をより効率的に使用し、言語の落とし穴を回避するためのガイダンスをいくつか説明しています。</p><h2 id=コードの簡潔性と安全性の向上><a name=c10-1></a>コードの簡潔性と安全性の向上</h2><h3 id=提案1011-autoを適切に使用する><a name=a10-1-1></a>提案10.1.1 <code>auto</code>を適切に使用する</h3><p><strong>理由</strong></p><ul><li><code>auto</code>は冗長で繰り返しの多い型名を避けることができ、定義された変数が初期化されることも保証します。</li><li><code>auto</code>の型推論ルールは複雑で、慎重に理解する必要があります。</li><li>コードがより明確になる場合は、明示的な型を使用し、局所変数でのみ<code>auto</code>を使用してください。</li></ul><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 冗長な型名を避ける
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 繰り返しの型名を避ける
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 初期化を保証する
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// コンパイル成功、初期化なし
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>x</span><span class=p>;</span>   <span class=c1>// コンパイル失敗、初期化が必要
</span></span></span></code></pre></div><p>autoの型推論は混乱を招く可能性があります：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>           <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>ca</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>    <span class=c1>// const int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>   <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>aa</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>         <span class=c1>// int, constとreferenceを無視
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila1</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>   <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila2</span><span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>      <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura1</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>      <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura2</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>     <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura3</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>// int&amp;&amp;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>arr1</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>        <span class=c1>// const int*
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;</span> <span class=n>arr2</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>       <span class=c1>// const int(&amp;)[10]
</span></span></span></code></pre></div><p><code>auto</code>の型推論時に参照を無視することに注意しないと、発見しにくいパフォーマンスの問題を引き起こす可能性があります:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>  <span class=c1>// autoはstd::stringと推論され、v[0]をコピーする
</span></span></span></code></pre></div><p><code>auto</code>を使用してインターフェイスを定義する場合（ヘッダファイル内の定数など）、開発者が値を変更したことで型が変化する可能性があります。</p><h3 id=ルール1011-仮想関数をオーバーライドするときはoverrideまたはfinalキーワードを使用する><a name=r10-1-1></a>ルール10.1.1 仮想関数をオーバーライドするときは<code>override</code>または<code>final</code>キーワードを使用する</h3><p><strong>理由</strong>
<code>override</code>と<code>final</code>キーワードは、関数が仮想関数であり、基底クラスの仮想関数をオーバーライドすることを保証します。子クラスの関数と基底クラスの関数のプロトタイプが一致しない場合、コンパイル警告が発生します。<code>final</code>は、仮想関数が子クラスによって再度オーバーライドされないことを保証します。</p><p><code>override</code>または<code>final</code>キーワードを使用すると、基底クラスの仮想関数のプロトタイプを変更したが、子クラスのオーバーライドされた仮想関数を変更し忘れた場合でも、コンパイル時に発見できます。また、複数の子クラスがある場合に、仮想関数のオーバーライドの変更が漏れるのを防ぐことができます。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// コンパイル失敗: Derived::Foo と Base::Foo のプロトタイプが一致しない、オーバーライドではない
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 正しい: Derived::Foo が Base::Foo をオーバーライド
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=k>final</span><span class=p>;</span>   <span class=c1>// 正しい: Derived::Foo(int) が Base::Foo(int) をオーバーライドし、Derivedの派生クラスはこの関数をオーバーライドできない
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// コンパイル失敗: Base::Bar は仮想関数ではない
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>まとめ</strong></p><ol><li>基底クラスで初めて仮想関数を定義するときは、<code>virtual</code>キーワードを使用する</li><li>子クラスが基底クラスの仮想関数（デストラクタを含む）をオーバーライドするときは、<code>override</code>または<code>final</code>キーワードを使用する（両方同時に使用しないこと）、かつ<code>virtual</code>キーワードは使用しない</li><li>仮想関数でない場合は、<code>virtual</code>、<code>override</code>、<code>final</code>のいずれも使用しない</li></ol><h3 id=ルール1012-deleteキーワードを使用して関数を削除する><a name=r10-1-2></a>ルール10.1.2 <code>delete</code>キーワードを使用して関数を削除する</h3><p><strong>理由</strong>
クラスメンバー関数を<code>private</code>として宣言して実装しない方法と比べて、<code>delete</code>キーワードはより明確で、適用範囲も広いです。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ヘッダファイルだけ見てもコピーコンストラクタが削除されているか分からない
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 明示的にコピーアサインメント関数を削除
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>delete</code>キーワードは非メンバー関数の削除もサポートしています</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=ルール1013-nullptrを使用しnullや0は使用しないこと><a name=r10-1-3></a>ルール10.1.3 <code>nullptr</code>を使用し、<code>NULL</code>や<code>0</code>は使用しないこと</h3><p><strong>理由</strong>
長年にわたり、C++には空ポインタを表すキーワードがなく、これは非常に厄介な状況でした：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NULL ((void *)0)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// エラー: void* は char* に自動変換できない
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=p>(</span><span class=n>C</span><span class=o>::*</span><span class=n>pmf</span><span class=p>)()</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>C</span><span class=o>::</span><span class=n>Func</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pmf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// エラー: void* はメンバ関数ポインタに自動変換できない
</span></span></span></code></pre></div><p><code>NULL</code>を<code>0</code>や<code>0L</code>として定義すれば、上記の問題は解決できます。</p><p>または、空ポインタが必要な場所で直接<code>0</code>を使用します。しかし、これには別の問題があり、コードが明確ではなく、特に<code>auto</code>自動推論を使用する場合です：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() はポインタを返すのか整数を返すのか?
</span></span></span><span class=line><span class=cl>    <span class=c1>// 何かをする
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>0</code>は文字通り<code>int</code>型（<code>0L</code>は<code>long</code>型）であり、<code>NULL</code>と<code>0</code>はどちらもポインタ型ではありません。
ポインタと整数型の関数をオーバーロードするとき、<code>NULL</code>や<code>0</code>を渡すと整数型のオーバーロードされた関数が呼び出されます:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>      <span class=c1>// F(int)を呼び出す、F(int*)ではない
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>   <span class=c1>// F(int)を呼び出す、F(int*)ではない
</span></span></span></code></pre></div><p>さらに、<code>sizeof(NULL) == sizeof(void*)</code>が常に成立するとは限らないため、潜在的なリスクがあります。</p><p>まとめると、直接<code>0</code>や<code>0L</code>を使用すると、コードが明確ではなく、型安全を保証できません。<code>NULL</code>を使用しても型安全を保証できません。これらは潜在的なリスクです。</p><p><code>nullptr</code>の利点は、文字通り空ポインタを表すだけでなく、コードを明確にし、型安全を保証することです。</p><p><code>nullptr</code>は<code>std::nullptr_t</code>型であり、<code>std::nullptr_t</code>はすべての原始ポインタ型に暗黙的に変換できます。これにより、<code>nullptr</code>は任意の型の空ポインタとして振る舞うことができます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// F(int*)を呼び出す
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() はポインタを返す
</span></span></span><span class=line><span class=cl>    <span class=c1>// 何かをする
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=ルール1014-usingを使用しtypedefは使用しないこと><a name=r10-1-4></a>ルール10.1.4 <code>using</code>を使用し、<code>typedef</code>は使用しないこと</h3><p><code>C++11</code>以前では、<code>typedef</code>を使用して型の別名を定義できました。誰もが<code>std::map&lt;uint32_t, std::vector&lt;int>></code>のようなコードを何度も繰り返すことを望んでいません。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>SomeType</span><span class=p>;</span>
</span></span></code></pre></div><p>型の別名は実際には型のカプセル化です。カプセル化により、コードがより明確になり、型の変化による散発的な修正を大幅に回避できます。
<code>C++11</code>以降では、<code>using</code>が提供され、<code>別名宣言(alias declarations)</code>を実装しています:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>SomeType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>両者のフォーマットを比較してみましょう：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Type</span> <span class=n>Alias</span><span class=p>;</span>   <span class=c1>// Typeが前にあるのか、Aliasが前にあるのか
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Alias</span> <span class=o>=</span> <span class=n>Type</span><span class=p>;</span>   <span class=c1>// &#39;代入&#39;の使い方に合致し、理解しやすく、間違いにくい
</span></span></span></code></pre></div><p>これが<code>using</code>に切り替えるのに十分な理由でないと思われるなら、<code>テンプレート別名(alias template)</code>を見てみましょう:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// テンプレートの別名を定義する、一行のコード
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyAllocatorVector</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>       <span class=c1>// usingで定義された別名を使用
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data_</span><span class=p>;</span>   <span class=c1>// テンプレートクラスでusingで定義された別名を使用
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>一方、<code>typedef</code>はテンプレートパラメータ付きの別名をサポートしていません。迂回路を取らなければなりません:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// typedefをラップしたテンプレートを使用、テンプレートクラスの実装が必要
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyAllocatorVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// typedefで定義された別名を使用、::typeを追加
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data_</span><span class=p>;</span>  <span class=c1>// テンプレートクラスで使用、::typeに加えてtypenameも必要
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=ルール1015-constオブジェクトに対してstdmoveを使用しないこと><a name=r10-1-5></a>ルール10.1.5 constオブジェクトに対してstd::moveを使用しないこと</h3><p>文字通り見ると、<code>std::move</code>はオブジェクトを移動することを意味します。しかし、constオブジェクトは変更できないため、当然移動もできません。したがって、<code>std::move</code>を使用してconstオブジェクトを操作すると、コードの読者に困惑を与えます。
実際の機能面では、<code>std::move</code>はオブジェクトを右辺値参照型に変換します。constオブジェクトの場合は、constの右辺値参照に変換されます。ほとんどすべての型はconstの右辺値参照をパラメータとするムーブコンストラクタやムーブ代入演算子を定義していないため、コードの実際の機能はオブジェクトのコピーに退化し、パフォーマンスの損失をもたらします。</p><p><strong>誤った例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>g_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>g_stringList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>myString</span> <span class=o>=</span> <span class=s>&#34;String content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>myString</span><span class=p>);</span> <span class=c1>// 悪い: myStringを移動しておらず、コピーしている
</span></span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=s>&#34;Another string content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_stringList</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>anotherString</span><span class=p>));</span>    <span class=c1>// 悪い: anotherStringを移動しておらず、コピーしている
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=スマートポインタ><a name=c10-2></a>スマートポインタ</h2><h3 id=ルール1021-所有権が複数で共有されないシングルトンやクラスのメンバーなどはスマートポインタではなく生ポインタを優先する><a name=r10-2-1></a>ルール10.2.1 所有権が複数で共有されないシングルトンやクラスのメンバーなどは、スマートポインタではなく生ポインタを優先する</h3><p><strong>理由</strong>
スマートポインタは自動的にオブジェクトリソースを解放し、リソースリークを防ぎますが、追加のリソースオーバーヘッドを伴います。例えば、スマートポインタが自動生成するクラス、コンストラクタとデストラクタのオーバーヘッド、メモリ使用量の増加などです。</p><p>シングルトンやクラスのメンバーなどのオブジェクトの所有権が複数で共有されない場合は、クラスのデストラクタでリソースを解放すれば十分です。スマートポインタを使用して追加のオーバーヘッドを増やすべきではありません。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>foo_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>foo_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>例外</strong></p><ol><li>オブジェクトの作成時にポインタの破棄関数が必要な場合は、スマートポインタを使用できます。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>CreateUniqueUser</span><span class=p>()</span> <span class=c1>// unique_ptrを使用してオブジェクトの作成と解放を同一runtimeで保証できます
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=o>::</span><span class=k>new</span> <span class=n>User</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>),</span> <span class=p>[](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>user</span><span class=o>-&gt;</span><span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>::</span><span class=k>delete</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>CreateSharedUser</span><span class=p>()</span> <span class=c1>// shared_ptrを使用してオブジェクトの作成と解放を同一runtimeで保証できます
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>.</span><span class=n>GetRefPtr</span><span class=p>(),</span> <span class=p>[</span><span class=n>ipcUser</span><span class=p>](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ipcUser</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>作成したオブジェクトが複数の側面で参照される必要がある場合は、shared_ptrを使用できます。</li></ol><h3 id=ルール1022-newではなくstdmake_uniqueを使用してunique_ptrを作成する><a name=r10-2-2></a>ルール10.2.2 <code>new</code>ではなく<code>std::make_unique</code>を使用して<code>unique_ptr</code>を作成する</h3><p><strong>理由</strong></p><ol><li><code>make_unique</code>はより簡潔な作成方法を提供します</li><li>複雑な式の例外安全を保証します</li></ol><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 悪い：MyClassが2回出現、不一致のリスクがある
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 良い：MyClassが1回だけ出現、不一致の可能性がない
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>型の繰り返しは非常に深刻な問題を引き起こす可能性があり、見つけるのも難しいです：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// コンパイルは成功するが、newとdeleteが一致しない
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=mi>10</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 非例外安全: コンパイラは関数の引数を以下のように計算する可能性がある:
</span></span></span><span class=line><span class=cl><span class=c1>// 1. Fooのメモリを割り当てる,
</span></span></span><span class=line><span class=cl><span class=c1>// 2. Fooを構築する,
</span></span></span><span class=line><span class=cl><span class=c1>// 3. Barを呼び出す,
</span></span></span><span class=line><span class=cl><span class=c1>// 4. unique_ptr&lt;Foo&gt;を構築する.
</span></span></span><span class=line><span class=cl><span class=c1>// Barが例外を投げると、Fooは破棄されず、メモリリークが発生する。
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>()),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 例外安全: 関数呼び出しは中断されない.
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>例外</strong>
<code>std::make_unique</code>はカスタム<code>deleter</code>をサポートしていません。
カスタム<code>deleter</code>が必要なシナリオでは、独自の名前空間でカスタムバージョンの<code>make_unique</code>を実装することをお勧めします。
カスタム<code>deleter</code>付きの<code>unique_ptr</code>を作成するために<code>new</code>を使用することは最後の選択肢です。</p><h3 id=ルール1024-newではなくstdmake_sharedを使用してshared_ptrを作成する><a name=r10-2-4></a>ルール10.2.4 <code>new</code>ではなく<code>std::make_shared</code>を使用して<code>shared_ptr</code>を作成する</h3><p><strong>理由</strong>
<code>std::make_shared</code>を使用して<code>std::shared_ptr</code>を作成することは、<code>std::make_unique</code>と同様に一貫性などの理由だけでなく、パフォーマンスの観点からも重要です。
<code>std::shared_ptr</code>は2つの実体を管理します：</p><ul><li>制御ブロック（参照カウント、<code>deleter</code>などを格納）</li><li>管理対象オブジェクト</li></ul><p><code>std::make_shared</code>を使用して<code>std::shared_ptr</code>を作成すると、ヒープ上で制御ブロックと管理対象オブジェクトを収容するのに十分なメモリを一度に割り当てます。一方、<code>std::shared_ptr&lt;MyClass>(new MyClass)</code>を使用して<code>std::shared_ptr</code>を作成すると、<code>new MyClass</code>がヒープ割り当てをトリガーするだけでなく、<code>std::shard_ptr</code>のコンストラクタも第二次のヒープ割り当てをトリガーし、追加のオーバーヘッドを生じます。</p><p><strong>例外</strong>
<code>std::make_unique</code>と同様に、<code>std::make_shared</code>はカスタム<code>deleter</code>をサポートしていません</p><h2 id=lambda><a name=c10-3></a>Lambda</h2><h3 id=提案1031-関数が動作しない場合はlambdaローカル変数をキャプチャするまたはローカル関数を書くを選択する><a name=a10-3-1></a>提案10.3.1 関数が動作しない場合は<code>lambda</code>(ローカル変数をキャプチャする、またはローカル関数を書く)を選択する</h3><p><strong>理由</strong>
関数はローカル変数をキャプチャしたり、ローカルスコープで宣言したりできません。ローカル状態をキャプチャする必要がある場合、またはステートメントや式のスコープに現れる必要がある場合は、可能な限り<code>lambda</code>を選択し、手書きの<code>functor</code>は避けます。
一方、<code>lambda</code>と<code>functor</code>はオーバーロードできません。オーバーロードが必要な場合は、関数を使用します。
<code>lambda</code>と関数の両方が使用できる場合は、可能な限り関数を使用します。可能な限りシンプルなツールを使用してください。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// intまたはstringだけを受け入れる関数を書く
</span></span></span><span class=line><span class=cl><span class=c1>// -- オーバーロードは自然な選択です
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ローカル状態をキャプチャする必要がある、またはステートメントや式のスコープに現れる必要がある
</span></span></span><span class=line><span class=cl><span class=c1>// -- lambdaが自然な選択です
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>Work</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=n>LotsOfWork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>taskNum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>taskNum</span> <span class=o>&lt;</span> <span class=n>max</span><span class=p>;</span> <span class=o>++</span><span class=n>taskNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pool</span><span class=p>.</span><span class=n>Run</span><span class=p>([</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>]</span> <span class=p>{...});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=ルール1031-非ローカルスコープでlambdasを使用する場合参照キャプチャは避けること><a name=r10-3-2></a>ルール10.3.1 非ローカルスコープで<code>lambdas</code>を使用する場合、参照キャプチャは避けること</h3><p><strong>理由</strong>
非ローカルスコープでの<code>lambdas</code>の使用には、返値、ヒープ上での保存、他のスレッドへの渡しが含まれます。ローカルのポインターや参照は、ローカル変数のライフサイクルを超えて存在してはいけません。<code>lambdas</code>が参照でキャプチャすると、ローカルオブジェクトの参照を保存することになります。これがローカル変数のライフサイクルを超えて参照が存在することになる場合は、参照キャプチャは避けるべきです。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 悪い
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// localを参照でキャプチャ。
</span></span></span><span class=line><span class=cl>    <span class=c1>// 関数が返された後、localは存在しなくなるため、
</span></span></span><span class=line><span class=cl>    <span class=c1>// Process()の呼び出しは未定義の動作になる!
</span></span></span><span class=line><span class=cl>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 良い
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// localを値でキャプチャ。
</span></span></span><span class=line><span class=cl>    <span class=c1>// コピーしたため、Process()の呼び出し中、localは常に有効
</span></span></span><span class=line><span class=cl>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=提案1032-thisをキャプチャする場合はすべての変数を明示的にキャプチャする><a name=a10-3-2></a>提案10.3.2 <code>this</code>をキャプチャする場合は、すべての変数を明示的にキャプチャする</h3><p><strong>理由</strong>
メンバー関数内の<code>[=]</code>は値でキャプチャしているように見えます。しかし、これは<code>this</code>ポインタを暗黙的に値で取得し、すべてのメンバー変数を参照で操作できるため、実際にはメンバー変数は参照でキャプチャされています。通常はこれを避けるべきです。もし本当にこれを行う必要があるなら、<code>this</code>のキャプチャを明示的に書くべきです。</p><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span>   <span class=c1>// 悪い: 値でキャプチャしているように見えるが、実際にはメンバー変数は参照でキャプチャされている
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// use(42)を呼び出す
</span></span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// use(43)を呼び出す
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda2</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=k>this</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span> <span class=c1>// 良い、明示的に値キャプチャを指定し、最も明確で混乱が少ない
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=提案1033-デフォルトキャプチャモードの使用を避ける><a name=a10-3-3></a>提案10.3.3 デフォルトキャプチャモードの使用を避ける</h3><p><strong>理由</strong>
lambda式は2種類のデフォルトキャプチャモードを提供しています：参照によるキャプチャ（&）と値によるキャプチャ（=）。
デフォルトの参照キャプチャはすべてのローカル変数の参照を暗黙的にキャプチャするため、ハングアップ参照へのアクセスを簡単に引き起こします。対照的に、必要な変数を明示的に書くことで、オブジェクトのライフサイクルをより簡単に確認でき、間違いを減らすことができます。
デフォルトの値キャプチャは<code>this</code>ポインタを暗黙的にキャプチャし、lambda関数が依存する変数がどれか分かりにくくなります。静的変数が存在する場合は、lambdaが静的変数のコピーを持っていると誤解させる可能性があります。
したがって、通常はデフォルトキャプチャモードを使用するのではなく、lambdaがキャプチャする必要のある変数を明示的に書くべきです。</p><p><strong>誤った例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span>  <span class=c1>// 実際にはaddendだけをコピーしている
</span></span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 静的変数の値に影響を与える
</span></span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>正しい例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>addend</span><span class=p>,</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=n>baseValue</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span>  <span class=c1>// C++14のキャプチャ初期化を使用して変数のコピーを作成する
</span></span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 静的変数の値に影響を与えない自分のコピーを変更する
</span></span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>参考：《Effective Modern C++》：Item 31: Avoid default capture modes.</p><h2 id=インタフェース><a name=c10-4></a>インタフェース</h2><h3 id=提案1041-所有権を伴わないシナリオではスマートポインタではなくtまたはtを引数として使用する><a name=a10-4-1></a>提案10.4.1 所有権を伴わないシナリオでは、スマートポインタではなく<code>T*</code>または<code>T&</code>を引数として使用する</h3><p><strong>理由</strong></p><ol><li>明示的に所有権を移転または共有する必要がある場合にのみ、スマートポインタを使用して所有権を移転または共有する。</li><li>スマートポインタで渡すと、関数呼び出し側にスマートポインタを使用することを強制する（たとえば、呼び出し側が<code>this</code>を渡したい場合など）。</li><li>共有所有権のスマートポインタを渡すと、ランタイムのオーバーヘッドが発生する。</li></ol><p><strong>例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 任意の int*を受け入れる
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 所有権を移転したい intだけを受け入れる
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 所有権を共有したい intだけを受け入れる
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 所有権を変えないが、特定の所有権を持つ呼び出し側を必要とする
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=k>const</span> <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 任意の intを受け入れる
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 悪い
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl>    <span class=n>Use</span><span class=p>(</span><span class=o>*</span><span class=n>w</span><span class=p>);</span> <span class=c1>// wだけを使用する -- 所有権管理とは全く関係ない
</span></span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><br><script src=https://giscus.app/client.js data-repo=jqknono/blog data-repo-id=R_kgDONOhENQ data-category=Announcements data-category-id=DIC_kwDONOhENc4CkQDB data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script><br><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a href=/ja-jp/blog/2024/06/28/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1ipv6%E3%81%AE%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E3%81%AE%E7%89%B9%E5%BE%B4/ aria-label="前へ - 中国电信IPv6のいくつかの特徴" class="btn btn-primary"><span class=me-1>←</span>前へ</a></li><li><a href=/ja-jp/blog/2024/06/28/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%9E%E3%83%8B%E3%83%A5%E3%82%A2%E3%83%AB%E3%81%A7%E3%81%AE%E8%A7%92%E6%8B%AC%E5%BC%A7%E3%81%AE%E6%84%8F%E5%91%B3/ aria-label="次へ - コマンドラインマニュアルでの角括弧の意味" class="btn btn-primary">次へ<span class=ms-1>→</span></a></li></ul></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/jqknono aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2015&ndash;2026
<span class=td-footer__authors>jqknono</span></span><span class=td-footer__all_rights_reserved>全著作権所有</span></div></div></div></footer></div><script src=/js/main.min.70d2ef91374ec2569b2dc1ee9e7569822c0339dc6ba611092d40f6935e5c601a.js integrity="sha256-cNLvkTdOwlabLcHunnVpgiwDOdxrphEJLUD2k15cYBo=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>