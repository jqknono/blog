<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programmer on Nono Blogs</title><link>https://blog.jqknono.com/en-us/tags/programmer/</link><description>Recent content in Programmer on Nono Blogs</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 28 Jun 2024 17:35:19 +0800</lastBuildDate><atom:link href="https://blog.jqknono.com/en-us/tags/programmer/index.xml" rel="self" type="application/rss+xml"/><item><title>Third-party Library Pitfalls</title><link>https://blog.jqknono.com/en-us/blog/2024/06/28/third-party-library-pitfalls/</link><pubDate>Fri, 28 Jun 2024 17:35:19 +0800</pubDate><guid>https://blog.jqknono.com/en-us/blog/2024/06/28/third-party-library-pitfalls/</guid><description>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Third-party library pitfalls&lt;/li>
&lt;/ul>
&lt;p>Today we talked about a vulnerability in a recently released third-party logging library that can be exploited with minimal effort to execute remote commands. A logging library and remote command execution seem completely unrelated, yet over-engineered third-party libraries are everywhere.&lt;/p>
&lt;p>The more code I read, the more I feel that a lot of open-source code is of very poor quality—regardless of how many k-stars it has. Stars represent needs, not engineering skill.&lt;/p></description></item><item><title>Design Specification Template</title><link>https://blog.jqknono.com/en-us/blog/2024/06/28/design-specification-template/</link><pubDate>Fri, 28 Jun 2024 17:35:07 +0800</pubDate><guid>https://blog.jqknono.com/en-us/blog/2024/06/28/design-specification-template/</guid><description>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Design Specification Template&lt;/li>
&lt;/ul>
&lt;h1 id="detailed-design-of-xxx-system--sub-system">Detailed Design of XXX System / Sub-system&lt;/h1>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>System Name&lt;/th>
 &lt;th>XXX System&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>Author&lt;/td>
 &lt;td>XXX&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Submission Date&lt;/td>
 &lt;td>2021-06-30&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="revision-history">Revision History&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Revised Version&lt;/th>
 &lt;th>Change Description&lt;/th>
 &lt;th>Date of Change&lt;/th>
 &lt;th>Author&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>v1.0&lt;/td>
 &lt;td>XXXXXXX&lt;/td>
 &lt;td>2021-06-30&lt;/td>
 &lt;td>XXX&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;td>&amp;mdash;&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="technical-review-comments">Technical Review Comments&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>No.&lt;/th>
 &lt;th>Reviewer&lt;/th>
 &lt;th>Review Comment (Pass/Fail/Pending, comments allowed)&lt;/th>
 &lt;th>Review Time&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>XXX&lt;/td>
 &lt;td>Pass&lt;/td>
 &lt;td>2022.1.1&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="background">Background&lt;/h2>
&lt;h2 id="glossary">Glossary&lt;/h2>
&lt;!-- For any new or uncommon terms, concepts, or acronyms appearing in the document, provide definitions and explanations. -->
&lt;ul>
&lt;li>SIP: Session Initiation Protocol&lt;/li>
&lt;li>RTP: Real-time Transport Protocol&lt;/li>
&lt;/ul>
&lt;h2 id="design-objectives">Design Objectives&lt;/h2>
&lt;h3 id="functional-requirements">Functional Requirements&lt;/h3>
&lt;!-- Summarize the functional requirements of the system itself, without describing external systems. If the project already has an MRD/PRD, list functional points and sub-points in hierarchy here. If there is no MRD/PRD, enumerate the functional points and sub-points to be implemented. -->
&lt;h3 id="non-functional-requirements-mandatory">Non-Functional Requirements (mandatory)&lt;/h3>
&lt;!-- Describe the non-functional requirements of the system (including performance needs). It is recommended to list quantifiable performance indicators such as response time, error rate, resource usage, and operational period. Do not be vague, ambiguous, or make unfounded assumptions. -->
&lt;h2 id="environment">Environment&lt;/h2>
&lt;h3 id="related-software--hardware-optional">Related Software &amp;amp; Hardware (optional)&lt;/h3>
&lt;!-- Add required software &amp; hardware for the system, including operating systems, machine models, and configuration requirements. Tabular format is recommended; ideally also include a deployment diagram of servers and software components. This section can also be written as a separate deployment design document and referenced here. -->
&lt;h3 id="system-constraints">System Constraints&lt;/h3>
&lt;!-- Add known or foreseeable constraints of the system here. -->
&lt;h3 id="estimated-data-scale-mandatory">Estimated Data Scale (mandatory)&lt;/h3>
&lt;!-- Through research or experience, estimate the data scale, covering user volume, data volume, bandwidth consumption, and growth rate. Categorize and list them. -->
&lt;h2 id="existing-solutions">Existing Solutions&lt;/h2>
&lt;!-- For this design objective, enumerate all known solutions—particularly **existing solutions inside Qiteng**—and identify whether they meet the new requirements. Unless the requirements differ completely, forking should be the last resort; prefer enhancing the current solution. -->
&lt;h2 id="design-ideas--trade-offs">Design Ideas &amp;amp; Trade-offs&lt;/h2>
&lt;!-- Describe key or difficult problems to be solved or considered in the system design. Where alternative solutions exist, include the selected option, trade-offs, and justification; provide further details later in the “System Design” section. It is suggested to classify by concerns such as performance, scalability, security, service stability, anti-fraud, and reuse; attach research data to support the design choice. -->
&lt;h3 id="assumptions--dependencies--relationships-with-other-systems">Assumptions &amp;amp; Dependencies / Relationships with Other Systems&lt;/h3>
&lt;!-- State the prerequisites for the success of the system and its connections with external systems/modules. Either list them in bulleted prose or depict with a system architecture diagram. -->
&lt;h2 id="system-design">System Design&lt;/h2>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;!-- A brief introduction of the overall system. -->
&lt;h3 id="architecture-diagram--explanation">Architecture Diagram &amp;amp; Explanation&lt;/h3>
&lt;!-- Decompose the system into subsystems or modules, provide an architecture diagram, and briefly explain the main responsibility of each module (if helpful, include justification for grouping certain functions into a specific module). If the modules run in heterogeneous environments (e.g., different operating systems, servers), show the corresponding physical architecture diagram in the Related Software &amp; Hardware section. -->
&lt;h3 id="system-flow--explanation-optional">System Flow &amp;amp; Explanation (optional)&lt;/h3>
&lt;!-- Use flowcharts to illustrate how system modules interact to fulfill system functions. -->
&lt;h3 id="interfaces-with-external-systems">Interfaces with External Systems&lt;/h3>
&lt;!-- Provide detailed definitions for interfaces between this system and external systems. If interfaces are numerous or complex, create a dedicated interface design document and reference it here. If the external system has already published an interface document, simply cite it. Interfaces here include structures, function calls, interface files, databases, URL parameters, and libraries. If an external library is required, negotiate the version to be used during the design phase and clarify it here. -->
&lt;h3 id="global-data-structure-descriptions">Global Data-Structure Descriptions&lt;/h3>
&lt;!-- Describe global data structures (including database schemas) commonly used across modules. If this is already covered in the interface design section, simply reference the interface document. -->
&lt;h3 id="brief-description-of-module-xxx1">Brief Description of Module XXX1&lt;/h3>
&lt;h4 id="functionality-of-module-xxx1">Functionality of Module XXX1&lt;/h4>
&lt;!-- Describe the functionality to be implemented by this module—first a high-level summary, then list detailed points. For any key features or techniques specific to this module, elaborate here to guide detailed designers. -->
&lt;h4 id="interfaces-with-other-modules">Interfaces with Other Modules&lt;/h4>
&lt;!-- Describe the interfaces between this module and other modules within the system (excluding internal interfaces of the module). If the interfaces are complex or extensive enough, create a separate interface design document and reference it here. Alternatively, add a secondary heading “Inter-module Interfaces” to define them systematically and comprehensively. -->
&lt;h3 id="brief-description-of-module-xxx2">Brief Description of Module XXX2&lt;/h3>
&lt;h4 id="functionality-of-module-xxx2">Functionality of Module XXX2&lt;/h4>
&lt;h4 id="interfaces-with-other-modules-1">Interfaces with Other Modules&lt;/h4>
&lt;h2 id="threat-modeling">Threat Modeling&lt;/h2>
&lt;!-- Use a structured approach to systematically identify and evaluate security risks and threats to the product, and define mitigation measures for each risk or threat. -->
&lt;h2 id="upgrade-impact-mandatory">Upgrade Impact (mandatory)&lt;/h2>
&lt;!-- If this design needs to upgrade an existing previous version, will there be any breaking changes? Can the upgrade be performed seamlessly? What potential impacts may the upgrade bring, and how can they be mitigated? -->
&lt;h2 id="risk-assessment--impact-on-other-systems-optional">Risk Assessment &amp;amp; Impact on Other Systems (optional)&lt;/h2>
&lt;h3 id="known-or-foreseeable-risks">Known or Foreseeable Risks&lt;/h3>
&lt;!-- Include already known or possible future risks, including technical and business aspects. Preferably list corresponding measures for each risk. -->
&lt;h3 id="potential-impact-with-other-systemsmodules">Potential Impact with Other Systems/Modules&lt;/h3>
&lt;!-- In “Assumptions &amp; Dependencies on Other Systems” we described the dependencies of this system on others. Here describe the impact these dependencies may have—both the impact this system may have on others and vice-versa. Identify potential innovations and file patents where appropriate. -->
&lt;h2 id="innovation-points-optional">Innovation Points (optional)&lt;/h2>
&lt;!-- Explore potential innovation points to file patents. -->
&lt;h2 id="attachments--references">Attachments &amp;amp; References&lt;/h2>
&lt;!-- List related attachments or reference documents. Attach infrequently changed documents (e.g., research reports) as embedded objects in this document. For frequently updated documents (e.g., interface documents), simply list the filenames or links here. --></description></item><item><title>Meanings of brackets in man pages</title><link>https://blog.jqknono.com/en-us/blog/2024/06/28/meanings-of-brackets-in-man-pages/</link><pubDate>Fri, 28 Jun 2024 17:31:00 +0800</pubDate><guid>https://blog.jqknono.com/en-us/blog/2024/06/28/meanings-of-brackets-in-man-pages/</guid><description>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Meanings of brackets in man pages&lt;/li>
&lt;/ul>
&lt;h1 id="meanings-of-brackets-in-man-pages">Meanings of brackets in man pages&lt;/h1>
&lt;p>In command-line help, different types of brackets generally carry the following meanings:&lt;/p>
&lt;ol>
&lt;li>Angle brackets &lt;code>&amp;lt;&amp;gt;&lt;/code>:
&lt;ul>
&lt;li>Angle brackets denote required arguments—values you must provide when running the command. They’re typically used to express the core syntax and parameters of a command.&lt;/li>
&lt;li>Example: &lt;code>command &amp;lt;filename&amp;gt;&lt;/code> means you must supply a filename as a required argument, e.g., &lt;code>command file.txt&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Square brackets &lt;code>[]&lt;/code>:
&lt;ul>
&lt;li>Square brackets indicate optional arguments—values you may or may not provide when running the command. They’re commonly used to mark optional parameters and options.&lt;/li>
&lt;li>Example: &lt;code>command [option]&lt;/code> means you can choose to provide an option, e.g., &lt;code>command -v&lt;/code> or simply &lt;code>command&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Curly braces &lt;code>{}&lt;/code>:
&lt;ul>
&lt;li>Curly braces usually represent a set of choices, indicating that you must select one. These are also called “choice parameter groups.”&lt;/li>
&lt;li>Example: &lt;code>command {option1 | option2 | option3}&lt;/code> means you must pick one of the given options, e.g., &lt;code>command option2&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Parentheses &lt;code>()&lt;/code>:
&lt;ul>
&lt;li>Parentheses are generally used to group arguments, clarifying structure and precedence in a command’s syntax.&lt;/li>
&lt;li>Example: &lt;code>command (option1 | option2) filename&lt;/code> means you must choose either &lt;code>option1&lt;/code> or &lt;code>option2&lt;/code> and supply a filename as an argument, e.g., &lt;code>command option1 file.txt&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>These bracket conventions are intended to help users understand command syntax and parameter choices so they can use command-line tools correctly. When reading man pages or help text, paying close attention to the meaning and purpose of each bracket type is crucial—it prevents incorrect commands and achieves the desired results.&lt;/p></description></item><item><title>Huawei C++ Coding Standards</title><link>https://blog.jqknono.com/en-us/blog/2024/06/28/huawei-c-coding-standards/</link><pubDate>Fri, 28 Jun 2024 17:30:10 +0800</pubDate><guid>https://blog.jqknono.com/en-us/blog/2024/06/28/huawei-c-coding-standards/</guid><description>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Huawei C++ Coding Standards&lt;/li>
&lt;/ul>
&lt;h1 id="c-language-coding-standards">C++ Language Coding Standards&lt;/h1>
&lt;h2 id="purpose">&lt;a name="c0-1">&lt;/a>Purpose&lt;/h2>
&lt;p>Rules are not perfect; by prohibiting features useful in specific situations, they may impact code implementation. However, the purpose of establishing rules is “to benefit the majority of developers.” If, during team collaboration, a rule is deemed unenforceable, we hope to improve it together.&lt;/p>
&lt;p>Before referencing this standard, it is assumed that you already possess the corresponding basic C++ language capabilities; do not rely on this document to learn the C++ language.&lt;/p></description></item></channel></rss>