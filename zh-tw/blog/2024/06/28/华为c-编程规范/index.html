<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-tw class=no-js data-theme-init><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=color-scheme content="light dark"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#000000"><style>html{background:Canvas;color:CanvasText}@media(prefers-color-scheme:dark){html{background:#0b0d12;color:#e6e6e6}}html[data-theme-init] *{transition:none!important}</style><script>(function(){const t="td-color-theme",n=localStorage.getItem(t);let e=n||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");e==="auto"&&(e=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"),document.documentElement.setAttribute("data-bs-theme",e)})()</script><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>华为C++编程规范 | jqknono Blogs</title><meta name=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:url" content="https://blog.jqknono.com/zh-tw/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"><meta property="og:site_name" content="jqknono Blogs"><meta property="og:title" content="华为C++编程规范"><meta property="og:description" content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:locale" content="zh_tw"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-28T17:30:10+08:00"><meta property="article:modified_time" content="2024-06-28T17:30:10+08:00"><meta property="article:tag" content="教程"><meta property="article:tag" content="程序员"><meta itemprop=name content="华为C++编程规范"><meta itemprop=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta itemprop=datePublished content="2024-06-28T17:30:10+08:00"><meta itemprop=dateModified content="2024-06-28T17:30:10+08:00"><meta itemprop=wordCount content="4653"><meta itemprop=keywords content="教程,程序员"><meta name=twitter:card content="summary"><meta name=twitter:title content="华为C++编程规范"><meta name=twitter:description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><link rel=preload href=/scss/main.min.06ec545bc526509366973aad911c3b01c355af759b57d6c661642fccb0b80a34.css as=style integrity="sha256-BuxUW8UmUJNmlzqtkRw7AcNVr3WbV9bGYWQvzLC4CjQ=" crossorigin=anonymous><link href=/scss/main.min.06ec545bc526509366973aad911c3b01c355af759b57d6c661642fccb0b80a34.css rel=stylesheet integrity="sha256-BuxUW8UmUJNmlzqtkRw7AcNVr3WbV9bGYWQvzLC4CjQ=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3FFTG72NE"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3FFTG72NE")}</script></head><body class="td-page td-blog"><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="td-navbar-container container-fluid flex-column flex-md-row"><a class=navbar-brand href=/zh-tw/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>jqknono Blogs</span></a><div class="td-navbar-nav-scroll td-navbar-nav-scroll--indicator" id=main_navbar><div class="scroll-indicator scroll-left"></div><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/zh-tw/blog/><i class='fas fa-cube'></i><span>博客</span></a></li><li class=nav-item><a class=nav-link href=https://jqknono.com target=_blank rel=noopener><span>About</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class=nav-item><a class=nav-link href=https://github.com/jqknono target=_blank rel=noopener><i class="fab fa-github" aria-hidden=true></i><span>GitHub</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class="nav-item td-navbar__lang-menu"><div class="td-lang-menu dropdown"><a class="nav-link dropdown-toggle td-lang-menu__title" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><span class=td-lang-menu__title-text>繁體中文</span>
<span class=td-lang-menu__title-code>ZH-TW</span></a><ul class=dropdown-menu><li><a class=dropdown-item href=/blog/2024/06/28/huawei-c-programming-specification/>English</a></li><li><span class="dropdown-item active">繁體中文</span></li><li><a class=dropdown-item href=/ja-jp/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>日本語</a></li><li><a class=dropdown-item href=/ko-kr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>한국어</a></li><li><a class=dropdown-item href=/ar-sa/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/de-de/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Deutsch</a></li><li><a class=dropdown-item href=/fr-fr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Français</a></li><li><a class=dropdown-item href=/hi-in/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>हिंदी</a></li><li><a class=dropdown-item href=/es-es/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Español</a></li><li><a class=dropdown-item href=/pt-br/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Português</a></li><li><a class=dropdown-item href=/ru-ru/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Русский</a></li><li><a class=dropdown-item href=/it-it/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Italiano</a></li><li><span class="dropdown-item disabled">Bahasa Indonesia</span></li><li><a class=dropdown-item href=/tr-tr/blog/2024/06/28/huawei-c-programlama-kurallar%C4%B1/>Türkçe</a></li><li><a class=dropdown-item href=/nl-nl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Nederlands</a></li><li><a class=dropdown-item href=/pl-pl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Polski</a></li><li><a class=dropdown-item href=/ar-ae/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/zh-cn/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>简体中文</a></li></ul></div></li><li class="nav-item td-navbar__light-dark-menu"><div class="td-light-dark-menu dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown aria-label="Toggle theme (auto)">
<svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class=dropdown-menu aria-labelledby=bd-theme><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></div></li></ul><div class="scroll-indicator scroll-right"></div></div><div class="d-none d-lg-block td-navbar__search"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main data-bs-spy=scroll data-bs-target=.td-toc data-bs-root-margin="0px 0px -10%"><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="td-sidebar-nav collapse td-sidebar-nav--search-disabled foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-zh-twblog-li><a href=/zh-tw/blog/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-zh-twblog><span>博客</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260211return-to-gpt-non-codex-li><input type=checkbox id=m-zh-twblog20260211return-to-gpt-non-codex-check>
<label for=m-zh-twblog20260211return-to-gpt-non-codex-check><a href=/zh-tw/blog/2026/02/11/return-to-gpt-non-codex/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260211return-to-gpt-non-codex><span>return-to-gpt-non-codex</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260211doh-vs-dot-comparison-li><input type=checkbox id=m-zh-twblog20260211doh-vs-dot-comparison-check>
<label for=m-zh-twblog20260211doh-vs-dot-comparison-check><a href=/zh-tw/blog/2026/02/11/doh-vs-dot-comparison/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260211doh-vs-dot-comparison><span>DoH 與 DoT 技術對比分析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260209openrouter-gpt-oss-120b-chinese-bug-li><input type=checkbox id=m-zh-twblog20260209openrouter-gpt-oss-120b-chinese-bug-check>
<label for=m-zh-twblog20260209openrouter-gpt-oss-120b-chinese-bug-check><a href=/zh-tw/blog/2026/02/09/openrouter-gpt-oss-120b-chinese-bug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260209openrouter-gpt-oss-120b-chinese-bug><span>OpenRouter gpt-oss-120b 模型不支援中文請求的除錯記錄</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260202free-ai-icon-generators-li><input type=checkbox id=m-zh-twblog20260202free-ai-icon-generators-check>
<label for=m-zh-twblog20260202free-ai-icon-generators-check><a href=/zh-tw/blog/2026/02/02/free-ai-icon-generators/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260202free-ai-icon-generators><span>免費AI圖示生成工具彙總</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260107vibe-coding-cost-formulas-li><input type=checkbox id=m-zh-twblog20260107vibe-coding-cost-formulas-check>
<label for=m-zh-twblog20260107vibe-coding-cost-formulas-check><a href=/zh-tw/blog/2026/01/07/vibe-coding-cost-formulas/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260107vibe-coding-cost-formulas><span>Vibe Coding 的省錢公式與臨界點</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20260101windows-remote-browser-cdp-li><input type=checkbox id=m-zh-twblog20260101windows-remote-browser-cdp-check>
<label for=m-zh-twblog20260101windows-remote-browser-cdp-check><a href=/zh-tw/blog/2026/01/01/windows-remote-browser-cdp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20260101windows-remote-browser-cdp><span>在 Windows 上搭建遠端瀏覽器調試入口</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251223technical-blogs-are-dead-li><input type=checkbox id=m-zh-twblog20251223technical-blogs-are-dead-check>
<label for=m-zh-twblog20251223technical-blogs-are-dead-check><a href=/zh-tw/blog/2025/12/23/technical-blogs-are-dead/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251223technical-blogs-are-dead><span>技術部落格已死</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251212openaie79a84e58f96e5908de8979de8a193e99191e8b39e-li><input type=checkbox id=m-zh-twblog20251212openaie79a84e58f96e5908de8979de8a193e99191e8b39e-check>
<label for=m-zh-twblog20251212openaie79a84e58f96e5908de8979de8a193e99191e8b39e-check><a href=/zh-tw/blog/2025/12/12/openai%E7%9A%84%E5%8F%96%E5%90%8D%E8%97%9D%E8%A1%93%E9%91%91%E8%B3%9E/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251212openaie79a84e58f96e5908de8979de8a193e99191e8b39e><span>OpenAI的取名藝術鑑賞</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-li><input type=checkbox id=m-zh-twblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-check>
<label for=m-zh-twblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-check><a href=/zh-tw/blog/2025/12/05/%E6%8A%A2%E5%8D%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E4%B8%AA%E5%A4%A7%E4%BE%BF%E5%AE%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c><span>抢占服务器是个大便宜</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251203e5bbbae8adb0e58588e4b88de8a681e4bdbfe794a8e998bfe9878ce99bb2esa_pagee58a9fe883bd-li><input type=checkbox id=m-zh-twblog20251203e5bbbae8adb0e58588e4b88de8a681e4bdbfe794a8e998bfe9878ce99bb2esa_pagee58a9fe883bd-check>
<label for=m-zh-twblog20251203e5bbbae8adb0e58588e4b88de8a681e4bdbfe794a8e998bfe9878ce99bb2esa_pagee58a9fe883bd-check><a href=/zh-tw/blog/2025/12/03/%E5%BB%BA%E8%AD%B0%E5%85%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E9%9B%B2esa_page%E5%8A%9F%E8%83%BD/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251203e5bbbae8adb0e58588e4b88de8a681e4bdbfe794a8e998bfe9878ce99bb2esa_pagee58a9fe883bd><span>建議先不要使用阿里雲ESA_page功能</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251202e998bfe9878ce5b7b4e5b7b4esae88887osse79a84e59d91-li><input type=checkbox id=m-zh-twblog20251202e998bfe9878ce5b7b4e5b7b4esae88887osse79a84e59d91-check>
<label for=m-zh-twblog20251202e998bfe9878ce5b7b4e5b7b4esae88887osse79a84e59d91-check><a href=/zh-tw/blog/2025/12/02/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4esa%E8%88%87oss%E7%9A%84%E5%9D%91/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251202e998bfe9878ce5b7b4e5b7b4esae88887osse79a84e59d91><span>阿里巴巴ESA與OSS的坑</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251202windowse585b1e4baabe999a4e98cafchromee696b9e6b395-li><input type=checkbox id=m-zh-twblog20251202windowse585b1e4baabe999a4e98cafchromee696b9e6b395-check>
<label for=m-zh-twblog20251202windowse585b1e4baabe999a4e98cafchromee696b9e6b395-check><a href=/zh-tw/blog/2025/12/02/windows%E5%85%B1%E4%BA%AB%E9%99%A4%E9%8C%AFchrome%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251202windowse585b1e4baabe999a4e98cafchromee696b9e6b395><span>windows共享除錯chrome方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251202cloudflaree698afe590a6e5ae8ce585a8e58fafe4bfa1-li><input type=checkbox id=m-zh-twblog20251202cloudflaree698afe590a6e5ae8ce585a8e58fafe4bfa1-check>
<label for=m-zh-twblog20251202cloudflaree698afe590a6e5ae8ce585a8e58fafe4bfa1-check><a href=/zh-tw/blog/2025/12/02/cloudflare%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E5%8F%AF%E4%BF%A1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251202cloudflaree698afe590a6e5ae8ce585a8e58fafe4bfa1><span>cloudflare是否完全可信</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251201e8a696e58a9be694b9e59684e79691e99bb2-li><input type=checkbox id=m-zh-twblog20251201e8a696e58a9be694b9e59684e79691e99bb2-check>
<label for=m-zh-twblog20251201e8a696e58a9be694b9e59684e79691e99bb2-check><a href=/zh-tw/blog/2025/12/01/%E8%A6%96%E5%8A%9B%E6%94%B9%E5%96%84%E7%96%91%E9%9B%B2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251201e8a696e58a9be694b9e59684e79691e99bb2><span>視力改善疑雲</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251129e8a898e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7b6b2e8b7afe5958fe9a18ce68e92e69fa5-li><input type=checkbox id=m-zh-twblog20251129e8a898e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7b6b2e8b7afe5958fe9a18ce68e92e69fa5-check>
<label for=m-zh-twblog20251129e8a898e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7b6b2e8b7afe5958fe9a18ce68e92e69fa5-check><a href=/zh-tw/blog/2025/11/29/%E8%A8%98%E4%B8%80%E6%AC%A1%E9%9D%9E%E5%85%B8%E5%9E%8B%E5%AE%B6%E5%BA%AD%E7%B6%B2%E8%B7%AF%E5%95%8F%E9%A1%8C%E6%8E%92%E6%9F%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251129e8a898e4b880e6aca1e99d9ee585b8e59e8be5aeb6e5baade7b6b2e8b7afe5958fe9a18ce68e92e69fa5><span>記一次非典型家庭網路問題排查</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251127freebies-you-can-snag-by-owning-a-domain-li><input type=checkbox id=m-zh-twblog20251127freebies-you-can-snag-by-owning-a-domain-check>
<label for=m-zh-twblog20251127freebies-you-can-snag-by-owning-a-domain-check><a href=/zh-tw/blog/2025/11/27/freebies-you-can-snag-by-owning-a-domain/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251127freebies-you-can-snag-by-owning-a-domain><span>持有域名可以耗到的羊毛</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251126gpt-5-highe698afe69c80e981a9e59088e9968be799bce88085e79a84e6a8a1e59e8b-li><input type=checkbox id=m-zh-twblog20251126gpt-5-highe698afe69c80e981a9e59088e9968be799bce88085e79a84e6a8a1e59e8b-check>
<label for=m-zh-twblog20251126gpt-5-highe698afe69c80e981a9e59088e9968be799bce88085e79a84e6a8a1e59e8b-check><a href=/zh-tw/blog/2025/11/26/gpt-5-high%E6%98%AF%E6%9C%80%E9%81%A9%E5%90%88%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84%E6%A8%A1%E5%9E%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251126gpt-5-highe698afe69c80e981a9e59088e9968be799bce88085e79a84e6a8a1e59e8b><span>gpt-5-high是最適合開發者的模型</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251124llme79a84e581bde4babae6849f-li><input type=checkbox id=m-zh-twblog20251124llme79a84e581bde4babae6849f-check>
<label for=m-zh-twblog20251124llme79a84e581bde4babae6849f-check><a href=/zh-tw/blog/2025/11/24/llm%E7%9A%84%E5%81%BD%E4%BA%BA%E6%84%9F/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251124llme79a84e581bde4babae6849f><span>llm的偽人感</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251107useful-mouse-key-mapping-share-li><input type=checkbox id=m-zh-twblog20251107useful-mouse-key-mapping-share-check>
<label for=m-zh-twblog20251107useful-mouse-key-mapping-share-check><a href=/zh-tw/blog/2025/11/07/useful-mouse-key-mapping-share/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251107useful-mouse-key-mapping-share><span>實用滑鼠改鍵分享</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251015traee5a682e4bd95e998b2e6ada2e7b3bbe7b5b1e68f90e7a4bae8a99ee6b4a9e6bc8f-li><input type=checkbox id=m-zh-twblog20251015traee5a682e4bd95e998b2e6ada2e7b3bbe7b5b1e68f90e7a4bae8a99ee6b4a9e6bc8f-check>
<label for=m-zh-twblog20251015traee5a682e4bd95e998b2e6ada2e7b3bbe7b5b1e68f90e7a4bae8a99ee6b4a9e6bc8f-check><a href=/zh-tw/blog/2025/10/15/trae%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%B3%BB%E7%B5%B1%E6%8F%90%E7%A4%BA%E8%A9%9E%E6%B4%A9%E6%BC%8F/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251015traee5a682e4bd95e998b2e6ada2e7b3bbe7b5b1e68f90e7a4bae8a99ee6b4a9e6bc8f><span>Trae如何防止系統提示詞洩漏</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251014e782bae4bd95e5a4a7e6a8a1e59e8be79a84e58face59b9ee78e87e68c87e6a899e9878de8a681-li><input type=checkbox id=m-zh-twblog20251014e782bae4bd95e5a4a7e6a8a1e59e8be79a84e58face59b9ee78e87e68c87e6a899e9878de8a681-check>
<label for=m-zh-twblog20251014e782bae4bd95e5a4a7e6a8a1e59e8be79a84e58face59b9ee78e87e68c87e6a899e9878de8a681-check><a href=/zh-tw/blog/2025/10/14/%E7%82%BA%E4%BD%95%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AC%E5%9B%9E%E7%8E%87%E6%8C%87%E6%A8%99%E9%87%8D%E8%A6%81/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251014e782bae4bd95e5a4a7e6a8a1e59e8be79a84e58face59b9ee78e87e68c87e6a899e9878de8a681><span>為何大模型的召回率指標重要</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251009dns-e99ab1e7a781e998b2e8adb7e88887e4bdbfe794a8e88085e795abe5838fe998b2e7af84e7ad96e795a5-li><input type=checkbox id=m-zh-twblog20251009dns-e99ab1e7a781e998b2e8adb7e88887e4bdbfe794a8e88085e795abe5838fe998b2e7af84e7ad96e795a5-check>
<label for=m-zh-twblog20251009dns-e99ab1e7a781e998b2e8adb7e88887e4bdbfe794a8e88085e795abe5838fe998b2e7af84e7ad96e795a5-check><a href=/zh-tw/blog/2025/10/09/dns-%E9%9A%B1%E7%A7%81%E9%98%B2%E8%AD%B7%E8%88%87%E4%BD%BF%E7%94%A8%E8%80%85%E7%95%AB%E5%83%8F%E9%98%B2%E7%AF%84%E7%AD%96%E7%95%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251009dns-e99ab1e7a781e998b2e8adb7e88887e4bdbfe794a8e88085e795abe5838fe998b2e7af84e7ad96e795a5><span>DNS 隱私防護與使用者畫像防範策略</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250930github-spec-kite5ae98e696b9e8a68fe6a0bce9a985e58b95e9968be799bce5b7a5e585b7e58c85e6b7b1e5baa6e8a7a3e69e90-li><input type=checkbox id=m-zh-twblog20250930github-spec-kite5ae98e696b9e8a68fe6a0bce9a985e58b95e9968be799bce5b7a5e585b7e58c85e6b7b1e5baa6e8a7a3e69e90-check>
<label for=m-zh-twblog20250930github-spec-kite5ae98e696b9e8a68fe6a0bce9a985e58b95e9968be799bce5b7a5e585b7e58c85e6b7b1e5baa6e8a7a3e69e90-check><a href=/zh-tw/blog/2025/09/30/github-spec-kit%E5%AE%98%E6%96%B9%E8%A6%8F%E6%A0%BC%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7%E5%8C%85%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250930github-spec-kite5ae98e696b9e8a68fe6a0bce9a985e58b95e9968be799bce5b7a5e585b7e58c85e6b7b1e5baa6e8a7a3e69e90><span>GitHub Spec Kit：官方規格驅動開發工具包深度解析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250917claude-code-e7acace4b889e696b9e4be9be68789e59586e4bdbfe794a8e68c87e58d97-e6b7b1e5baa6e8a7a3e69e90e88887e69c80e4bdb3e5afa6e58b99-li><input type=checkbox id=m-zh-twblog20250917claude-code-e7acace4b889e696b9e4be9be68789e59586e4bdbfe794a8e68c87e58d97-e6b7b1e5baa6e8a7a3e69e90e88887e69c80e4bdb3e5afa6e58b99-check>
<label for=m-zh-twblog20250917claude-code-e7acace4b889e696b9e4be9be68789e59586e4bdbfe794a8e68c87e58d97-e6b7b1e5baa6e8a7a3e69e90e88887e69c80e4bdb3e5afa6e58b99-check><a href=/zh-tw/blog/2025/09/17/claude-code-%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9B%E6%87%89%E5%95%86%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E8%88%87%E6%9C%80%E4%BD%B3%E5%AF%A6%E5%8B%99/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250917claude-code-e7acace4b889e696b9e4be9be68789e59586e4bdbfe794a8e68c87e58d97-e6b7b1e5baa6e8a7a3e69e90e88887e69c80e4bdb3e5afa6e58b99><span>Claude Code 第三方供應商使用指南 - 深度解析與最佳實務</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250827e698afe590a6e5bf85e9a088e69c89e7b6b2e59f9fe6898de883bde4bdbfe794a8ddns-li><input type=checkbox id=m-zh-twblog20250827e698afe590a6e5bf85e9a088e69c89e7b6b2e59f9fe6898de883bde4bdbfe794a8ddns-check>
<label for=m-zh-twblog20250827e698afe590a6e5bf85e9a088e69c89e7b6b2e59f9fe6898de883bde4bdbfe794a8ddns-check><a href=/zh-tw/blog/2025/08/27/%E6%98%AF%E5%90%A6%E5%BF%85%E9%A0%88%E6%9C%89%E7%B6%B2%E5%9F%9F%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8ddns/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250827e698afe590a6e5bf85e9a088e69c89e7b6b2e59f9fe6898de883bde4bdbfe794a8ddns><span>是否必須有網域才能使用DDNS?</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250722traee4bdbfe794a8e79a84e7b0a1e596aee58886e4baab-li><input type=checkbox id=m-zh-twblog20250722traee4bdbfe794a8e79a84e7b0a1e596aee58886e4baab-check>
<label for=m-zh-twblog20250722traee4bdbfe794a8e79a84e7b0a1e596aee58886e4baab-check><a href=/zh-tw/blog/2025/07/22/trae%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B0%A1%E5%96%AE%E5%88%86%E4%BA%AB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250722traee4bdbfe794a8e79a84e7b0a1e596aee58886e4baab><span>trae使用的簡單分享</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250711e6a8a1e59e8be4b8ade8bd89e69c8de58b99e79a84e694bbe6938ae696b9e5bc8f-li><input type=checkbox id=m-zh-twblog20250711e6a8a1e59e8be4b8ade8bd89e69c8de58b99e79a84e694bbe6938ae696b9e5bc8f-check>
<label for=m-zh-twblog20250711e6a8a1e59e8be4b8ade8bd89e69c8de58b99e79a84e694bbe6938ae696b9e5bc8f-check><a href=/zh-tw/blog/2025/07/11/%E6%A8%A1%E5%9E%8B%E4%B8%AD%E8%BD%89%E6%9C%8D%E5%8B%99%E7%9A%84%E6%94%BB%E6%93%8A%E6%96%B9%E5%BC%8F/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250711e6a8a1e59e8be4b8ade8bd89e69c8de58b99e79a84e694bbe6938ae696b9e5bc8f><span>模型中轉服務的攻擊方式</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250710e4b8ade8bd89e6a8a1e59e8be69c8de58b99e79a84e9a2a8e99aaa-li><input type=checkbox id=m-zh-twblog20250710e4b8ade8bd89e6a8a1e59e8be69c8de58b99e79a84e9a2a8e99aaa-check>
<label for=m-zh-twblog20250710e4b8ade8bd89e6a8a1e59e8be69c8de58b99e79a84e9a2a8e99aaa-check><a href=/zh-tw/blog/2025/07/10/%E4%B8%AD%E8%BD%89%E6%A8%A1%E5%9E%8B%E6%9C%8D%E5%8B%99%E7%9A%84%E9%A2%A8%E9%9A%AA/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250710e4b8ade8bd89e6a8a1e59e8be69c8de58b99e79a84e9a2a8e99aaa><span>中轉模型服務的風險</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250710e782baadguardhomee5a29ee58aa0e58886e6b581e883bde58a9b-li><input type=checkbox id=m-zh-twblog20250710e782baadguardhomee5a29ee58aa0e58886e6b581e883bde58a9b-check>
<label for=m-zh-twblog20250710e782baadguardhomee5a29ee58aa0e58886e6b581e883bde58a9b-check><a href=/zh-tw/blog/2025/07/10/%E7%82%BAadguardhome%E5%A2%9E%E5%8A%A0%E5%88%86%E6%B5%81%E8%83%BD%E5%8A%9B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250710e782baadguardhomee5a29ee58aa0e58886e6b581e883bde58a9b><span>為AdguardHome增加分流能力</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250710e9a085e79baee5a49ae8aa9ee8a880e981a9e59088e981b8e69387e593aae4ba9be8aa9ee8a880-li><input type=checkbox id=m-zh-twblog20250710e9a085e79baee5a49ae8aa9ee8a880e981a9e59088e981b8e69387e593aae4ba9be8aa9ee8a880-check>
<label for=m-zh-twblog20250710e9a085e79baee5a49ae8aa9ee8a880e981a9e59088e981b8e69387e593aae4ba9be8aa9ee8a880-check><a href=/zh-tw/blog/2025/07/10/%E9%A0%85%E7%9B%AE%E5%A4%9A%E8%AA%9E%E8%A8%80%E9%81%A9%E5%90%88%E9%81%B8%E6%93%87%E5%93%AA%E4%BA%9B%E8%AA%9E%E8%A8%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250710e9a085e79baee5a49ae8aa9ee8a880e981a9e59088e981b8e69387e593aae4ba9be8aa9ee8a880><span>項目多語言適合選擇哪些語言</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250709e59897e8a9a6e5aea2e8a780e79a84e8a995e583b9e88fafe782ba-li><input type=checkbox id=m-zh-twblog20250709e59897e8a9a6e5aea2e8a780e79a84e8a995e583b9e88fafe782ba-check>
<label for=m-zh-twblog20250709e59897e8a9a6e5aea2e8a780e79a84e8a995e583b9e88fafe782ba-check><a href=/zh-tw/blog/2025/07/09/%E5%98%97%E8%A9%A6%E5%AE%A2%E8%A7%80%E7%9A%84%E8%A9%95%E5%83%B9%E8%8F%AF%E7%82%BA/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250709e59897e8a9a6e5aea2e8a780e79a84e8a995e583b9e88fafe782ba><span>嘗試客觀的評價華為</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250627cursore887aae58b95e58c96e8aabfe8a9a6-li><input type=checkbox id=m-zh-twblog20250627cursore887aae58b95e58c96e8aabfe8a9a6-check>
<label for=m-zh-twblog20250627cursore887aae58b95e58c96e8aabfe8a9a6-check><a href=/zh-tw/blog/2025/06/27/cursor%E8%87%AA%E5%8B%95%E5%8C%96%E8%AA%BF%E8%A9%A6/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250627cursore887aae58b95e58c96e8aabfe8a9a6><span>cursor自動化調試</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250625wsl-mirrored-e7b6b2e8b7afe6a8a1e5bc8fe8a8ade5ae9ae68c87e58d97-li><input type=checkbox id=m-zh-twblog20250625wsl-mirrored-e7b6b2e8b7afe6a8a1e5bc8fe8a8ade5ae9ae68c87e58d97-check>
<label for=m-zh-twblog20250625wsl-mirrored-e7b6b2e8b7afe6a8a1e5bc8fe8a8ade5ae9ae68c87e58d97-check><a href=/zh-tw/blog/2025/06/25/wsl-mirrored-%E7%B6%B2%E8%B7%AF%E6%A8%A1%E5%BC%8F%E8%A8%AD%E5%AE%9A%E6%8C%87%E5%8D%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250625wsl-mirrored-e7b6b2e8b7afe6a8a1e5bc8fe8a8ade5ae9ae68c87e58d97><span>WSL mirrored 網路模式設定指南</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250526windows-sshe981a0e7a88be799bbe98c84-li><input type=checkbox id=m-zh-twblog20250526windows-sshe981a0e7a88be799bbe98c84-check>
<label for=m-zh-twblog20250526windows-sshe981a0e7a88be799bbe98c84-check><a href=/zh-tw/blog/2025/05/26/windows-ssh%E9%81%A0%E7%A8%8B%E7%99%BB%E9%8C%84/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250526windows-sshe981a0e7a88be799bbe98c84><span>Windows SSH遠程登錄</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250524androide9968be799bc-li><input type=checkbox id=m-zh-twblog20250524androide9968be799bc-check>
<label for=m-zh-twblog20250524androide9968be799bc-check><a href=/zh-tw/blog/2025/05/24/android%E9%96%8B%E7%99%BC/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250524androide9968be799bc><span>Android開發</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250425cnamee88887txte8a19de7aa81e5b08ee887b4e8ad89e69bb8e794b3e8ab8be5958fe9a18c-li><input type=checkbox id=m-zh-twblog20250425cnamee88887txte8a19de7aa81e5b08ee887b4e8ad89e69bb8e794b3e8ab8be5958fe9a18c-check>
<label for=m-zh-twblog20250425cnamee88887txte8a19de7aa81e5b08ee887b4e8ad89e69bb8e794b3e8ab8be5958fe9a18c-check><a href=/zh-tw/blog/2025/04/25/cname%E8%88%87txt%E8%A1%9D%E7%AA%81%E5%B0%8E%E8%87%B4%E8%AD%89%E6%9B%B8%E7%94%B3%E8%AB%8B%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250425cnamee88887txte8a19de7aa81e5b08ee887b4e8ad89e69bb8e794b3e8ab8be5958fe9a18c><span>CNAME與TXT衝突導致證書申請問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250330e4be86e887aa-cline-e79a84e68f90e7a4bae68c87e58d97-li><input type=checkbox id=m-zh-twblog20250330e4be86e887aa-cline-e79a84e68f90e7a4bae68c87e58d97-check>
<label for=m-zh-twblog20250330e4be86e887aa-cline-e79a84e68f90e7a4bae68c87e58d97-check><a href=/zh-tw/blog/2025/03/30/%E4%BE%86%E8%87%AA-cline-%E7%9A%84%E6%8F%90%E7%A4%BA%E6%8C%87%E5%8D%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250330e4be86e887aa-cline-e79a84e68f90e7a4bae68c87e58d97><span>來自 cline 的提示指南</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250327e6809de7b6ade5b7a5e585b7-li><input type=checkbox id=m-zh-twblog20250327e6809de7b6ade5b7a5e585b7-check>
<label for=m-zh-twblog20250327e6809de7b6ade5b7a5e585b7-check><a href=/zh-tw/blog/2025/03/27/%E6%80%9D%E7%B6%AD%E5%B7%A5%E5%85%B7/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250327e6809de7b6ade5b7a5e585b7><span>思維工具</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250319e5a682e4bd95e981bfe5858de8a2abe9968be79b92-li><input type=checkbox id=m-zh-twblog20250319e5a682e4bd95e981bfe5858de8a2abe9968be79b92-check>
<label for=m-zh-twblog20250319e5a682e4bd95e981bfe5858de8a2abe9968be79b92-check><a href=/zh-tw/blog/2025/03/19/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E9%96%8B%E7%9B%92/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250319e5a682e4bd95e981bfe5858de8a2abe9968be79b92><span>如何避免被開盒</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250317esae59ca8cnamee6a8a1e5bc8fe4b88be78db2e5be97e6b39be59f9fe5908de8ad89e69bb8e696b9e6b395-li><input type=checkbox id=m-zh-twblog20250317esae59ca8cnamee6a8a1e5bc8fe4b88be78db2e5be97e6b39be59f9fe5908de8ad89e69bb8e696b9e6b395-check>
<label for=m-zh-twblog20250317esae59ca8cnamee6a8a1e5bc8fe4b88be78db2e5be97e6b39be59f9fe5908de8ad89e69bb8e696b9e6b395-check><a href=/zh-tw/blog/2025/03/17/esa%E5%9C%A8cname%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%8D%B2%E5%BE%97%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AD%89%E6%9B%B8%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250317esae59ca8cnamee6a8a1e5bc8fe4b88be78db2e5be97e6b39be59f9fe5908de8ad89e69bb8e696b9e6b395><span>ESA在cname模式下獲得泛域名證書方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250317aie58aa9e6898be6af94e68891e881b0e6988ee5be88e5a49a-li><input type=checkbox id=m-zh-twblog20250317aie58aa9e6898be6af94e68891e881b0e6988ee5be88e5a49a-check>
<label for=m-zh-twblog20250317aie58aa9e6898be6af94e68891e881b0e6988ee5be88e5a49a-check><a href=/zh-tw/blog/2025/03/17/ai%E5%8A%A9%E6%89%8B%E6%AF%94%E6%88%91%E8%81%B0%E6%98%8E%E5%BE%88%E5%A4%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250317aie58aa9e6898be6af94e68891e881b0e6988ee5be88e5a49a><span>AI助手比我聰明很多</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250304github-copilote4bb98e8b2bbe6a8a1e59e8be5b08de6af94-li><input type=checkbox id=m-zh-twblog20250304github-copilote4bb98e8b2bbe6a8a1e59e8be5b08de6af94-check>
<label for=m-zh-twblog20250304github-copilote4bb98e8b2bbe6a8a1e59e8be5b08de6af94-check><a href=/zh-tw/blog/2025/03/04/github-copilot%E4%BB%98%E8%B2%BB%E6%A8%A1%E5%9E%8B%E5%B0%8D%E6%AF%94/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250304github-copilote4bb98e8b2bbe6a8a1e59e8be5b08de6af94><span>Github Copilot付費模型對比</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250228github-copilot-agente6a8a1e5bc8fe4bdbfe794a8e7b693e9a997e58886e4baab-li><input type=checkbox id=m-zh-twblog20250228github-copilot-agente6a8a1e5bc8fe4bdbfe794a8e7b693e9a997e58886e4baab-check>
<label for=m-zh-twblog20250228github-copilot-agente6a8a1e5bc8fe4bdbfe794a8e7b693e9a997e58886e4baab-check><a href=/zh-tw/blog/2025/02/28/github-copilot-agent%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250228github-copilot-agente6a8a1e5bc8fe4bdbfe794a8e7b693e9a997e58886e4baab><span>Github Copilot Agent模式使用經驗分享</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250228e5b9bee5808be69bb4e5ae89e585a8e4bdbfe794a8e585ace7b6b2ipv6e79a84e696b9e6b395-li><input type=checkbox id=m-zh-twblog20250228e5b9bee5808be69bb4e5ae89e585a8e4bdbfe794a8e585ace7b6b2ipv6e79a84e696b9e6b395-check>
<label for=m-zh-twblog20250228e5b9bee5808be69bb4e5ae89e585a8e4bdbfe794a8e585ace7b6b2ipv6e79a84e696b9e6b395-check><a href=/zh-tw/blog/2025/02/28/%E5%B9%BE%E5%80%8B%E6%9B%B4%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%E5%85%AC%E7%B6%B2ipv6%E7%9A%84%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250228e5b9bee5808be69bb4e5ae89e585a8e4bdbfe794a8e585ace7b6b2ipv6e79a84e696b9e6b395><span>幾個更安全使用公網IPv6的方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250220e5bba3e5918ae69494e688aae696b0e981b8e69387--adguardprivate-li><input type=checkbox id=m-zh-twblog20250220e5bba3e5918ae69494e688aae696b0e981b8e69387--adguardprivate-check>
<label for=m-zh-twblog20250220e5bba3e5918ae69494e688aae696b0e981b8e69387--adguardprivate-check><a href=/zh-tw/blog/2025/02/20/%E5%BB%A3%E5%91%8A%E6%94%94%E6%88%AA%E6%96%B0%E9%81%B8%E6%93%87--adguardprivate/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250220e5bba3e5918ae69494e688aae696b0e981b8e69387--adguardprivate><span>廣告攔截新選擇--AdGuardPrivate</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250220e4bdbfe794a8-curl-e78db2e58f96-dns-e7b590e69e9c-li><input type=checkbox id=m-zh-twblog20250220e4bdbfe794a8-curl-e78db2e58f96-dns-e7b590e69e9c-check>
<label for=m-zh-twblog20250220e4bdbfe794a8-curl-e78db2e58f96-dns-e7b590e69e9c-check><a href=/zh-tw/blog/2025/02/20/%E4%BD%BF%E7%94%A8-curl-%E7%8D%B2%E5%8F%96-dns-%E7%B5%90%E6%9E%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250220e4bdbfe794a8-curl-e78db2e58f96-dns-e7b590e69e9c><span>使用 curl 獲取 DNS 結果</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250220e5a682e4bd95e4bdbfe794a8e5bf85e68789e59c8be99a9be78988-li><input type=checkbox id=m-zh-twblog20250220e5a682e4bd95e4bdbfe794a8e5bf85e68789e59c8be99a9be78988-check>
<label for=m-zh-twblog20250220e5a682e4bd95e4bdbfe794a8e5bf85e68789e59c8be99a9be78988-check><a href=/zh-tw/blog/2025/02/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BF%85%E6%87%89%E5%9C%8B%E9%9A%9B%E7%89%88/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250220e5a682e4bd95e4bdbfe794a8e5bf85e68789e59c8be99a9be78988><span>如何使用必應國際版</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250219e4bdbfe794a8e5b8b8e8a68b-ddns-e5ad90e7b6b2e59f9fe58fafe883bde5b08ee887b4e99bbbe4bfa1e5aface9a0bbe69c8de58b99e9998de7b49a-li><input type=checkbox id=m-zh-twblog20250219e4bdbfe794a8e5b8b8e8a68b-ddns-e5ad90e7b6b2e59f9fe58fafe883bde5b08ee887b4e99bbbe4bfa1e5aface9a0bbe69c8de58b99e9998de7b49a-check>
<label for=m-zh-twblog20250219e4bdbfe794a8e5b8b8e8a68b-ddns-e5ad90e7b6b2e59f9fe58fafe883bde5b08ee887b4e99bbbe4bfa1e5aface9a0bbe69c8de58b99e9998de7b49a-check><a href=/zh-tw/blog/2025/02/19/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A6%8B-ddns-%E5%AD%90%E7%B6%B2%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%B0%8E%E8%87%B4%E9%9B%BB%E4%BF%A1%E5%AF%AC%E9%A0%BB%E6%9C%8D%E5%8B%99%E9%99%8D%E7%B4%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250219e4bdbfe794a8e5b8b8e8a68b-ddns-e5ad90e7b6b2e59f9fe58fafe883bde5b08ee887b4e99bbbe4bfa1e5aface9a0bbe69c8de58b99e9998de7b49a><span>使用常見 DDNS 子網域可能導致電信寬頻服務降級</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250217e5aeb6e5baade7b6b2e8b7afe58f8de59091e4bba3e79086e79a84e59088e8a68fe680a7e68ea2e8a88e-li><input type=checkbox id=m-zh-twblog20250217e5aeb6e5baade7b6b2e8b7afe58f8de59091e4bba3e79086e79a84e59088e8a68fe680a7e68ea2e8a88e-check>
<label for=m-zh-twblog20250217e5aeb6e5baade7b6b2e8b7afe58f8de59091e4bba3e79086e79a84e59088e8a68fe680a7e68ea2e8a88e-check><a href=/zh-tw/blog/2025/02/17/%E5%AE%B6%E5%BA%AD%E7%B6%B2%E8%B7%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%90%88%E8%A6%8F%E6%80%A7%E6%8E%A2%E8%A8%8E/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250217e5aeb6e5baade7b6b2e8b7afe58f8de59091e4bba3e79086e79a84e59088e8a68fe680a7e68ea2e8a88e><span>家庭網路反向代理的合規性探討</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241231e9878be694bevpse79a84e4bf9de79599e8a898e686b6e9ab94-li><input type=checkbox id=m-zh-twblog20241231e9878be694bevpse79a84e4bf9de79599e8a898e686b6e9ab94-check>
<label for=m-zh-twblog20241231e9878be694bevpse79a84e4bf9de79599e8a898e686b6e9ab94-check><a href=/zh-tw/blog/2024/12/31/%E9%87%8B%E6%94%BEvps%E7%9A%84%E4%BF%9D%E7%95%99%E8%A8%98%E6%86%B6%E9%AB%94/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241231e9878be694bevpse79a84e4bf9de79599e8a898e686b6e9ab94><span>釋放vps的保留記憶體</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241213e69f90e5bba0e59586e998b2e6ada2dnse69494e688aae79a84e8bea6e6b395-li><input type=checkbox id=m-zh-twblog20241213e69f90e5bba0e59586e998b2e6ada2dnse69494e688aae79a84e8bea6e6b395-check>
<label for=m-zh-twblog20241213e69f90e5bba0e59586e998b2e6ada2dnse69494e688aae79a84e8bea6e6b395-check><a href=/zh-tw/blog/2024/12/13/%E6%9F%90%E5%BB%A0%E5%95%86%E9%98%B2%E6%AD%A2dns%E6%94%94%E6%88%AA%E7%9A%84%E8%BE%A6%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241213e69f90e5bba0e59586e998b2e6ada2dnse69494e688aae79a84e8bea6e6b395><span>某廠商防止DNS攔截的辦法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241205e5beaee4bfa1e8ae80e69bb8e887aae58b95e68993e58da1e588b7e69982e995b7-li><input type=checkbox id=m-zh-twblog20241205e5beaee4bfa1e8ae80e69bb8e887aae58b95e68993e58da1e588b7e69982e995b7-check>
<label for=m-zh-twblog20241205e5beaee4bfa1e8ae80e69bb8e887aae58b95e68993e58da1e588b7e69982e995b7-check><a href=/zh-tw/blog/2024/12/05/%E5%BE%AE%E4%BF%A1%E8%AE%80%E6%9B%B8%E8%87%AA%E5%8B%95%E6%89%93%E5%8D%A1%E5%88%B7%E6%99%82%E9%95%B7/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241205e5beaee4bfa1e8ae80e69bb8e887aae58b95e68993e58da1e588b7e69982e995b7><span>微信讀書自動打卡刷時長</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241203e4bd8ee9a2a8e99aaae788ace89fb2e8a18ce782bae58886e69e90e694b6e79b8ae88887e7ad96e795a5-li><input type=checkbox id=m-zh-twblog20241203e4bd8ee9a2a8e99aaae788ace89fb2e8a18ce782bae58886e69e90e694b6e79b8ae88887e7ad96e795a5-check>
<label for=m-zh-twblog20241203e4bd8ee9a2a8e99aaae788ace89fb2e8a18ce782bae58886e69e90e694b6e79b8ae88887e7ad96e795a5-check><a href=/zh-tw/blog/2024/12/03/%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%88%AC%E8%9F%B2%E8%A1%8C%E7%82%BA%E5%88%86%E6%9E%90%E6%94%B6%E7%9B%8A%E8%88%87%E7%AD%96%E7%95%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241203e4bd8ee9a2a8e99aaae788ace89fb2e8a18ce782bae58886e69e90e694b6e79b8ae88887e7ad96e795a5><span>低風險爬蟲行為分析：收益與策略</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241118e9979ce99689e78da8e7ab8be9a1afe7a4bae58da1e4bba5e79c81e99bbb-li><input type=checkbox id=m-zh-twblog20241118e9979ce99689e78da8e7ab8be9a1afe7a4bae58da1e4bba5e79c81e99bbb-check>
<label for=m-zh-twblog20241118e9979ce99689e78da8e7ab8be9a1afe7a4bae58da1e4bba5e79c81e99bbb-check><a href=/zh-tw/blog/2024/11/18/%E9%97%9C%E9%96%89%E7%8D%A8%E7%AB%8B%E9%A1%AF%E7%A4%BA%E5%8D%A1%E4%BB%A5%E7%9C%81%E9%9B%BB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241118e9979ce99689e78da8e7ab8be9a1afe7a4bae58da1e4bba5e79c81e99bbb><span>關閉獨立顯示卡以省電</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241115google-e7bfbbe8adaf-api-e79a84e4bdbfe794a8e69599e7a88b-li><input type=checkbox id=m-zh-twblog20241115google-e7bfbbe8adaf-api-e79a84e4bdbfe794a8e69599e7a88b-check>
<label for=m-zh-twblog20241115google-e7bfbbe8adaf-api-e79a84e4bdbfe794a8e69599e7a88b-check><a href=/zh-tw/blog/2024/11/15/google-%E7%BF%BB%E8%AD%AF-api-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241115google-e7bfbbe8adaf-api-e79a84e4bdbfe794a8e69599e7a88b><span>Google 翻譯 API 的使用教程</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241112e981bfe5858de58d9ae5aea2e6b4a9e99cb2e5808be4babae8b387e8a88a-li><input type=checkbox id=m-zh-twblog20241112e981bfe5858de58d9ae5aea2e6b4a9e99cb2e5808be4babae8b387e8a88a-check>
<label for=m-zh-twblog20241112e981bfe5858de58d9ae5aea2e6b4a9e99cb2e5808be4babae8b387e8a88a-check><a href=/zh-tw/blog/2024/11/12/%E9%81%BF%E5%85%8D%E5%8D%9A%E5%AE%A2%E6%B4%A9%E9%9C%B2%E5%80%8B%E4%BA%BA%E8%B3%87%E8%A8%8A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241112e981bfe5858de58d9ae5aea2e6b4a9e99cb2e5808be4babae8b387e8a88a><span>避免博客洩露個人資訊</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20241106windows-server-2019-e995b7e69982e99693e9818be8a18c-ipv6-e696b7e980a3e5958fe9a18c-li><input type=checkbox id=m-zh-twblog20241106windows-server-2019-e995b7e69982e99693e9818be8a18c-ipv6-e696b7e980a3e5958fe9a18c-check>
<label for=m-zh-twblog20241106windows-server-2019-e995b7e69982e99693e9818be8a18c-ipv6-e696b7e980a3e5958fe9a18c-check><a href=/zh-tw/blog/2024/11/06/windows-server-2019-%E9%95%B7%E6%99%82%E9%96%93%E9%81%8B%E8%A1%8C-ipv6-%E6%96%B7%E9%80%A3%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20241106windows-server-2019-e995b7e69982e99693e9818be8a18c-ipv6-e696b7e980a3e5958fe9a18c><span>Windows Server 2019 長時間運行 ipv6 斷連問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628snort-li><input type=checkbox id=m-zh-twblog20240628snort-check>
<label for=m-zh-twblog20240628snort-check><a href=/zh-tw/blog/2024/06/28/snort/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628snort><span>snort</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628linuxe5b08ee8a6bd-li><input type=checkbox id=m-zh-twblog20240628linuxe5b08ee8a6bd-check>
<label for=m-zh-twblog20240628linuxe5b08ee8a6bd-check><a href=/zh-tw/blog/2024/06/28/linux%E5%B0%8E%E8%A6%BD/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628linuxe5b08ee8a6bd><span>linux導覽</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e7acace4b889e696b9e5baabe79a84e999b7e998b1-li><input type=checkbox id=m-zh-twblog20240628e7acace4b889e696b9e5baabe79a84e999b7e998b1-check>
<label for=m-zh-twblog20240628e7acace4b889e696b9e5baabe79a84e999b7e998b1-check><a href=/zh-tw/blog/2024/06/28/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%AB%E7%9A%84%E9%99%B7%E9%98%B1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e7acace4b889e696b9e5baabe79a84e999b7e998b1><span>第三方庫的陷阱</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e696b9e6a188e8a8ade8a888e6a8a1e69dbf-li><input type=checkbox id=m-zh-twblog20240628e696b9e6a188e8a8ade8a888e6a8a1e69dbf-check>
<label for=m-zh-twblog20240628e696b9e6a188e8a8ade8a888e6a8a1e69dbf-check><a href=/zh-tw/blog/2024/06/28/%E6%96%B9%E6%A1%88%E8%A8%AD%E8%A8%88%E6%A8%A1%E6%9D%BF/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e696b9e6a188e8a8ade8a888e6a8a1e69dbf><span>方案設計模板</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e591bde4bba4e8a18ce8aa9ee6b395e7b484e5ae9a-li><input type=checkbox id=m-zh-twblog20240628e591bde4bba4e8a18ce8aa9ee6b395e7b484e5ae9a-check>
<label for=m-zh-twblog20240628e591bde4bba4e8a18ce8aa9ee6b395e7b484e5ae9a-check><a href=/zh-tw/blog/2024/06/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AA%9E%E6%B3%95%E7%B4%84%E5%AE%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e591bde4bba4e8a18ce8aa9ee6b395e7b484e5ae9a><span>命令行語法約定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e591bde4bba4e8a18ce6898be5868ae4b8ade68bace8999fe79a84e590abe7bea9-li><input type=checkbox id=m-zh-twblog20240628e591bde4bba4e8a18ce6898be5868ae4b8ade68bace8999fe79a84e590abe7bea9-check>
<label for=m-zh-twblog20240628e591bde4bba4e8a18ce6898be5868ae4b8ade68bace8999fe79a84e590abe7bea9-check><a href=/zh-tw/blog/2024/06/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%8B%E5%86%8A%E4%B8%AD%E6%8B%AC%E8%99%9F%E7%9A%84%E5%90%AB%E7%BE%A9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e591bde4bba4e8a18ce6898be5868ae4b8ade68bace8999fe79a84e590abe7bea9><span>命令行手冊中括號的含義</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-zh-twblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-li><input type=checkbox id=m-zh-twblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check checked>
<label for=m-zh-twblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check><a href=/zh-tw/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83><span class=td-sidebar-nav-active-item>华为C++编程规范</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e99bbbe4bfa1ipv6e79a84e4b880e4ba9be789b9e5beb5-li><input type=checkbox id=m-zh-twblog20240628e99bbbe4bfa1ipv6e79a84e4b880e4ba9be789b9e5beb5-check>
<label for=m-zh-twblog20240628e99bbbe4bfa1ipv6e79a84e4b880e4ba9be789b9e5beb5-check><a href=/zh-tw/blog/2024/06/28/%E9%9B%BB%E4%BF%A1ipv6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E5%BE%B5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e99bbbe4bfa1ipv6e79a84e4b880e4ba9be789b9e5beb5><span>電信IPv6的一些特徵</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e782bae4bb80e9babce4b88de68789e8a9b2e68a8atcpe6809de7b6ade5a597e59ca8udpe4b88a-li><input type=checkbox id=m-zh-twblog20240628e782bae4bb80e9babce4b88de68789e8a9b2e68a8atcpe6809de7b6ade5a597e59ca8udpe4b88a-check>
<label for=m-zh-twblog20240628e782bae4bb80e9babce4b88de68789e8a9b2e68a8atcpe6809de7b6ade5a597e59ca8udpe4b88a-check><a href=/zh-tw/blog/2024/06/28/%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E6%87%89%E8%A9%B2%E6%8A%8Atcp%E6%80%9D%E7%B6%AD%E5%A5%97%E5%9C%A8udp%E4%B8%8A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e782bae4bb80e9babce4b88de68789e8a9b2e68a8atcpe6809de7b6ade5a597e59ca8udpe4b88a><span>為什麼不應該把TCP思維套在UDP上</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628openvpne7b6b2e8b7afe4b88de9809a-li><input type=checkbox id=m-zh-twblog20240628openvpne7b6b2e8b7afe4b88de9809a-check>
<label for=m-zh-twblog20240628openvpne7b6b2e8b7afe4b88de9809a-check><a href=/zh-tw/blog/2024/06/28/openvpn%E7%B6%B2%E8%B7%AF%E4%B8%8D%E9%80%9A/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628openvpne7b6b2e8b7afe4b88de9809a><span>openvpn網路不通</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e79086e8a7a3windowse7b6b2e8b7af_wfp-li><input type=checkbox id=m-zh-twblog20240628e79086e8a7a3windowse7b6b2e8b7af_wfp-check>
<label for=m-zh-twblog20240628e79086e8a7a3windowse7b6b2e8b7af_wfp-check><a href=/zh-tw/blog/2024/06/28/%E7%90%86%E8%A7%A3windows%E7%B6%B2%E8%B7%AF_wfp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e79086e8a7a3windowse7b6b2e8b7af_wfp><span>理解Windows網路_WFP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e79086e8a7a3windowse4ba8be4bbb6e8bfbde8b9a4_etw-li><input type=checkbox id=m-zh-twblog20240628e79086e8a7a3windowse4ba8be4bbb6e8bfbde8b9a4_etw-check>
<label for=m-zh-twblog20240628e79086e8a7a3windowse4ba8be4bbb6e8bfbde8b9a4_etw-check><a href=/zh-tw/blog/2024/06/28/%E7%90%86%E8%A7%A3windows%E4%BA%8B%E4%BB%B6%E8%BF%BD%E8%B9%A4_etw/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e79086e8a7a3windowse4ba8be4bbb6e8bfbde8b9a4_etw><span>理解Windows事件追蹤_ETW</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628wireguarde9858de7bdae-li><input type=checkbox id=m-zh-twblog20240628wireguarde9858de7bdae-check>
<label for=m-zh-twblog20240628wireguarde9858de7bdae-check><a href=/zh-tw/blog/2024/06/28/wireguard%E9%85%8D%E7%BD%AE/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628wireguarde9858de7bdae><span>wireguard配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628windowse998bbe696b7e7b6b2e8b7afe6b581e9878fe58f96e5be97-li><input type=checkbox id=m-zh-twblog20240628windowse998bbe696b7e7b6b2e8b7afe6b581e9878fe58f96e5be97-check>
<label for=m-zh-twblog20240628windowse998bbe696b7e7b6b2e8b7afe6b581e9878fe58f96e5be97-check><a href=/zh-tw/blog/2024/06/28/windows%E9%98%BB%E6%96%B7%E7%B6%B2%E8%B7%AF%E6%B5%81%E9%87%8F%E5%8F%96%E5%BE%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628windowse998bbe696b7e7b6b2e8b7afe6b581e9878fe58f96e5be97><span>Windows阻斷網路流量取得</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628windowse998b2e781abe78986e7aea1e79086-netsh-li><input type=checkbox id=m-zh-twblog20240628windowse998b2e781abe78986e7aea1e79086-netsh-check>
<label for=m-zh-twblog20240628windowse998b2e781abe78986e7aea1e79086-netsh-check><a href=/zh-tw/blog/2024/06/28/windows%E9%98%B2%E7%81%AB%E7%89%86%E7%AE%A1%E7%90%86-netsh/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628windowse998b2e781abe78986e7aea1e79086-netsh><span>Windows防火牆管理-netsh</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628windowse79bb8e9979ce8b387e6ba90-li><input type=checkbox id=m-zh-twblog20240628windowse79bb8e9979ce8b387e6ba90-check>
<label for=m-zh-twblog20240628windowse79bb8e9979ce8b387e6ba90-check><a href=/zh-tw/blog/2024/06/28/windows%E7%9B%B8%E9%97%9C%E8%B3%87%E6%BA%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628windowse79bb8e9979ce8b387e6ba90><span>Windows相關資源</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628windowse5b08ee8a6bd-li><input type=checkbox id=m-zh-twblog20240628windowse5b08ee8a6bd-check>
<label for=m-zh-twblog20240628windowse5b08ee8a6bd-check><a href=/zh-tw/blog/2024/06/28/windows%E5%B0%8E%E8%A6%BD/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628windowse5b08ee8a6bd><span>Windows導覽</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628windows-ipv6e7aea1e79086-li><input type=checkbox id=m-zh-twblog20240628windows-ipv6e7aea1e79086-check>
<label for=m-zh-twblog20240628windows-ipv6e7aea1e79086-check><a href=/zh-tw/blog/2024/06/28/windows-ipv6%E7%AE%A1%E7%90%86/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628windows-ipv6e7aea1e79086><span>windows-ipv6管理</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628window-message-li><input type=checkbox id=m-zh-twblog20240628window-message-check>
<label for=m-zh-twblog20240628window-message-check><a href=/zh-tw/blog/2024/06/28/window-message/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628window-message><span>window-message</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628win-to-go-li><input type=checkbox id=m-zh-twblog20240628win-to-go-check>
<label for=m-zh-twblog20240628win-to-go-check><a href=/zh-tw/blog/2024/06/28/win-to-go/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628win-to-go><span>Win-to-go</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e8999be693ace8a898e686b6e9ab94e7a381e7a29fe9858de7bdae-li><input type=checkbox id=m-zh-twblog20240628e8999be693ace8a898e686b6e9ab94e7a381e7a29fe9858de7bdae-check>
<label for=m-zh-twblog20240628e8999be693ace8a898e686b6e9ab94e7a381e7a29fe9858de7bdae-check><a href=/zh-tw/blog/2024/06/28/%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94%E7%A3%81%E7%A2%9F%E9%85%8D%E7%BD%AE/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e8999be693ace8a898e686b6e9ab94e7a381e7a29fe9858de7bdae><span>虛擬記憶體磁碟配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628wsl-li><input type=checkbox id=m-zh-twblog20240628wsl-check>
<label for=m-zh-twblog20240628wsl-check><a href=/zh-tw/blog/2024/06/28/wsl/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628wsl><span>wsl</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628letsencrypte79a84e68691e8ad89e794b3e8ab8be99990e588b6-li><input type=checkbox id=m-zh-twblog20240628letsencrypte79a84e68691e8ad89e794b3e8ab8be99990e588b6-check>
<label for=m-zh-twblog20240628letsencrypte79a84e68691e8ad89e794b3e8ab8be99990e588b6-check><a href=/zh-tw/blog/2024/06/28/letsencrypt%E7%9A%84%E6%86%91%E8%AD%89%E7%94%B3%E8%AB%8B%E9%99%90%E5%88%B6/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628letsencrypte79a84e68691e8ad89e794b3e8ab8be99990e588b6><span>letsencrypt的憑證申請限制</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e7b0a1e69893server-cliente4bba3e7a2bc-li><input type=checkbox id=m-zh-twblog20240628e7b0a1e69893server-cliente4bba3e7a2bc-check>
<label for=m-zh-twblog20240628e7b0a1e69893server-cliente4bba3e7a2bc-check><a href=/zh-tw/blog/2024/06/28/%E7%B0%A1%E6%98%93server-client%E4%BB%A3%E7%A2%BC/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e7b0a1e69893server-cliente4bba3e7a2bc><span>簡易server-client代碼</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628calico-exploration-li><input type=checkbox id=m-zh-twblog20240628calico-exploration-check>
<label for=m-zh-twblog20240628calico-exploration-check><a href=/zh-tw/blog/2024/06/28/calico-exploration/ title="Calico 網路外掛探索與實作" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628calico-exploration><span>Calico 探索</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628dockere4bb8be7b4b9-li><input type=checkbox id=m-zh-twblog20240628dockere4bb8be7b4b9-check>
<label for=m-zh-twblog20240628dockere4bb8be7b4b9-check><a href=/zh-tw/blog/2024/06/28/docker%E4%BB%8B%E7%B4%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628dockere4bb8be7b4b9><span>docker介紹</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628copilote4bdbfe794a8e585a5e99680-li><input type=checkbox id=m-zh-twblog20240628copilote4bdbfe794a8e585a5e99680-check>
<label for=m-zh-twblog20240628copilote4bdbfe794a8e585a5e99680-check><a href=/zh-tw/blog/2024/06/28/copilot%E4%BD%BF%E7%94%A8%E5%85%A5%E9%96%80/ title=Copilot使用入門 class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628copilote4bdbfe794a8e585a5e99680><span>Copilot的用法分享</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628chatgpt-user-guide-li><input type=checkbox id=m-zh-twblog20240628chatgpt-user-guide-check>
<label for=m-zh-twblog20240628chatgpt-user-guide-check><a href=/zh-tw/blog/2024/06/28/chatgpt-user-guide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628chatgpt-user-guide><span>ChatGPT 使用指南</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e58fafe4bfa1e8a8ade8a888-li><input type=checkbox id=m-zh-twblog20240628e58fafe4bfa1e8a8ade8a888-check>
<label for=m-zh-twblog20240628e58fafe4bfa1e8a8ade8a888-check><a href=/zh-tw/blog/2024/06/28/%E5%8F%AF%E4%BF%A1%E8%A8%AD%E8%A8%88/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e58fafe4bfa1e8a8ade8a888><span>可信設計</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e88fafe782bae58fafe4bfa1e6a682e5bfb5-li><input type=checkbox id=m-zh-twblog20240628e88fafe782bae58fafe4bfa1e6a682e5bfb5-check>
<label for=m-zh-twblog20240628e88fafe782bae58fafe4bfa1e6a682e5bfb5-check><a href=/zh-tw/blog/2024/06/28/%E8%8F%AF%E7%82%BA%E5%8F%AF%E4%BF%A1%E6%A6%82%E5%BF%B5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e88fafe782bae58fafe4bfa1e6a682e5bfb5><span>華為可信概念</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628e88fafe782bae585a7e7b6b2e7b6b2e8b7afe5ae89e585a8e58886e69e90-li><input type=checkbox id=m-zh-twblog20240628e88fafe782bae585a7e7b6b2e7b6b2e8b7afe5ae89e585a8e58886e69e90-check>
<label for=m-zh-twblog20240628e88fafe782bae585a7e7b6b2e7b6b2e8b7afe5ae89e585a8e58886e69e90-check><a href=/zh-tw/blog/2024/06/28/%E8%8F%AF%E7%82%BA%E5%85%A7%E7%B6%B2%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628e88fafe782bae585a7e7b6b2e7b6b2e8b7afe5ae89e585a8e58886e69e90><span>華為內網網路安全分析</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628about-child-protection-li><input type=checkbox id=m-zh-twblog20240628about-child-protection-check>
<label for=m-zh-twblog20240628about-child-protection-check><a href=/zh-tw/blog/2024/06/28/about-child-protection/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628about-child-protection><span>兒童的上網保護</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240628dos-e998b2e7af84-li><input type=checkbox id=m-zh-twblog20240628dos-e998b2e7af84-check>
<label for=m-zh-twblog20240628dos-e998b2e7af84-check><a href=/zh-tw/blog/2024/06/28/dos-%E9%98%B2%E7%AF%84/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240628dos-e998b2e7af84><span>DoS 防範</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240618ingress-nginxe88887nginx-ingresse4b88de698afe4b880e5808be69db1e8a5bf-li><input type=checkbox id=m-zh-twblog20240618ingress-nginxe88887nginx-ingresse4b88de698afe4b880e5808be69db1e8a5bf-check>
<label for=m-zh-twblog20240618ingress-nginxe88887nginx-ingresse4b88de698afe4b880e5808be69db1e8a5bf-check><a href=/zh-tw/blog/2024/06/18/ingress-nginx%E8%88%87nginx-ingress%E4%B8%8D%E6%98%AF%E4%B8%80%E5%80%8B%E6%9D%B1%E8%A5%BF/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240618ingress-nginxe88887nginx-ingresse4b88de698afe4b880e5808be69db1e8a5bf><span>ingress-nginx與nginx ingress不是一個東西</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240614e887aae5bbbak8se99b86e7bea4e4bdbfe794a8e998bfe9878ce99bb2e58886e4bd88e5ad98e584b2-li><input type=checkbox id=m-zh-twblog20240614e887aae5bbbak8se99b86e7bea4e4bdbfe794a8e998bfe9878ce99bb2e58886e4bd88e5ad98e584b2-check>
<label for=m-zh-twblog20240614e887aae5bbbak8se99b86e7bea4e4bdbfe794a8e998bfe9878ce99bb2e58886e4bd88e5ad98e584b2-check><a href=/zh-tw/blog/2024/06/14/%E8%87%AA%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E9%9B%B2%E5%88%86%E4%BD%88%E5%AD%98%E5%84%B2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240614e887aae5bbbak8se99b86e7bea4e4bdbfe794a8e998bfe9878ce99bb2e58886e4bd88e5ad98e584b2><span>自建K8S集群使用阿里雲分佈存儲</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240612e588a9e794a8dnse69c8de58b99e5b9b3e6bb91e58887e68f9be7b6b2e8b7afe69c8de58b99-li><input type=checkbox id=m-zh-twblog20240612e588a9e794a8dnse69c8de58b99e5b9b3e6bb91e58887e68f9be7b6b2e8b7afe69c8de58b99-check>
<label for=m-zh-twblog20240612e588a9e794a8dnse69c8de58b99e5b9b3e6bb91e58887e68f9be7b6b2e8b7afe69c8de58b99-check><a href=/zh-tw/blog/2024/06/12/%E5%88%A9%E7%94%A8dns%E6%9C%8D%E5%8B%99%E5%B9%B3%E6%BB%91%E5%88%87%E6%8F%9B%E7%B6%B2%E8%B7%AF%E6%9C%8D%E5%8B%99/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240612e588a9e794a8dnse69c8de58b99e5b9b3e6bb91e58887e68f9be7b6b2e8b7afe69c8de58b99><span>利用DNS服務平滑切換網路服務</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240605e58db7e79a84e58886e9a19ee5928ce696b9e6b395e8ab96-li><input type=checkbox id=m-zh-twblog20240605e58db7e79a84e58886e9a19ee5928ce696b9e6b395e8ab96-check>
<label for=m-zh-twblog20240605e58db7e79a84e58886e9a19ee5928ce696b9e6b395e8ab96-check><a href=/zh-tw/blog/2024/06/05/%E5%8D%B7%E7%9A%84%E5%88%86%E9%A1%9E%E5%92%8C%E6%96%B9%E6%B3%95%E8%AB%96/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240605e58db7e79a84e58886e9a19ee5928ce696b9e6b395e8ab96><span>卷的分類和方法論</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20230627okre79a84e999b7e998b1e88887e58aa9e58a9b-li><input type=checkbox id=m-zh-twblog20230627okre79a84e999b7e998b1e88887e58aa9e58a9b-check>
<label for=m-zh-twblog20230627okre79a84e999b7e998b1e88887e58aa9e58a9b-check><a href=/zh-tw/blog/2023/06/27/okr%E7%9A%84%E9%99%B7%E9%98%B1%E8%88%87%E5%8A%A9%E5%8A%9B/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20230627okre79a84e999b7e998b1e88887e58aa9e58a9b><span>OKR的陷阱與助力</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20230506windowse6a98be68ea5e69982e79a84ipv6e5958fe9a18c-li><input type=checkbox id=m-zh-twblog20230506windowse6a98be68ea5e69982e79a84ipv6e5958fe9a18c-check>
<label for=m-zh-twblog20230506windowse6a98be68ea5e69982e79a84ipv6e5958fe9a18c-check><a href=/zh-tw/blog/2023/05/06/windows%E6%A9%8B%E6%8E%A5%E6%99%82%E7%9A%84ipv6%E5%95%8F%E9%A1%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20230506windowse6a98be68ea5e69982e79a84ipv6e5958fe9a18c><span>Windows橋接時的IPv6問題</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20221113vs-remote-debug-li><input type=checkbox id=m-zh-twblog20221113vs-remote-debug-check>
<label for=m-zh-twblog20221113vs-remote-debug-check><a href=/zh-tw/blog/2022/11/13/vs-remote-debug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20221113vs-remote-debug><span>vs-remote-debug</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-li><input type=checkbox id=m-zh-twblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-check>
<label for=m-zh-twblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb-check><a href=/zh-tw/blog/2019/01/05/%E6%B0%B8%E8%BF%9C%E5%8B%87%E6%95%A2%E9%9D%A2%E5%AF%B9%E7%94%9F%E6%B4%BB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20190105e6b0b8e8bf9ce58b87e695a2e99da2e5afb9e7949fe6b4bb><span>永遠勇敢面對生活</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20181205e88081e4b89ce5aeb6e79a84e7a68fe588a9e8aea9e4babae6849fe58aa8-li><input type=checkbox id=m-zh-twblog20181205e88081e4b89ce5aeb6e79a84e7a68fe588a9e8aea9e4babae6849fe58aa8-check>
<label for=m-zh-twblog20181205e88081e4b89ce5aeb6e79a84e7a68fe588a9e8aea9e4babae6849fe58aa8-check><a href=/zh-tw/blog/2018/12/05/%E8%80%81%E4%B8%9C%E5%AE%B6%E7%9A%84%E7%A6%8F%E5%88%A9%E8%AE%A9%E4%BA%BA%E6%84%9F%E5%8A%A8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20181205e88081e4b89ce5aeb6e79a84e7a68fe588a9e8aea9e4babae6849fe58aa8><span>老東家的福利讓人感動</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20181201e58d8ee4b8bae5a4aae69c89e992b1e4ba86-li><input type=checkbox id=m-zh-twblog20181201e58d8ee4b8bae5a4aae69c89e992b1e4ba86-check>
<label for=m-zh-twblog20181201e58d8ee4b8bae5a4aae69c89e992b1e4ba86-check><a href=/zh-tw/blog/2018/12/01/%E5%8D%8E%E4%B8%BA%E5%A4%AA%E6%9C%89%E9%92%B1%E4%BA%86/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20181201e58d8ee4b8bae5a4aae69c89e992b1e4ba86><span>華為太有錢了</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180618e69caae69da5e7ae80e58fb2e7bab8e4b88ae79a84e7949fe6b4bb-li><input type=checkbox id=m-zh-twblog20180618e69caae69da5e7ae80e58fb2e7bab8e4b88ae79a84e7949fe6b4bb-check>
<label for=m-zh-twblog20180618e69caae69da5e7ae80e58fb2e7bab8e4b88ae79a84e7949fe6b4bb-check><a href=/zh-tw/blog/2018/06/18/%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E7%BA%B8%E4%B8%8A%E7%9A%84%E7%94%9F%E6%B4%BB/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180618e69caae69da5e7ae80e58fb2e7bab8e4b88ae79a84e7949fe6b4bb><span>未來簡史·紙上的生活</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180618e4b88de585ace5b9b3e58886e9858de6848fe4b989e4b98be7bd91-li><input type=checkbox id=m-zh-twblog20180618e4b88de585ace5b9b3e58886e9858de6848fe4b989e4b98be7bd91-check>
<label for=m-zh-twblog20180618e4b88de585ace5b9b3e58886e9858de6848fe4b989e4b98be7bd91-check><a href=/zh-tw/blog/2018/06/18/%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E9%85%8D%E6%84%8F%E4%B9%89%E4%B9%8B%E7%BD%91/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180618e4b88de585ace5b9b3e58886e9858de6848fe4b989e4b98be7bd91><span>不公平分配&意義之網</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180615e69c80e5be8ce9809ae78992e58d9ae5bc88-li><input type=checkbox id=m-zh-twblog20180615e69c80e5be8ce9809ae78992e58d9ae5bc88-check>
<label for=m-zh-twblog20180615e69c80e5be8ce9809ae78992e58d9ae5bc88-check><a href=/zh-tw/blog/2018/06/15/%E6%9C%80%E5%BE%8C%E9%80%9A%E7%89%92%E5%8D%9A%E5%BC%88/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180615e69c80e5be8ce9809ae78992e58d9ae5bc88><span>博弈論-最後通牒博弈</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180614e69caae4be86e7b0a1e58fb2e799bce5b195e69c83e5819ce6ada2e5978e-li><input type=checkbox id=m-zh-twblog20180614e69caae4be86e7b0a1e58fb2e799bce5b195e69c83e5819ce6ada2e5978e-check>
<label for=m-zh-twblog20180614e69caae4be86e7b0a1e58fb2e799bce5b195e69c83e5819ce6ada2e5978e-check><a href=/zh-tw/blog/2018/06/14/%E6%9C%AA%E4%BE%86%E7%B0%A1%E5%8F%B2%E7%99%BC%E5%B1%95%E6%9C%83%E5%81%9C%E6%AD%A2%E5%97%8E/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180614e69caae4be86e7b0a1e58fb2e799bce5b195e69c83e5819ce6ada2e5978e><span>未來簡史·發展會停止嗎</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180527windows-to-go-e4bc98e7bcbae782b9-li><input type=checkbox id=m-zh-twblog20180527windows-to-go-e4bc98e7bcbae782b9-check>
<label for=m-zh-twblog20180527windows-to-go-e4bc98e7bcbae782b9-check><a href=/zh-tw/blog/2018/05/27/windows-to-go-%E4%BC%98%E7%BC%BA%E7%82%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180527windows-to-go-e4bc98e7bcbae782b9><span>Windows To Go 優缺點</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180522e8afbbe69caae69da5e7ae80e58fb2-li><input type=checkbox id=m-zh-twblog20180522e8afbbe69caae69da5e7ae80e58fb2-check>
<label for=m-zh-twblog20180522e8afbbe69caae69da5e7ae80e58fb2-check><a href=/zh-tw/blog/2018/05/22/%E8%AF%BB%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180522e8afbbe69caae69da5e7ae80e58fb2><span>读《未来简史》</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180522e68abde8b1a1e4b88ee585b7e4bd93-li><input type=checkbox id=m-zh-twblog20180522e68abde8b1a1e4b88ee585b7e4bd93-check>
<label for=m-zh-twblog20180522e68abde8b1a1e4b88ee585b7e4bd93-check><a href=/zh-tw/blog/2018/05/22/%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%85%B7%E4%BD%93/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180522e68abde8b1a1e4b88ee585b7e4bd93><span>抽象與具體</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20180508uwpuniversal-windows-platforme4bb8be7bb8d-e5bfabe9809fe4b88ae6898b-2-li><input type=checkbox id=m-zh-twblog20180508uwpuniversal-windows-platforme4bb8be7bb8d-e5bfabe9809fe4b88ae6898b-2-check>
<label for=m-zh-twblog20180508uwpuniversal-windows-platforme4bb8be7bb8d-e5bfabe9809fe4b88ae6898b-2-check><a href=/zh-tw/blog/2018/05/08/uwpuniversal-windows-platform%E4%BB%8B%E7%BB%8D-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20180508uwpuniversal-windows-platforme4bb8be7bb8d-e5bfabe9809fe4b88ae6898b-2><span>UWP(Universal Windows Platform)介紹 — 快速上手</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20171219change-from-learning-to-earning-li><input type=checkbox id=m-zh-twblog20171219change-from-learning-to-earning-check>
<label for=m-zh-twblog20171219change-from-learning-to-earning-check><a href=/zh-tw/blog/2017/12/19/change-from-learning-to-earning/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20171219change-from-learning-to-earning><span>從學習到賺錢</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251013dns-impact-on-browsing-li><input type=checkbox id=m-zh-twblog20251013dns-impact-on-browsing-check>
<label for=m-zh-twblog20251013dns-impact-on-browsing-check><a href=/zh-tw/blog/2025/10/13/dns-impact-on-browsing/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251013dns-impact-on-browsing><span>DNS 會如何影響你的上網體驗</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20251011e9968be6ba90e58d9ae5aea2e79a84e6bd9be59ca8e5ae89e585a8e99ab1e682a3e5a682e4bd95e4bf9de8adb7e5808be4babae8b387e8a88ae4b88de8a2abe6b4a9e99cb2-li><input type=checkbox id=m-zh-twblog20251011e9968be6ba90e58d9ae5aea2e79a84e6bd9be59ca8e5ae89e585a8e99ab1e682a3e5a682e4bd95e4bf9de8adb7e5808be4babae8b387e8a88ae4b88de8a2abe6b4a9e99cb2-check>
<label for=m-zh-twblog20251011e9968be6ba90e58d9ae5aea2e79a84e6bd9be59ca8e5ae89e585a8e99ab1e682a3e5a682e4bd95e4bf9de8adb7e5808be4babae8b387e8a88ae4b88de8a2abe6b4a9e99cb2-check><a href=/zh-tw/blog/2025/10/11/%E9%96%8B%E6%BA%90%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%BD%9B%E5%9C%A8%E5%AE%89%E5%85%A8%E9%9A%B1%E6%82%A3%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AD%B7%E5%80%8B%E4%BA%BA%E8%B3%87%E8%A8%8A%E4%B8%8D%E8%A2%AB%E6%B4%A9%E9%9C%B2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20251011e9968be6ba90e58d9ae5aea2e79a84e6bd9be59ca8e5ae89e585a8e99ab1e682a3e5a682e4bd95e4bf9de8adb7e5808be4babae8b387e8a88ae4b88de8a2abe6b4a9e99cb2><span>開源博客的潛在安全隱患：如何保護個人資訊不被洩露</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250820e5858de8b2bbe58f96e5be97e998bfe9878ce99bb2e9828ae7b7a3e5ae89e585a8e58aa0e9809fesae69c8de58b99-li><input type=checkbox id=m-zh-twblog20250820e5858de8b2bbe58f96e5be97e998bfe9878ce99bb2e9828ae7b7a3e5ae89e585a8e58aa0e9809fesae69c8de58b99-check>
<label for=m-zh-twblog20250820e5858de8b2bbe58f96e5be97e998bfe9878ce99bb2e9828ae7b7a3e5ae89e585a8e58aa0e9809fesae69c8de58b99-check><a href=/zh-tw/blog/2025/08/20/%E5%85%8D%E8%B2%BB%E5%8F%96%E5%BE%97%E9%98%BF%E9%87%8C%E9%9B%B2%E9%82%8A%E7%B7%A3%E5%AE%89%E5%85%A8%E5%8A%A0%E9%80%9Fesa%E6%9C%8D%E5%8B%99/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250820e5858de8b2bbe58f96e5be97e998bfe9878ce99bb2e9828ae7b7a3e5ae89e585a8e58aa0e9809fesae69c8de58b99><span>免費取得阿里雲邊緣安全加速（ESA）服務</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20250117e5808be4babae7b6b2e59f9fe79a84e5ae89e585a8e5afa6e8b890-li><input type=checkbox id=m-zh-twblog20250117e5808be4babae7b6b2e59f9fe79a84e5ae89e585a8e5afa6e8b890-check>
<label for=m-zh-twblog20250117e5808be4babae7b6b2e59f9fe79a84e5ae89e585a8e5afa6e8b890-check><a href=/zh-tw/blog/2025/01/17/%E5%80%8B%E4%BA%BA%E7%B6%B2%E5%9F%9F%E7%9A%84%E5%AE%89%E5%85%A8%E5%AF%A6%E8%B8%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20250117e5808be4babae7b6b2e59f9fe79a84e5ae89e585a8e5afa6e8b890><span>個人網域的安全實踐</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240603e5afb6e5a194dockere6ba90e58aa0e9809f-li><input type=checkbox id=m-zh-twblog20240603e5afb6e5a194dockere6ba90e58aa0e9809f-check>
<label for=m-zh-twblog20240603e5afb6e5a194dockere6ba90e58aa0e9809f-check><a href=/zh-tw/blog/2024/06/03/%E5%AF%B6%E5%A1%94docker%E6%BA%90%E5%8A%A0%E9%80%9F/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240603e5afb6e5a194dockere6ba90e58aa0e9809f><span>寶塔docker源加速</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240528linuxe7b6b2e8b7afe5958fe9a18ce5ae9ae4bd8d-li><input type=checkbox id=m-zh-twblog20240528linuxe7b6b2e8b7afe5958fe9a18ce5ae9ae4bd8d-check>
<label for=m-zh-twblog20240528linuxe7b6b2e8b7afe5958fe9a18ce5ae9ae4bd8d-check><a href=/zh-tw/blog/2024/05/28/linux%E7%B6%B2%E8%B7%AF%E5%95%8F%E9%A1%8C%E5%AE%9A%E4%BD%8D/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240528linuxe7b6b2e8b7afe5958fe9a18ce5ae9ae4bd8d><span>linux網路問題定位</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240527windowse7b3bbe7b5b1e5ae89e8a39de5928ce5959fe794a8-massgravedev-e8a9b3e7b4b0e4bb8be7b4b9-li><input type=checkbox id=m-zh-twblog20240527windowse7b3bbe7b5b1e5ae89e8a39de5928ce5959fe794a8-massgravedev-e8a9b3e7b4b0e4bb8be7b4b9-check>
<label for=m-zh-twblog20240527windowse7b3bbe7b5b1e5ae89e8a39de5928ce5959fe794a8-massgravedev-e8a9b3e7b4b0e4bb8be7b4b9-check><a href=/zh-tw/blog/2024/05/27/windows%E7%B3%BB%E7%B5%B1%E5%AE%89%E8%A3%9D%E5%92%8C%E5%95%9F%E7%94%A8-massgrave.dev-%E8%A9%B3%E7%B4%B0%E4%BB%8B%E7%B4%B9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240527windowse7b3bbe7b5b1e5ae89e8a39de5928ce5959fe794a8-massgravedev-e8a9b3e7b4b0e4bb8be7b4b9><span>Windows系統安裝和啟用 - massgrave.dev 詳細介紹</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240527k8se58fa2e99b86e4b8ade5a682e4bd95e4bf9de79599e8b2a0e8bc89e59d87e8a1a1e5be8ce79a84e8ab8be6b182e6ba90ip-li><input type=checkbox id=m-zh-twblog20240527k8se58fa2e99b86e4b8ade5a682e4bd95e4bf9de79599e8b2a0e8bc89e59d87e8a1a1e5be8ce79a84e8ab8be6b182e6ba90ip-check>
<label for=m-zh-twblog20240527k8se58fa2e99b86e4b8ade5a682e4bd95e4bf9de79599e8b2a0e8bc89e59d87e8a1a1e5be8ce79a84e8ab8be6b182e6ba90ip-check><a href=/zh-tw/blog/2024/05/27/k8s%E5%8F%A2%E9%9B%86%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E7%95%99%E8%B2%A0%E8%BC%89%E5%9D%87%E8%A1%A1%E5%BE%8C%E7%9A%84%E8%AB%8B%E6%B1%82%E6%BA%90ip/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240527k8se58fa2e99b86e4b8ade5a682e4bd95e4bf9de79599e8b2a0e8bc89e59d87e8a1a1e5be8ce79a84e8ab8be6b182e6ba90ip><span>K8s叢集中如何保留負載均衡後的請求源IP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240521wireguarde5b08de68a97e9818be7879fe59586udp-qose79a84e5ae8ce695b4e8a7a3e6b1bae696b9e6a188-li><input type=checkbox id=m-zh-twblog20240521wireguarde5b08de68a97e9818be7879fe59586udp-qose79a84e5ae8ce695b4e8a7a3e6b1bae696b9e6a188-check>
<label for=m-zh-twblog20240521wireguarde5b08de68a97e9818be7879fe59586udp-qose79a84e5ae8ce695b4e8a7a3e6b1bae696b9e6a188-check><a href=/zh-tw/blog/2024/05/21/wireguard%E5%B0%8D%E6%8A%97%E9%81%8B%E7%87%9F%E5%95%86udp-qos%E7%9A%84%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240521wireguarde5b08de68a97e9818be7879fe59586udp-qose79a84e5ae8ce695b4e8a7a3e6b1bae696b9e6a188><span>WireGuard對抗運營商UDP QoS的完整解決方案</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240520e5b091e695b8e6b4bee696b0e4babae5a0b1e5b08e-li><input type=checkbox id=m-zh-twblog20240520e5b091e695b8e6b4bee696b0e4babae5a0b1e5b08e-check>
<label for=m-zh-twblog20240520e5b091e695b8e6b4bee696b0e4babae5a0b1e5b08e-check><a href=/zh-tw/blog/2024/05/20/%E5%B0%91%E6%95%B8%E6%B4%BE%E6%96%B0%E4%BA%BA%E5%A0%B1%E5%B0%8E/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240520e5b091e695b8e6b4bee696b0e4babae5a0b1e5b08e><span>少數派新人報導</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240518e6ada6e6bca2e5b08fe9be8de89da6e5b882e5a0b4e68f90e4be9be58aa0e5b7a5e69c8de58b99e4ba86-li><input type=checkbox id=m-zh-twblog20240518e6ada6e6bca2e5b08fe9be8de89da6e5b882e5a0b4e68f90e4be9be58aa0e5b7a5e69c8de58b99e4ba86-check>
<label for=m-zh-twblog20240518e6ada6e6bca2e5b08fe9be8de89da6e5b882e5a0b4e68f90e4be9be58aa0e5b7a5e69c8de58b99e4ba86-check><a href=/zh-tw/blog/2024/05/18/%E6%AD%A6%E6%BC%A2%E5%B0%8F%E9%BE%8D%E8%9D%A6%E5%B8%82%E5%A0%B4%E6%8F%90%E4%BE%9B%E5%8A%A0%E5%B7%A5%E6%9C%8D%E5%8B%99%E4%BA%86/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240518e6ada6e6bca2e5b08fe9be8de89da6e5b882e5a0b4e68f90e4be9be58aa0e5b7a5e69c8de58b99e4ba86><span>武漢小龍蝦市場提供加工服務了</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240518e5a682e4bd95e68f90e58d87e887aae5bbbadnse69c8de58b99e4b88be79a84e7b6b2e8b7afe9ab94e9a997-li><input type=checkbox id=m-zh-twblog20240518e5a682e4bd95e68f90e58d87e887aae5bbbadnse69c8de58b99e4b88be79a84e7b6b2e8b7afe9ab94e9a997-check>
<label for=m-zh-twblog20240518e5a682e4bd95e68f90e58d87e887aae5bbbadnse69c8de58b99e4b88be79a84e7b6b2e8b7afe9ab94e9a997-check><a href=/zh-tw/blog/2024/05/18/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E8%87%AA%E5%BB%BAdns%E6%9C%8D%E5%8B%99%E4%B8%8B%E7%9A%84%E7%B6%B2%E8%B7%AF%E9%AB%94%E9%A9%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240518e5a682e4bd95e68f90e58d87e887aae5bbbadnse69c8de58b99e4b88be79a84e7b6b2e8b7afe9ab94e9a997><span>如何提升自建DNS服務下的網路體驗</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240516e8a8ade8a888e6a8a1e5bc8fe7a9b6e7ab9fe69c89e5b9bee5808be58e9fe58987-li><input type=checkbox id=m-zh-twblog20240516e8a8ade8a888e6a8a1e5bc8fe7a9b6e7ab9fe69c89e5b9bee5808be58e9fe58987-check>
<label for=m-zh-twblog20240516e8a8ade8a888e6a8a1e5bc8fe7a9b6e7ab9fe69c89e5b9bee5808be58e9fe58987-check><a href=/zh-tw/blog/2024/05/16/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%B9%BE%E5%80%8B%E5%8E%9F%E5%89%87/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240516e8a8ade8a888e6a8a1e5bc8fe7a9b6e7ab9fe69c89e5b9bee5808be58e9fe58987><span>設計模式究竟有幾個原則</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240509e5a49ae5b9b3e58fb0e585a7e5aeb9e799bce5b883e5b7a5e585b7--e89fbbe5b08fe4ba8ce9ab94e9a997-li><input type=checkbox id=m-zh-twblog20240509e5a49ae5b9b3e58fb0e585a7e5aeb9e799bce5b883e5b7a5e585b7--e89fbbe5b08fe4ba8ce9ab94e9a997-check>
<label for=m-zh-twblog20240509e5a49ae5b9b3e58fb0e585a7e5aeb9e799bce5b883e5b7a5e585b7--e89fbbe5b08fe4ba8ce9ab94e9a997-check><a href=/zh-tw/blog/2024/05/09/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%85%A7%E5%AE%B9%E7%99%BC%E5%B8%83%E5%B7%A5%E5%85%B7--%E8%9F%BB%E5%B0%8F%E4%BA%8C%E9%AB%94%E9%A9%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240509e5a49ae5b9b3e58fb0e585a7e5aeb9e799bce5b883e5b7a5e585b7--e89fbbe5b08fe4ba8ce9ab94e9a997><span>多平台內容發布工具--蟻小二體驗</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240509e5808be4babae58c96e68ea8e896a6e698afe4bebfe588a9e7a59ee599a8e98284e698afe8aa8de79fa5e999b7e998b1-li><input type=checkbox id=m-zh-twblog20240509e5808be4babae58c96e68ea8e896a6e698afe4bebfe588a9e7a59ee599a8e98284e698afe8aa8de79fa5e999b7e998b1-check>
<label for=m-zh-twblog20240509e5808be4babae58c96e68ea8e896a6e698afe4bebfe588a9e7a59ee599a8e98284e698afe8aa8de79fa5e999b7e998b1-check><a href=/zh-tw/blog/2024/05/09/%E5%80%8B%E4%BA%BA%E5%8C%96%E6%8E%A8%E8%96%A6%E6%98%AF%E4%BE%BF%E5%88%A9%E7%A5%9E%E5%99%A8%E9%82%84%E6%98%AF%E8%AA%8D%E7%9F%A5%E9%99%B7%E9%98%B1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240509e5808be4babae58c96e68ea8e896a6e698afe4bebfe588a9e7a59ee599a8e98284e698afe8aa8de79fa5e999b7e998b1><span>個人化推薦：是便利神器還是認知陷阱？</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240509e9a8b0e8a88ae99bb2e9968be799bce88085e7a4bee7bea4e589b5e4bd9ce9ab94e9a997-li><input type=checkbox id=m-zh-twblog20240509e9a8b0e8a88ae99bb2e9968be799bce88085e7a4bee7bea4e589b5e4bd9ce9ab94e9a997-check>
<label for=m-zh-twblog20240509e9a8b0e8a88ae99bb2e9968be799bce88085e7a4bee7bea4e589b5e4bd9ce9ab94e9a997-check><a href=/zh-tw/blog/2024/05/09/%E9%A8%B0%E8%A8%8A%E9%9B%B2%E9%96%8B%E7%99%BC%E8%80%85%E7%A4%BE%E7%BE%A4%E5%89%B5%E4%BD%9C%E9%AB%94%E9%A9%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240509e9a8b0e8a88ae99bb2e9968be799bce88085e7a4bee7bea4e589b5e4bd9ce9ab94e9a997><span>騰訊雲開發者社群創作體驗</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240509e7b0a1e69bb8e79a84e589b5e4bd9ce9ab94e9a997-li><input type=checkbox id=m-zh-twblog20240509e7b0a1e69bb8e79a84e589b5e4bd9ce9ab94e9a997-check>
<label for=m-zh-twblog20240509e7b0a1e69bb8e79a84e589b5e4bd9ce9ab94e9a997-check><a href=/zh-tw/blog/2024/05/09/%E7%B0%A1%E6%9B%B8%E7%9A%84%E5%89%B5%E4%BD%9C%E9%AB%94%E9%A9%97/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240509e7b0a1e69bb8e79a84e589b5e4bd9ce9ab94e9a997><span>簡書的創作體驗</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240509chatgpt-vpn-e8ad98e588a5e7b99ee9818ee696b9e6b395-li><input type=checkbox id=m-zh-twblog20240509chatgpt-vpn-e8ad98e588a5e7b99ee9818ee696b9e6b395-check>
<label for=m-zh-twblog20240509chatgpt-vpn-e8ad98e588a5e7b99ee9818ee696b9e6b395-check><a href=/zh-tw/blog/2024/05/09/chatgpt-vpn-%E8%AD%98%E5%88%A5%E7%B9%9E%E9%81%8E%E6%96%B9%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240509chatgpt-vpn-e8ad98e588a5e7b99ee9818ee696b9e6b395><span>ChatGPT VPN 識別繞過方法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog20240507windows-edgee7808fe8a6bde599a8e58da1e9a093e79a84e4b880e7a8aee8a7a3e6b1bae8bea6e6b395-li><input type=checkbox id=m-zh-twblog20240507windows-edgee7808fe8a6bde599a8e58da1e9a093e79a84e4b880e7a8aee8a7a3e6b1bae8bea6e6b395-check>
<label for=m-zh-twblog20240507windows-edgee7808fe8a6bde599a8e58da1e9a093e79a84e4b880e7a8aee8a7a3e6b1bae8bea6e6b395-check><a href=/zh-tw/blog/2024/05/07/windows-edge%E7%80%8F%E8%A6%BD%E5%99%A8%E5%8D%A1%E9%A0%93%E7%9A%84%E4%B8%80%E7%A8%AE%E8%A7%A3%E6%B1%BA%E8%BE%A6%E6%B3%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog20240507windows-edgee7808fe8a6bde599a8e58da1e9a093e79a84e4b880e7a8aee8a7a3e6b1bae8bea6e6b395><span>Windows Edge瀏覽器卡頓的一種解決辦法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog10101-li><input type=checkbox id=m-zh-twblog10101-check>
<label for=m-zh-twblog10101-check><a href=/zh-tw/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog10101><span></span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog10101-li><input type=checkbox id=m-zh-twblog10101-check>
<label for=m-zh-twblog10101-check><a href=/zh-tw/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog10101><span></span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog10101-li><input type=checkbox id=m-zh-twblog10101-check>
<label for=m-zh-twblog10101-check><a href=/zh-tw/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog10101><span></span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog10101-li><input type=checkbox id=m-zh-twblog10101-check>
<label for=m-zh-twblog10101-check><a href=/zh-tw/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog10101><span></span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-twblog10101-li><input type=checkbox id=m-zh-twblog10101-check>
<label for=m-zh-twblog10101-check><a href=/zh-tw/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-zh-twblog10101><span></span></a></label></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"></div><div class=td-toc data-proofer-ignore><div class=td-toc-title><span class=td-toc-title__text></span>
<a class=td-toc-title__link title href=#></a></div><nav id=TableOfContents><ul><li><a href=#目的>目的</a></li><li><a href=#总体原则>总体原则</a></li><li><a href=#重点关注>重点关注</a></li><li><a href=#约定>约定</a></li><li><a href=#例外>例外</a></li></ul><ul><li><a href=#通用命名>通用命名</a></li><li><a href=#文件命名>文件命名</a><ul><li><a href=#规则221-c文件以cpp结尾头文件以h结尾>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</a></li><li><a href=#规则222-c文件名和类名保持一致>规则2.2.2 C++文件名和类名保持一致</a></li></ul></li><li><a href=#函数命名>函数命名</a></li><li><a href=#类型命名>类型命名</a><ul><li><a href=#建议241-避免滥用-typedef或者define-对基本类型起别名>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</a></li></ul></li><li><a href=#变量命名>变量命名</a><ul><li><a href=#规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀>规则2.5.1 全局变量应增加 ‘g_’ 前缀，静态变量命名不需要加特殊前缀</a></li><li><a href=#规则252-类的成员变量命名以小驼峰加后下划线组成>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</a></li></ul></li><li><a href=#宏常量枚举命名>宏、常量、枚举命名</a></li></ul><ul><li><a href=#行宽>行宽</a><ul><li><a href=#规则311-行宽不超过-120-个字符>规则3.1.1 行宽不超过 120 个字符</a></li></ul></li><li><a href=#缩进>缩进</a><ul><li><a href=#规则321-使用空格进行缩进每次缩进4个空格>规则3.2.1 使用空格进行缩进，每次缩进4个空格</a></li></ul></li><li><a href=#大括号>大括号</a><ul><li><a href=#规则331-使用-kr-缩进风格>规则3.3.1 使用 K&amp;R 缩进风格</a></li></ul></li><li><a href=#函数声明和定义>函数声明和定义</a><ul><li><a href=#规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</a></li></ul></li><li><a href=#函数调用>函数调用</a><ul><li><a href=#规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</a></li></ul></li><li><a href=#if语句>if语句</a><ul><li><a href=#规则361-if语句必须要使用大括号>规则3.6.1 if语句必须要使用大括号</a></li><li><a href=#规则362-禁止-ifelseelse-if-写在同一行>规则3.6.2 禁止 if/else/else if 写在同一行</a></li></ul></li><li><a href=#循环语句>循环语句</a><ul><li><a href=#规则371-循环语句必须使用大括号>规则3.7.1 循环语句必须使用大括号</a></li></ul></li><li><a href=#switch语句>switch语句</a><ul><li><a href=#规则381-switch-语句的-casedefault-要缩进一层>规则3.8.1 switch 语句的 case/default 要缩进一层</a></li></ul></li><li><a href=#表达式>表达式</a><ul><li><a href=#建议391-表达式换行要保持换行的一致性运算符放行末>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</a></li></ul></li><li><a href=#变量赋值>变量赋值</a><ul><li><a href=#规则3101-多个变量定义和赋值语句不允许写在一行>规则3.10.1 多个变量定义和赋值语句不允许写在一行</a></li></ul></li><li><a href=#初始化>初始化</a><ul><li><a href=#规则3111-初始化换行时要有缩进并进行合理对齐>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</a></li></ul></li><li><a href=#指针与引用>指针与引用</a><ul><li><a href=#建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.1 指针类型"<code>*</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li><li><a href=#建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.2 引用类型"<code>&</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li></ul></li><li><a href=#编译预处理>编译预处理</a><ul><li><a href=#规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进>规则3.13.1 编译预处理的”#“统一放在行首，嵌套编译预处理语句时，”#“可以进行缩进</a></li><li><a href=#规则3132-避免使用宏>规则3.13.2 避免使用宏</a></li><li><a href=#规则3133-禁止使用宏来表示常量>规则3.13.3 禁止使用宏来表示常量</a></li><li><a href=#规则3134-禁止使用函数式宏>规则3.13.4 禁止使用函数式宏</a></li></ul></li><li><a href=#空格和空行>空格和空行</a><ul><li><a href=#规则3141-水平空格应该突出关键字和重要信息避免不必要的留白>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</a></li><li><a href=#建议3141-合理安排空行保持代码紧凑>建议3.14.1 合理安排空行，保持代码紧凑</a></li></ul></li><li><a href=#类>类</a><ul><li><a href=#规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</a></li><li><a href=#规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</a></li></ul></li></ul><ul><li><a href=#注释风格>注释风格</a></li><li><a href=#文件头注释>文件头注释</a><ul><li><a href=#规则31-文件头注释必须包含版权许可>规则3.1 文件头注释必须包含版权许可</a></li></ul></li><li><a href=#函数头注释>函数头注释</a><ul><li><a href=#规则431-公有public函数必须编写函数头注释>规则4.3.1 公有（public）函数必须编写函数头注释</a></li><li><a href=#规则432-禁止空有格式的函数头注释>规则4.3.2 禁止空有格式的函数头注释</a></li></ul></li><li><a href=#代码注释>代码注释</a><ul><li><a href=#规则441-代码注释放于对应代码的上方或右边>规则4.4.1 代码注释放于对应代码的上方或右边</a></li><li><a href=#规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</a></li><li><a href=#规则443-不用的代码段直接删除不要注释掉>规则4.4.3 不用的代码段直接删除，不要注释掉</a></li></ul></li></ul><ul><li><a href=#头文件职责>头文件职责</a><ul><li><a href=#建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</a></li></ul></li><li><a href=#头文件依赖>头文件依赖</a><ul><li><a href=#规则521-禁止头文件循环依赖>规则5.2.1 禁止头文件循环依赖</a></li><li><a href=#规则522-头文件必须编写define保护防止重复包含>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</a></li><li><a href=#规则523-禁止通过声明的方式引用外部函数接口变量>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</a></li><li><a href=#规则524-禁止在extern-c中包含头文件>规则5.2.4 禁止在extern “C"中包含头文件</a></li><li><a href=#建议521尽量避免使用前置声明而是通过include来包含头文件>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</a></li></ul></li></ul><ul><li><a href=#命名空间>命名空间</a><ul><li><a href=#建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</a></li><li><a href=#规则611-不要在头文件中或者include之前使用using导入命名空间>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</a></li></ul></li><li><a href=#全局函数和静态成员函数>全局函数和静态成员函数</a><ul><li><a href=#建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</a></li></ul></li><li><a href=#全局常量和静态成员常量>全局常量和静态成员常量</a><ul><li><a href=#建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</a></li></ul></li><li><a href=#全局变量>全局变量</a><ul><li><a href=#建议641-尽量避免使用全局变量考虑使用单例模式>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</a></li></ul></li></ul><ul><li><a href=#构造拷贝构造赋值和析构函数>构造，拷贝构造，赋值和析构函数</a><ul><li><a href=#规则711-类的成员变量必须显式初始化>规则7.1.1 类的成员变量必须显式初始化</a></li><li><a href=#建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</a></li><li><a href=#规则712-为避免隐式转换将单参数构造函数声明为explicit>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</a></li><li><a href=#规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</a></li><li><a href=#规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则715-移动构造和移动赋值操作符应该是成对出现或者禁止>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则716-禁止在构造函数和析构函数中调用虚函数>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</a></li><li><a href=#规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</a></li></ul></li><li><a href=#继承>继承</a><ul><li><a href=#规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</a></li><li><a href=#規則722-禁止虛函數使用缺省參數值>規則7.2.2 禁止虛函數使用缺省參數值</a></li><li><a href=#規則723-禁止重新定義繼承而來的非虛函數>規則7.2.3 禁止重新定義繼承而來的非虛函數</a></li></ul></li><li><a href=#多重繼承>多重繼承</a><ul><li><a href=#建議731-使用多重繼承來實現接口分離與多角色組合>建議7.3.1 使用多重繼承來實現接口分離與多角色組合</a></li></ul></li><li><a href=#重載>重載</a></li></ul><ul><li><a href=#函數設計>函數設計</a><ul><li><a href=#規則811-避免函數過長函數不超過50行非空非注釋>規則8.1.1 避免函數過長，函數不超過50行（非空非注釋）</a></li></ul></li><li><a href=#內聯函數>內聯函數</a><ul><li><a href=#建議821-內聯函數不超過10行非空非注釋>建議8.2.1 內聯函數不超過10行（非空非注釋）</a></li></ul></li><li><a href=#函數參數>函數參數</a><ul><li><a href=#建議831-函數參數使用引用取代指針>建議8.3.1 函數參數使用引用取代指針</a></li><li><a href=#建議832-使用強類型參數避免使用void>建議8.3.2 使用強類型參數，避免使用void*</a></li><li><a href=#建議833-函數的參數個數不超過5個>建議8.3.3 函數的參數個數不超過5個</a></li></ul></li></ul><ul><li><a href=#常量與初始化>常量與初始化</a><ul><li><a href=#規則911-不允許使用宏來表示常量>規則9.1.1 不允許使用宏來表示常量</a></li><li><a href=#建議911-一組相關的整型常量應定義為枚舉>建議9.1.1 一組相關的整型常量應定義為枚舉</a></li><li><a href=#規則912-不允許使用魔鬼數字>規則9.1.2 不允許使用魔鬼數字</a></li><li><a href=#規則913-常量應該保證單一職責>規則9.1.3 常量應該保證單一職責</a></li><li><a href=#規則914-禁止用memcpy_smemset_s初始化非pod對象>規則9.1.4 禁止用memcpy_s、memset_s初始化非POD對象</a></li><li><a href=#建議912-變量使用時才聲明並初始化>建議9.1.2 變量使用時才聲明並初始化</a></li></ul></li><li><a href=#表達式>表達式</a><ul><li><a href=#規則921-含有變量自增或自減運算的表達式中禁止再次引用該變量>規則9.2.1 含有變量自增或自減運算的表達式中禁止再次引用該變量</a></li><li><a href=#規則922-switch語句要有default分支>規則9.2.2 switch語句要有default分支</a></li><li><a href=#建議921-表達式的比較應當遵循左側傾向於變化右側傾向於不變的原則>建議9.2.1 表達式的比較，應當遵循左側傾向於變化、右側傾向於不變的原則</a></li><li><a href=#建議922-使用括號明確操作符的優先級>建議9.2.2 使用括號明確操作符的優先級</a></li></ul></li><li><a href=#類型轉換>類型轉換</a><ul><li><a href=#規則931-如果確定要使用類型轉換請使用由c提供的類型轉換而不是c風格的類型轉換>規則9.3.1 如果確定要使用類型轉換，請使用由C++提供的類型轉換，而不是C風格的類型轉換</a></li><li><a href=#建議931-避免使用dynamic_cast>建議9.3.1 避免使用<code>dynamic_cast</code></a></li><li><a href=#建議932-避免使用reinterpret_cast>建議9.3.2 避免使用<code>reinterpret_cast</code></a></li><li><a href=#建議933-避免使用const_cast>建議9.3.3 避免使用<code>const_cast</code></a></li></ul></li><li><a href=#資源分配和釋放>資源分配和釋放</a><ul><li><a href=#規則941-單個對象釋放使用delete數組對象釋放使用delete->規則9.4.1 單個對象釋放使用delete，數組對象釋放使用delete []</a></li><li><a href=#建議941-使用-raii-特性來幫助追蹤動態分配>建議9.4.1 使用 RAII 特性來幫助追蹤動態分配</a></li></ul></li><li><a href=#標準庫>標準庫</a><ul><li><a href=#規則951-不要保存stdstring的c_str返回的指針>規則9.5.1 不要保存std::string的c_str()返回的指針</a></li><li><a href=#建議951-使用stdstring代替char>建議9.5.1 使用std::string代替char*</a></li><li><a href=#規則952-禁止使用auto_ptr>規則9.5.2 禁止使用auto_ptr</a></li><li><a href=#建議952-使用新的標準頭文件>建議9.5.2 使用新的標準頭文件</a></li></ul></li><li><a href=#const的用法>const的用法</a><ul><li><a href=#規則961-對於指針和引用類型的形參如果是不需要修改的請使用const>規則9.6.1 對於指針和引用類型的形參，如果是不需要修改的，請使用const</a></li><li><a href=#規則962-對於不會修改成員變量的成員函數請使用const修飾>規則9.6.2 對於不會修改成員變量的成員函數請使用const修飾</a></li><li><a href=#建議961-初始化後再也不會修改的成員變量定義為const>建議9.6.1 初始化後再也不會修改的成員變量定義為const</a></li></ul></li><li><a href=#異常>異常</a><ul><li><a href=#建議971-c11中如果函數不會拋出異常聲明為noexcept>建議9.7.1 C++11中，如果函數不會拋出異常，聲明為<code>noexcept</code></a></li></ul></li><li><a href=#模板與泛型編程>模板與泛型編程</a><ul><li><a href=#規則981-禁止在openharmony項目中進行泛型編程>規則9.8.1 禁止在OpenHarmony項目中進行泛型編程</a></li></ul></li><li><a href=#宏>宏</a></li></ul><ul><li><a href=#代碼簡潔性和安全性提升>代碼簡潔性和安全性提升</a><ul><li><a href=#建議1011-合理使用auto>建議10.1.1 合理使用<code>auto</code></a></li><li><a href=#規則1011-在重寫虛函數時請使用override或final關鍵字>規則10.1.1 在重寫虛函數時請使用<code>override</code>或<code>final</code>關鍵字</a></li><li><a href=#規則1012-使用delete關鍵字刪除函數>規則10.1.2 使用<code>delete</code>關鍵字刪除函數</a></li><li><a href=#規則1013-使用nullptr而不是null或0>規則10.1.3 使用<code>nullptr</code>，而不是<code>NULL</code>或<code>0</code></a></li><li><a href=#規則1014-使用using而非typedef>規則10.1.4 使用<code>using</code>而非<code>typedef</code></a></li><li><a href=#規則1015-禁止使用stdmove操作const對象>規則10.1.5 禁止使用std::move操作const對象</a></li></ul></li><li><a href=#智能指針>智能指針</a><ul><li><a href=#規則1021-單例類的成員等所有權不會被多方持有的優先使用原始指針而不是智能指針>規則10.2.1 單例、類的成員等所有權不會被多方持有的優先使用原始指針而不是智能指針</a></li><li><a href=#規則1022-使用stdmake_unique而不是new創建unique_ptr>規則10.2.2 使用<code>std::make_unique</code>而不是<code>new</code>創建<code>unique_ptr</code></a></li><li><a href=#規則1024-使用stdmake_shared而不是new創建shared_ptr>規則10.2.4 使用<code>std::make_shared</code>而不是<code>new</code>創建<code>shared_ptr</code></a></li></ul></li><li><a href=#lambda>Lambda</a><ul><li><a href=#建議1031-當函數不能工作時選擇使用lambda捕獲局部變量或編寫局部函數>建議10.3.1 當函數不能工作時選擇使用<code>lambda</code>(捕獲局部變量，或編寫局部函數)</a></li></ul></li></ul></nav></div><div class="taxonomy taxonomy-terms-cloud taxo-tags"><h5 class=taxonomy-title>Taxonomy Cloud</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/2025/ data-taxonomy-term=2025><span class=taxonomy-label>2025</span><span class=taxonomy-count>10</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/2026/ data-taxonomy-term=2026><span class=taxonomy-label>2026</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/adguard%E7%B3%BB%E5%88%97/ data-taxonomy-term=adguard%E7%B3%BB%E5%88%97><span class=taxonomy-label>Adguard系列</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>14</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/ai%E8%BC%94%E5%8A%A9%E7%B7%A8%E7%A8%8B/ data-taxonomy-term=ai%E8%BC%94%E5%8A%A9%E7%B7%A8%E7%A8%8B><span class=taxonomy-label>AI輔助編程</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/api/ data-taxonomy-term=api><span class=taxonomy-label>API</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/blog/ data-taxonomy-term=blog><span class=taxonomy-label>Blog</span><span class=taxonomy-count>10</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/calico/ data-taxonomy-term=calico><span class=taxonomy-label>Calico</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/cdn/ data-taxonomy-term=cdn><span class=taxonomy-label>CDN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/cdp/ data-taxonomy-term=cdp><span class=taxonomy-label>CDP</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/chrome/ data-taxonomy-term=chrome><span class=taxonomy-label>Chrome</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/claude-code/ data-taxonomy-term=claude-code><span class=taxonomy-label>Claude Code</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/cline/ data-taxonomy-term=cline><span class=taxonomy-label>Cline</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/codex/ data-taxonomy-term=codex><span class=taxonomy-label>Codex</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/copilot%E7%B3%BB%E5%88%97/ data-taxonomy-term=copilot%E7%B3%BB%E5%88%97><span class=taxonomy-label>Copilot系列</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/cursor/ data-taxonomy-term=cursor><span class=taxonomy-label>Cursor</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/deepseek/ data-taxonomy-term=deepseek><span class=taxonomy-label>DeepSeek</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/dns/ data-taxonomy-term=dns><span class=taxonomy-label>DNS</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/docker/ data-taxonomy-term=docker><span class=taxonomy-label>Docker</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/environment/ data-taxonomy-term=environment><span class=taxonomy-label>Environment</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/esa/ data-taxonomy-term=esa><span class=taxonomy-label>ESA</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/gemini/ data-taxonomy-term=gemini><span class=taxonomy-label>Gemini</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/github/ data-taxonomy-term=github><span class=taxonomy-label>GitHub</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/github-pages/ data-taxonomy-term=github-pages><span class=taxonomy-label>GitHub Pages</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/google/ data-taxonomy-term=google><span class=taxonomy-label>Google</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/ipv6/ data-taxonomy-term=ipv6><span class=taxonomy-label>IPv6</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/k8s/ data-taxonomy-term=k8s><span class=taxonomy-label>K8s</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/kubenetes%E7%B3%BB%E5%88%97/ data-taxonomy-term=kubenetes%E7%B3%BB%E5%88%97><span class=taxonomy-label>Kubenetes系列</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/kubenetes%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97/ data-taxonomy-term=kubenetes%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97><span class=taxonomy-label>Kubenetes集群系列</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/linux/ data-taxonomy-term=linux><span class=taxonomy-label>Linux</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/llm/ data-taxonomy-term=llm><span class=taxonomy-label>Llm</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/massgrave/ data-taxonomy-term=massgrave><span class=taxonomy-label>Massgrave</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/moonshot/ data-taxonomy-term=moonshot><span class=taxonomy-label>Moonshot</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/prompt/ data-taxonomy-term=prompt><span class=taxonomy-label>Prompt</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/spec-driven-development/ data-taxonomy-term=spec-driven-development><span class=taxonomy-label>Spec-Driven Development</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/token/ data-taxonomy-term=token><span class=taxonomy-label>Token</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/udp-qos/ data-taxonomy-term=udp-qos><span class=taxonomy-label>UDP QoS</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/vpn/ data-taxonomy-term=vpn><span class=taxonomy-label>VPN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/vs-code%E6%93%B4%E5%85%85/ data-taxonomy-term=vs-code%E6%93%B4%E5%85%85><span class=taxonomy-label>VS Code擴充</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>13</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/win%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/ data-taxonomy-term=win%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87><span class=taxonomy-label>Win疑難雜症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/wireguard/ data-taxonomy-term=wireguard><span class=taxonomy-label>WireGuard</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/wsl/ data-taxonomy-term=wsl><span class=taxonomy-label>Wsl</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/z-ai/ data-taxonomy-term=z-ai><span class=taxonomy-label>Z-AI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7/ data-taxonomy-term=%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7><span class=taxonomy-label>人工智慧</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/ data-taxonomy-term=%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88><span class=taxonomy-label>人工智慧程式設計</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E4%BA%BA%E7%94%9F/ data-taxonomy-term=%E4%BA%BA%E7%94%9F><span class=taxonomy-label>人生</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E4%BD%BF%E7%94%A8%E8%80%85%E7%95%AB%E5%83%8F/ data-taxonomy-term=%E4%BD%BF%E7%94%A8%E8%80%85%E7%95%AB%E5%83%8F><span class=taxonomy-label>使用者畫像</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%85%8D%E8%B2%BB%E8%A9%A6%E7%94%A8/ data-taxonomy-term=%E5%85%8D%E8%B2%BB%E8%A9%A6%E7%94%A8><span class=taxonomy-label>免費試用</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%85%92%E7%AB%A5%E4%BF%9D%E8%AD%B7/ data-taxonomy-term=%E5%85%92%E7%AB%A5%E4%BF%9D%E8%AD%B7><span class=taxonomy-label>兒童保護</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%89%B5%E4%BD%9C%E8%80%85%E5%B9%B3%E5%8F%B0/ data-taxonomy-term=%E5%89%B5%E4%BD%9C%E8%80%85%E5%B9%B3%E5%8F%B0><span class=taxonomy-label>創作者平台</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/ data-taxonomy-term=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86><span class=taxonomy-label>反向代理</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%8F%A2%E9%9B%86/ data-taxonomy-term=%E5%8F%A2%E9%9B%86><span class=taxonomy-label>叢集</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%95%9F%E7%94%A8%E5%B7%A5%E5%85%B7/ data-taxonomy-term=%E5%95%9F%E7%94%A8%E5%B7%A5%E5%85%B7><span class=taxonomy-label>啟用工具</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%9C%96%E7%A4%BA/ data-taxonomy-term=%E5%9C%96%E7%A4%BA><span class=taxonomy-label>圖示</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E5%AE%89%E5%85%A8><span class=taxonomy-label>安全</span><span class=taxonomy-count>12</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%AE%B6%E9%95%B7%E6%8E%A7%E5%88%B6/ data-taxonomy-term=%E5%AE%B6%E9%95%B7%E6%8E%A7%E5%88%B6><span class=taxonomy-label>家長控制</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%AF%B6%E5%A1%94%E7%B3%BB%E5%88%97/ data-taxonomy-term=%E5%AF%B6%E5%A1%94%E7%B3%BB%E5%88%97><span class=taxonomy-label>寶塔系列</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E5%B7%A5%E5%85%B7/ data-taxonomy-term=%E5%B7%A5%E5%85%B7><span class=taxonomy-label>工具</span><span class=taxonomy-count>17</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%88%90%E6%9C%AC/ data-taxonomy-term=%E6%88%90%E6%9C%AC><span class=taxonomy-label>成本</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E6%8A%80%E8%A1%93><span class=taxonomy-label>技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%94%BB%E9%98%B2/ data-taxonomy-term=%E6%94%BB%E9%98%B2><span class=taxonomy-label>攻防</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96/ data-taxonomy-term=%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96><span class=taxonomy-label>效能優化</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%95%99%E5%AD%B8/ data-taxonomy-term=%E6%95%99%E5%AD%B8><span class=taxonomy-label>教學</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>18</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%95%B8%E5%AD%97%E7%B4%A0%E9%A4%8A/ data-taxonomy-term=%E6%95%B8%E5%AD%97%E7%B4%A0%E9%A4%8A><span class=taxonomy-label>數字素養</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%9C%AA%E5%88%86%E9%A1%9E/ data-taxonomy-term=%E6%9C%AA%E5%88%86%E9%A1%9E><span class=taxonomy-label>未分類</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%B3%95%E5%BE%8B/ data-taxonomy-term=%E6%B3%95%E5%BE%8B><span class=taxonomy-label>法律</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7/ data-taxonomy-term=%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7><span class=taxonomy-label>測試工具</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%88%AC%E8%9F%B2/ data-taxonomy-term=%E7%88%AC%E8%9F%B2><span class=taxonomy-label>爬蟲</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/ data-taxonomy-term=%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87><span class=taxonomy-label>疑難雜症</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%A8%8B%E5%BA%8F%E5%93%A1/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%93%A1><span class=taxonomy-label>程序員</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB/ data-taxonomy-term=%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB><span class=taxonomy-label>程式設計師</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9B%E6%87%89%E5%95%86/ data-taxonomy-term=%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9B%E6%87%89%E5%95%86><span class=taxonomy-label>第三方供應商</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B3%BB%E7%B5%B1/ data-taxonomy-term=%E7%B3%BB%E7%B5%B1><span class=taxonomy-label>系統</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E7%B6%AD%E8%AD%B7/ data-taxonomy-term=%E7%B3%BB%E7%B5%B1%E7%B6%AD%E8%AD%B7><span class=taxonomy-label>系統維護</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B4%A2%E5%BC%95/ data-taxonomy-term=%E7%B4%A2%E5%BC%95><span class=taxonomy-label>索引</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E5%9F%9F%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E7%B6%B2%E5%9F%9F%E5%AE%89%E5%85%A8><span class=taxonomy-label>網域安全</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E7%B5%A1%E5%84%AA%E5%8C%96/ data-taxonomy-term=%E7%B6%B2%E7%B5%A1%E5%84%AA%E5%8C%96><span class=taxonomy-label>網絡優化</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E7%B5%A1%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E7%B6%B2%E7%B5%A1%E5%AE%89%E5%85%A8><span class=taxonomy-label>網絡安全</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E8%B7%AF/ data-taxonomy-term=%E7%B6%B2%E8%B7%AF><span class=taxonomy-label>網路</span><span class=taxonomy-count>23</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8><span class=taxonomy-label>網路安全</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93><span class=taxonomy-label>網路技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%A8%AD%E8%A8%88/ data-taxonomy-term=%E8%A8%AD%E8%A8%88><span class=taxonomy-label>設計</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%A9%95%E6%B8%AC/ data-taxonomy-term=%E8%A9%95%E6%B8%AC><span class=taxonomy-label>評測</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%AA%BF%E7%A0%94/ data-taxonomy-term=%E8%AA%BF%E7%A0%94><span class=taxonomy-label>調研</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8><span class=taxonomy-label>資訊安全</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%B5%B0%E8%B5%B0%E5%81%9C%E5%81%9C/ data-taxonomy-term=%E8%B5%B0%E8%B5%B0%E5%81%9C%E5%81%9C><span class=taxonomy-label>走走停停</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E8%B7%9F%E8%91%97%E6%8F%90%E7%A4%BA%E8%A9%9E%E5%AD%B8%E6%9E%B6%E6%A7%8B/ data-taxonomy-term=%E8%B7%9F%E8%91%97%E6%8F%90%E7%A4%BA%E8%A9%9E%E5%AD%B8%E6%9E%B6%E6%A7%8B><span class=taxonomy-label>跟著提示詞學架構</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%80%9A%E8%AD%98/ data-taxonomy-term=%E9%80%9A%E8%AD%98><span class=taxonomy-label>通識</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%81%8B%E7%87%9F%E5%95%86/ data-taxonomy-term=%E9%81%8B%E7%87%9F%E5%95%86><span class=taxonomy-label>運營商</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%81%8B%E7%B6%AD/ data-taxonomy-term=%E9%81%8B%E7%B6%AD><span class=taxonomy-label>運維</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%81%A0%E7%AB%AF%E8%AA%BF%E8%A9%A6/ data-taxonomy-term=%E9%81%A0%E7%AB%AF%E8%AA%BF%E8%A9%A6><span class=taxonomy-label>遠端調試</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%96%8B%E6%BA%90%E5%8D%9A%E5%AE%A2/ data-taxonomy-term=%E9%96%8B%E6%BA%90%E5%8D%9A%E5%AE%A2><span class=taxonomy-label>開源博客</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/ data-taxonomy-term=%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7><span class=taxonomy-label>開發工具</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%98%BF%E9%87%8C%E9%9B%B2/ data-taxonomy-term=%E9%98%BF%E9%87%8C%E9%9B%B2><span class=taxonomy-label>阿里雲</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%98%BF%E9%87%8C%E9%9B%B2%E7%B3%BB%E5%88%97/ data-taxonomy-term=%E9%98%BF%E9%87%8C%E9%9B%B2%E7%B3%BB%E5%88%97><span class=taxonomy-label>阿里雲系列</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%99%A4%E9%8C%AF/ data-taxonomy-term=%E9%99%A4%E9%8C%AF><span class=taxonomy-label>除錯</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9A%A8%E7%AD%86/ data-taxonomy-term=%E9%9A%A8%E7%AD%86><span class=taxonomy-label>隨筆</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9A%B1%E7%A7%81/ data-taxonomy-term=%E9%9A%B1%E7%A7%81><span class=taxonomy-label>隱私</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9A%B1%E7%A7%81%E4%BF%9D%E8%AD%B7/ data-taxonomy-term=%E9%9A%B1%E7%A7%81%E4%BF%9D%E8%AD%B7><span class=taxonomy-label>隱私保護</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9B%86%E7%BE%A4/ data-taxonomy-term=%E9%9B%86%E7%BE%A4><span class=taxonomy-label>集群</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9B%9C%E8%AB%87/ data-taxonomy-term=%E9%9B%9C%E8%AB%87><span class=taxonomy-label>雜談</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E9%9B%B2%E6%9C%8D%E5%8B%99/ data-taxonomy-term=%E9%9B%B2%E6%9C%8D%E5%8B%99><span class=taxonomy-label>雲服務</span><span class=taxonomy-count>2</span></a></li></ul></div><div class="taxonomy taxonomy-terms-cloud taxo-categories"><h5 class=taxonomy-title>Categories</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/markdown/ data-taxonomy-term=markdown><span class=taxonomy-label>Markdown</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/win%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/ data-taxonomy-term=win%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87><span class=taxonomy-label>Win疑難雜症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7/ data-taxonomy-term=%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7><span class=taxonomy-label>人工智慧</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E4%BA%BA%E7%94%9F/ data-taxonomy-term=%E4%BA%BA%E7%94%9F><span class=taxonomy-label>人生</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%84%AA%E6%83%A0%E6%B4%BB%E5%8B%95/ data-taxonomy-term=%E5%84%AA%E6%83%A0%E6%B4%BB%E5%8B%95><span class=taxonomy-label>優惠活動</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%8F%A2%E9%9B%86/ data-taxonomy-term=%E5%8F%A2%E9%9B%86><span class=taxonomy-label>叢集</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%AE%89%E5%85%A8/ data-taxonomy-term=%E5%AE%89%E5%85%A8><span class=taxonomy-label>安全</span><span class=taxonomy-count>8</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%B7%A5%E5%85%B7/ data-taxonomy-term=%E5%B7%A5%E5%85%B7><span class=taxonomy-label>工具</span><span class=taxonomy-count>17</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%96%A6/ data-taxonomy-term=%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%96%A6><span class=taxonomy-label>工具推薦</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%8A%80%E8%A1%93-%E9%99%A4%E9%8C%AF-ai/ data-taxonomy-term=%E6%8A%80%E8%A1%93-%E9%99%A4%E9%8C%AF-ai><span class=taxonomy-label>技術, 除錯, AI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%95%99%E5%AD%B8/ data-taxonomy-term=%E6%95%99%E5%AD%B8><span class=taxonomy-label>教學</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>19</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%97%A5%E5%B8%B8/ data-taxonomy-term=%E6%97%A5%E5%B8%B8><span class=taxonomy-label>日常</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%9C%AA%E5%88%86%E9%A1%9E/ data-taxonomy-term=%E6%9C%AA%E5%88%86%E9%A1%9E><span class=taxonomy-label>未分類</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/ data-taxonomy-term=%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87><span class=taxonomy-label>疑難雜症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB/ data-taxonomy-term=%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB><span class=taxonomy-label>程式設計師</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%B3%BB%E7%B5%B1/ data-taxonomy-term=%E7%B3%BB%E7%B5%B1><span class=taxonomy-label>系統</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E5%95%9F%E7%94%A8/ data-taxonomy-term=%E7%B3%BB%E7%B5%B1%E5%95%9F%E7%94%A8><span class=taxonomy-label>系統啟用</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%B4%A2%E5%BC%95/ data-taxonomy-term=%E7%B4%A2%E5%BC%95><span class=taxonomy-label>索引</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%B6%B2%E8%B7%AF/ data-taxonomy-term=%E7%B6%B2%E8%B7%AF><span class=taxonomy-label>網路</span><span class=taxonomy-count>22</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93/ data-taxonomy-term=%E7%B6%B2%E8%B7%AF%E6%8A%80%E8%A1%93><span class=taxonomy-label>網路技術</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E8%A7%80%E9%BB%9E/ data-taxonomy-term=%E8%A7%80%E9%BB%9E><span class=taxonomy-label>觀點</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E8%A8%AD%E8%A8%88/ data-taxonomy-term=%E8%A8%AD%E8%A8%88><span class=taxonomy-label>設計</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E8%A9%95%E6%B8%AC/ data-taxonomy-term=%E8%A9%95%E6%B8%AC><span class=taxonomy-label>評測</span><span class=taxonomy-count>6</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E8%AA%BF%E7%A0%94/ data-taxonomy-term=%E8%AA%BF%E7%A0%94><span class=taxonomy-label>調研</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E8%AE%80%E6%9B%B8/ data-taxonomy-term=%E8%AE%80%E6%9B%B8><span class=taxonomy-label>讀書</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%80%9A%E8%AD%98/ data-taxonomy-term=%E9%80%9A%E8%AD%98><span class=taxonomy-label>通識</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%81%8B%E7%B6%AD/ data-taxonomy-term=%E9%81%8B%E7%B6%AD><span class=taxonomy-label>運維</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%96%8B%E6%BA%90%E9%A0%85%E7%9B%AE/ data-taxonomy-term=%E9%96%8B%E6%BA%90%E9%A0%85%E7%9B%AE><span class=taxonomy-label>開源項目</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%9A%A8%E7%AD%86/ data-taxonomy-term=%E9%9A%A8%E7%AD%86><span class=taxonomy-label>隨筆</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%9B%86%E7%BE%A4/ data-taxonomy-term=%E9%9B%86%E7%BE%A4><span class=taxonomy-label>集群</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/ data-taxonomy-term=%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99><span class=taxonomy-label>雲端服務</span><span class=taxonomy-count>1</span></a></li></ul></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><a class=td-rss-button title=RSS href=/zh-tw/blog/index.xml target=_blank rel=noopener><i class="fa-solid fa-rss" aria-hidden=true></i></a><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/zh-tw/blog/>博客</a></li><li class="breadcrumb-item active" aria-current=page>华为C++编程规范</li></ol></nav><div class=td-content><h1>华为C++编程规范</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><header class=article-meta><div class="taxonomy taxonomy-terms-article taxo-tags"><h5 class=taxonomy-title>Tags:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span></a></li></ul></div><div class="taxonomy taxonomy-terms-article taxo-categories"><h5 class=taxonomy-title>Categories:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/zh-tw/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li></ul></div></header><ul><li><input disabled type=checkbox> 华为C++编程规范</li></ul><h1 id=c语言编程规范>C++语言编程规范</h1><h2 id=目的><a name=c0-1></a>目的</h2><p>规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。
参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。</p><ol><li>了解C++语言的ISO标准；</li><li>熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性；</li><li>了解C++语言的标准库；</li></ol><h2 id=总体原则><a name=c0-2></a>总体原则</h2><p>代码需要在保证功能正确的前提下，满足<strong>可读、可维护、安全、可靠、可测试、高效、可移植</strong>的特征要求。</p><h2 id=重点关注><a name=c0-2></a>重点关注</h2><ol><li>约定C++语言的编程风格，比如命名，排版等。</li><li>C++语言的模块化设计，如何设计头文件，类，接口和函数。</li><li>C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。</li><li>现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。</li><li>本规范优先适于用C++17版本。</li></ol><h2 id=约定><a name=c0-3></a>约定</h2><p><strong>规则</strong>：编程时必须遵守的约定(must)</p><p><strong>建议</strong>：编程时应该遵守的约定(should)</p><p>本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。</p><h2 id=例外><a name=c0-4></a>例外</h2><p>无论是&rsquo;规则&rsquo;还是&rsquo;建议&rsquo;，都必须理解该条目这么规定的原因，并努力遵守。
但是，有些规则和建议可能会有例外。</p><p>在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。
例外破坏了代码的一致性，请尽量避免。&lsquo;规则&rsquo;的例外应该是极少的。</p><p>下列情况，应风格一致性原则优先：
<strong>修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。</strong></p><h1 id=2-命名><a name=c2></a>2 命名</h1><h2 id=通用命名><a name=c2-1></a>通用命名</h2><p><strong>驼峰风格(CamelCase)</strong>
大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。
按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)</p><table><thead><tr><th>类型</th><th>命名风格</th></tr></thead><tbody><tr><td>类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称</td><td>大驼峰</td></tr><tr><td>函数(包括全局函数，作用域函数，成员函数)</td><td>大驼峰</td></tr><tr><td>全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量</td><td>小驼峰</td></tr><tr><td>宏，常量(const)，枚举值，goto 标签</td><td>全大写，下划线分割</td></tr></tbody></table><p>注意：
上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。
上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。</p><h2 id=文件命名><a name=c2-2></a>文件命名</h2><h3 id=规则221-c文件以cpp结尾头文件以h结尾><a name=r2-2-1></a>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</h3><p>我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。
我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。</p><p>目前业界还有一些其他的后缀的表示方法：</p><ul><li>头文件： .hh, .hpp, .hxx</li><li>cpp文件：.cc, .cxx, .c</li></ul><p>如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。
但是对于本文档，我们默认使用.h和.cpp作为后缀。</p><h3 id=规则222-c文件名和类名保持一致><a name=r2-2-2></a>规则2.2.2 C++文件名和类名保持一致</h3><p>C++的头文件和cpp文件名和类名保持一致，使用下划线小写风格。</p><p>如果有一个类叫DatabaseConnection，那么对应的文件名：</p><ul><li>database_connection.h</li><li>database_connection.cpp</li></ul><p>结构体，命名空间，枚举等定义的文件名类似。</p><h2 id=函数命名><a name=c2-3></a>函数命名</h2><p>函数命名统一使用大驼峰风格，一般采用动词或者动宾结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>AddElement</span><span class=p>(</span><span class=k>const</span> <span class=n>Element</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Element</span> <span class=nf>GetElement</span><span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteUser</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类型命名><a name=c2-4></a>类型命名</h2><p>类型命名采用大驼峰命名风格。
所有类型命名——类、结构体、联合体、类型定义（typedef）、枚举——使用相同约定，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// classes, structs and unions
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTable</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTableTester</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UrlTableProperties</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>Packet</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedefs
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>UrlTableProperties</span><span class=o>*&gt;</span> <span class=n>PropertiesMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// enums
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>UrlTableErrors</span> <span class=p>{</span> <span class=p>...</span>
</span></span></code></pre></div><p>对于命名空间的命名，建议使用大驼峰：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// namespace
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>OsUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FileUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=建议241-避免滥用-typedef或者define-对基本类型起别名><a name=a2-4-1></a>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</h3><p>除有明确的必要性，否则不要用 typedef/#define 对基本数据类型进行重定义。
优先使用<code>&lt;cstdint></code>头文件中的基本类型：</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有/无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有/无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有/无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有/无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有/无符号整数类型</td></tr></tbody></table><h2 id=变量命名><a name=c2-5></a>变量命名</h2><p>通用变量命名采用小驼峰，包括全局变量，函数形参，局部变量，成员变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tableName</span><span class=p>;</span>  <span class=c1>// Good: 推荐此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tablename</span><span class=p>;</span>  <span class=c1>// Bad: 禁止此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span>       <span class=c1>// Good: 只有一个单词时，小驼峰为全小写
</span></span></span></code></pre></div><h3 id=规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀><a name=r2-5-1></a>规则2.5.1 全局变量应增加 &lsquo;g_&rsquo; 前缀，静态变量命名不需要加特殊前缀</h3><p>全局变量是应当尽量少使用的，使用时应特别注意，所以加上前缀用于视觉上的突出，促使开发人员对这些变量的使用更加小心。</p><ul><li>全局静态变量命名与全局变量相同。</li><li>函数内的静态变量命名与普通局部变量相同。</li><li>类的静态成员变量和普通成员变量相同。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_activeConnectCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>packetCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则252-类的成员变量命名以小驼峰加后下划线组成><a name=r2-5-2></a>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileName_</span><span class=p>;</span>   <span class=c1>// 添加_后缀，类似于K&amp;R命名风格
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>对于struct/union的成员变量，仍采用小驼峰不加后缀的命名方式，与局部变量命名风格一致。</p><h2 id=宏常量枚举命名><a name=c2-6></a>宏、常量、枚举命名</h2><p>宏、枚举值采用全大写，下划线连接的格式。
全局作用域内，有名和匿名namespace内的 const 常量，类的静态成员常量，全大写，下划线连接；函数局部 const 常量和类的普通const成员变量，使用小驼峰命名风格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX(a, b)   (((a) &lt; (b)) ? (b) : (a)) </span><span class=c1>// 仅对宏命名举例，并不推荐用宏实现此类功能
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TintColor</span> <span class=p>{</span>    <span class=c1>// 注意，枚举类型名用大驼峰，其下面的取值是全大写，下划线相连
</span></span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DARK_RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>GREEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LIGHT_GREEN</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>    <span class=c1>// 函数局部常量
</span></span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>DEFAULT_FILE_SIZE_KB</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>        <span class=c1>// 全局常量
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=3-格式><a name=c3></a>3 格式</h1><h2 id=行宽><a name=c3-1></a>行宽</h2><h3 id=规则311-行宽不超过-120-个字符><a name=r3-1-1></a>规则3.1.1 行宽不超过 120 个字符</h3><p>建议每行字符数不要超过 120 个。如果超过120个字符，请选择合理的方式进行换行。</p><p>例外:</p><ul><li>如果一行注释包含了超过120 个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；</li><li>包含长路径的 #include 语句可以超出120 个字符，但是也需要尽量避免；</li><li>编译预处理中的error信息可以超出一行。
预处理的 error 信息在一行便于阅读和理解，即使超过 120 个字符。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef XXX_YYY_ZZZ
</span></span></span><span class=line><span class=cl><span class=cp>#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 id=缩进><a name=c3-2></a>缩进</h2><h3 id=规则321-使用空格进行缩进每次缩进4个空格><a name=r3-2-1></a>规则3.2.1 使用空格进行缩进，每次缩进4个空格</h3><p>只允许使用空格(space)进行缩进，每次缩进为 4 个空格。不允许使用Tab符进行缩进。
当前几乎所有的集成开发环境（IDE）都支持配置将Tab符自动扩展为4空格输入；请配置你的IDE支持使用空格进行缩进。</p><h2 id=大括号><a name=c3-3></a>大括号</h2><h3 id=规则331-使用-kr-缩进风格><a name=r3-3-1></a>规则3.3.1 使用 K&amp;R 缩进风格</h3><p><strong>K&amp;R风格</strong>
换行时，函数（不包括lambda表达式）左大括号另起一行放行首，并独占一行；其他左大括号跟随语句放行末。
右大括号独占一行，除非后面跟着同一语句的剩余部分，如 do 语句中的 while，或者 if 语句的 else/else if，或者逗号、分号。</p><p>如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span> <span class=p>{</span>     <span class=c1>// 跟随语句放行末，前置1空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                   <span class=c1>// 函数左大括号独占一行，放行首
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>推荐这种风格的理由：</p><ul><li>代码更紧凑；</li><li>相比另起一行，放行末使代码阅读节奏感上更连续；</li><li>符合后来语言的习惯，符合业界主流习惯；</li><li>现代集成开发环境（IDE）都具有代码缩进对齐显示的辅助功能，大括号放在行尾并不会对缩进和范围产生理解上的影响。</li></ul><p>对于空函数体，可以将大括号放在同一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=函数声明和定义><a name=c3-4></a>函数声明和定义</h2><h3 id=规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐><a name=r3-4-1></a>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</h3><p>在声明和定义函数的时候，函数的返回值类型应该和函数名在同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。
参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>FunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>)</span>   <span class=c1>// Good：全在同一行
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>VeryVeryVeryLongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span>     <span class=c1>// 行宽不满足所有参数，进行换行
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span>     <span class=c1>// Good：和上一行参数对齐
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>LongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=c1>// 行宽限制，进行换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName5</span><span class=p>)</span>     <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>ReallyReallyReallyReallyLongFunctionName</span><span class=p>(</span>            <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span> <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=函数调用><a name=c3-5></a>函数调用</h2><h3 id=规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐><a name=r3-5-1></a>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</h3><p>函数调用时，函数参数列表放在一行。参数列表如果超过行宽，需要换行并进行合理的参数对齐。
左圆括号总是跟函数名，右圆括号总是跟最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>);</span>   <span class=c1>// Good：函数参数放在一行
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>paramName2</span><span class=p>,</span>                <span class=c1>// Good：保持与上方参数对齐
</span></span></span><span class=line><span class=cl>                                 <span class=n>paramName3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>paramName3</span><span class=p>,</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>paramName5</span><span class=p>);</span>                    <span class=c1>// Good：参数换行，4 空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>VeryVeryVeryLongFunctionName</span><span class=p>(</span>           <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>paramName3</span><span class=p>);</span>                    <span class=c1>// 换行后，4 空格缩进
</span></span></span></code></pre></div><p>如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Good：每行的参数代表一组相关性较强的数据结构，放在一行便于理解
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DealWithStructureLikeParams</span><span class=p>(</span><span class=n>left</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>left</span><span class=p>.</span><span class=n>y</span><span class=p>,</span>     <span class=c1>// 表示一组相关参数
</span></span></span><span class=line><span class=cl>                                         <span class=n>right</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>right</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>  <span class=c1>// 表示另外一组相关参数
</span></span></span></code></pre></div><h2 id=if语句><a name=c3-6></a>if语句</h2><h3 id=规则361-if语句必须要使用大括号><a name=r3-6-1></a>规则3.6.1 if语句必须要使用大括号</h3><p>我们要求if语句都需要使用大括号，即便只有一条语句。</p><p>理由：</p><ul><li>代码逻辑直观，易读；</li><li>在已有条件语句代码上增加新代码时不容易出错；</li><li>对于在if语句中使用函数式宏时，有大括号保护不易出错（如果宏定义时遗漏了大括号）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>objectIsNotExist</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Good：单行条件语句也加大括号
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>CreateNewObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则362-禁止-ifelseelse-if-写在同一行><a name=r3-6-2></a>规则3.6.2 禁止 if/else/else if 写在同一行</h3><p>条件语句中，若有多个分支，应该写在不同行。</p><p>如下是正确的写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// Good: else 与 if 在不同行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是不符合规范的案例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=c1>// Bad: else 与 if 在同一行
</span></span></span></code></pre></div><h2 id=循环语句><a name=c3-7></a>循环语句</h2><h3 id=规则371-循环语句必须使用大括号><a name=r3-7-1></a>规则3.7.1 循环语句必须使用大括号</h3><p>和条件表达式类似，我们要求for/while循环语句必须加上大括号，即便循环体是空的，或循环语句只有一条。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// Good: 使用了大括号
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>   <span class=c1>// Good：循环体是空，使用大括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>continue</span><span class=p>;</span>           <span class=c1>// Good：continue 表示空逻辑，使用大括号
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>      <span class=c1>// Bad: 应该加上括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>);</span>      <span class=c1>// Bad：使用分号容易让人误解是while语句中的一部分
</span></span></span></code></pre></div><h2 id=switch语句><a name=c3-8></a>switch语句</h2><h3 id=规则381-switch-语句的-casedefault-要缩进一层><a name=r3-8-1></a>规则3.8.1 switch 语句的 case/default 要缩进一层</h3><p>switch 语句的缩进风格如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>             <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething1</span><span class=p>();</span> <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span>           <span class=c1>// Good: 带大括号格式
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=o>:</span>                 <span class=c1>// Bad: case 未缩进
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span>                <span class=c1>// Bad: default 未缩进
</span></span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=表达式><a name=c3-9></a>表达式</h2><h3 id=建议391-表达式换行要保持换行的一致性运算符放行末><a name=a3-9-1></a>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><p>较长的表达式，不满足行宽要求的时候，需要在适当的地方换行。一般在较低优先级运算符或连接符后面截断，运算符或连接符放在行末。
运算符、连接符放在行末，表示“未结束，后续还有”。
例：</p><p>// 假设下面第一行已经不满足行宽要求</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>currentValue</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span>  <span class=c1>// Good：换行后，逻辑操作符放在行尾
</span></span></span><span class=line><span class=cl>    <span class=n>someCondition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>reallyReallyLongVariableName1</span> <span class=o>+</span>    <span class=c1>// Good
</span></span></span><span class=line><span class=cl>             <span class=n>reallyReallyLongVariableName2</span><span class=p>;</span>
</span></span></code></pre></div><p>表达式换行后，注意保持合理对齐，或者4空格缩进。参考下面例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>         <span class=c1>// Good: 4空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>          <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>   <span class=c1>// Good: 保持对齐
</span></span></span></code></pre></div><h2 id=变量赋值><a name=c3-10></a>变量赋值</h2><h3 id=规则3101-多个变量定义和赋值语句不允许写在一行><a name=r3-10-1></a>规则3.10.1 多个变量定义和赋值语句不允许写在一行</h3><p>每行只有一个变量初始化的语句，更容易阅读和理解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span></code></pre></div><p>下面是不符合规范的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Bad：多个变量初始化需要分开放在多行，每行一个变量初始化
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Bad：多个变量定义需要分行，每行一个
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>pointX</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>pointY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Bad：多个变量赋值语句放同一行
</span></span></span></code></pre></div><p>例外：for 循环头、if 初始化语句（C++17）、结构化绑定语句（C++17）中可以声明和初始化多个变量。这些语句中的多个变量声明有较强关联，如果强行分成多行会带来作用域不一致，声明和初始化割裂等问题。</p><h2 id=初始化><a name=c3-11></a>初始化</h2><p>初始化包括结构体、联合体、及数组的初始化</p><h3 id=规则3111-初始化换行时要有缩进并进行合理对齐><a name=r3-11-1></a>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</h3><p>结构体或数组初始化时，如果换行应保持4空格缩进。
从可读性角度出发，选择换行点和对齐位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=指针与引用><a name=c3-12></a>指针与引用</h2><h3 id=建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-1></a>建议3.12.1 指针类型"<code>*</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>指针命名: <code>*</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Bad
</span></span></span></code></pre></div><p>例外：当变量被 const 修饰时，"<code>*</code>&rdquo; 无法跟随变量，此时也不要跟随类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>VERSION</span> <span class=o>=</span> <span class=s>&#34;V100&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-2></a>建议3.12.2 引用类型"<code>&</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>引用命名：<code>&</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*&amp;</span> <span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随类型
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随变量名
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，* 跟随类型，&amp; 跟随变量名
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>      <span class=c1>// Bad
</span></span></span></code></pre></div><h2 id=编译预处理><a name=c3-13></a>编译预处理</h2><h3 id=规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进><a name=r3-13-1></a>规则3.13.1 编译预处理的&rdquo;#&ldquo;统一放在行首，嵌套编译预处理语句时，&rdquo;#&ldquo;可以进行缩进</h3><p>编译预处理的&rdquo;#&ldquo;统一放在行首，即使编译预处理的代码是嵌入在函数体中的，&rdquo;#&ldquo;也应该放在行首。</p><h3 id=规则3132-避免使用宏><a name=r3-13-2></a>规则3.13.2 避免使用宏</h3><p>宏会忽略作用域，类型系统以及各种规则，容易引发问题。应尽量避免使用宏定义，如果必须使用宏，要保证证宏名的唯一性。
在C++中，有许多方式来避免使用宏：</p><ul><li>用const或enum定义易于理解的常量</li><li>用namespace避免名字冲突</li><li>用inline函数避免函数调用的开销</li><li>用template函数来处理多种类型</li></ul><p>在文件头保护宏、条件编译、日志记录等必要场景中可以使用宏。</p><h3 id=规则3133-禁止使用宏来表示常量><a name=r3-13-3></a>规则3.13.3 禁止使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名； 宏没有类型检查，不安全； 宏没有作用域。</p><h3 id=规则3134-禁止使用函数式宏><a name=r3-13-4></a>规则3.13.4 禁止使用函数式宏</h3><p>宏义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。
函数式宏的缺点如下：</p><ul><li>函数式宏缺乏类型检查，不如函数调用检查严格</li><li>宏展开时宏参数不求值，可能会产生非预期结果</li><li>宏没有独立的作用域</li><li>宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性</li><li>在特定场景中必须用编译器对宏的扩展语法，如GCC的statement expression，影响可移植性</li><li>宏在预编译阶段展开后，在期后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题</li><li>对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀</li></ul><p>函数没有宏的上述缺点。但是，函数相比宏，最大的劣势是执行效率不高（增加函数调用的开销和编译器优化的难度）。
为此，可以在必要时使用内联函数。内联函数跟宏类似，也是在调用点展开。不同之处在于内联函数是在编译时展开。</p><p>内联函数兼具函数和宏的优点：</p><ul><li>内联函数执行严格的类型检查</li><li>内联函数的参数求值只会进行一次</li><li>内联函数就地展开，没有函数调用的开销</li><li>内联函数比函数优化得更好</li></ul><p>对于性能要求高的产品代码，可以考虑用内联函数代替函数。</p><p>例外：
在日志记录场景中，需要通过函数式宏保持调用点的文件名（<strong>FILE</strong>）、行号（<strong>LINE</strong>）等信息。</p><h2 id=空格和空行><a name=c3-14></a>空格和空行</h2><h3 id=规则3141-水平空格应该突出关键字和重要信息避免不必要的留白><a name=r3-14-1></a>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</h3><p>水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。总体规则如下：</p><ul><li>if, switch, case, do, while, for等关键字之后加空格；</li><li>小括号内部的两侧，不要加空格；</li><li>大括号内部两侧有无空格，左右必须保持一致；</li><li>一元操作符（& * + ‐ ~ !）之后不要加空格；</li><li>二元操作符（= + ‐ &lt; > * / % | & ^ &lt;= >= == != ）左右两侧加空格</li><li>三目运算符（? :）符号两侧均需要空格</li><li>前置和后置的自增、自减（++ &ndash;）和变量之间不加空格</li><li>结构体成员操作符（. ->）前后不加空格</li><li>逗号(,)前面不加空格，后面增加空格</li><li>对于模板和类型转换(&lt;>)和类型之间不要添加空格</li><li>域操作符(::)前后不要添加空格</li><li>冒号(:)前后根据情况来判断是否要添加空格</li></ul><p>常规情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：大括号前应该留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Good：变量初始化时，=前后应该有空格，分号前面不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>    <span class=c1>// Good：大括号内两侧都无空格
</span></span></span></code></pre></div><p>函数定义和函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>^</span>    <span class=c1>// Bad: 逗号后面需要增加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                 <span class=o>^</span>          <span class=o>^</span>  <span class=c1>// Bad: 函数参数列表的左括号后面不应该有空格，右括号前面不应该有空格
</span></span></span></code></pre></div><p>指针和取地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>     <span class=c1>// Good：*操作符和指针p之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：&amp;操作符和变量x之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>    <span class=c1>// Good：通过.访问成员变量时不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>   <span class=c1>// Good：通过-&gt;访问成员变量时不加空格
</span></span></span></code></pre></div><p>操作符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// Good：赋值操作的=前后都要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5</span><span class=p>;</span>  <span class=c1>// Good：负数的符号和数值之前不要加空格
</span></span></span><span class=line><span class=cl><span class=o>++</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：前置和后置的++/--和变量之间不要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>y</span><span class=p>)</span>  <span class=c1>// Good：布尔操作符前后要加上空格，！操作和变量之间不要空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>/</span> <span class=n>z</span><span class=p>;</span>  <span class=c1>// Good：二元操作符前后要加空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>z</span><span class=p>);</span>    <span class=c1>// Good：括号内的表达式前后不需要加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>  <span class=c1>// Good: 三目运算符， ？和：前后需要添加空格
</span></span></span></code></pre></div><p>循环和条件语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：if关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>           <span class=c1>// Good：else关键字和大括号之间加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{}</span>   <span class=c1>// Good：while关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：for关键字和括号之间加空格，分号之后加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: switch 关键字后面有1空格
</span></span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>     <span class=c1>// Good：case语句条件和冒号之间不加空格
</span></span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>模板和转换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在类型与指针操作符之间留空格也可以, 但要保持一致.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>域操作符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>    <span class=c1>// Good: 命名空间访问，不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>GetValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{}</span>  <span class=c1>// Good: 对于成员函数定义，不要留空格
</span></span></span></code></pre></div><p>冒号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 类的派生需要留有空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 构造函数初始化列表需要留有空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 位域表示也留有空格
</span></span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>XX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 对于public:, private:这种类访问权限的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对于switch-case的case和default后面的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意：当前的集成开发环境（IDE）可以设置删除行尾的空格，请正确配置。</p><h3 id=建议3141-合理安排空行保持代码紧凑><a name=a3-14-1></a>建议3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：</p><ul><li>根据上下内容的相关程度，合理安排空行；</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不使用连续 <strong>3</strong> 个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但namespace的大括号内不作要求。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Bar</span><span class=p>()</span>  <span class=c1>// Bad：最多使用连续2个空行。
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行首不要加入空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行尾不要加入空行
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：函数体内行首不要加空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类><a name=c3-15></a>类</h2><h3 id=规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐><a name=r3-15-1></a>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>      <span class=c1>// 注意没有缩进
</span></span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>();</span>  <span class=c1>// 标准的4空格缩进
</span></span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunctionThatDoesNothing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetVar</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=p>{</span> <span class=n>someVar_</span> <span class=o>=</span> <span class=n>var</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVar</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>someVar_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>SomeInternalFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someOtherVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在各个部分中，建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它成员函数, 数据成员。</p><h3 id=规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行><a name=r3-15-2></a>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 如果所有变量能放在同一行:
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果不能放在同一行,
</span></span></span><span class=line><span class=cl><span class=c1>// 必须置于冒号后, 并缩进4个空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span> <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Good: 逗号后面留有空格
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果初始化列表需要置于多行, 需要逐行对齐
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span>             <span class=c1>// 缩进4个空格
</span></span></span><span class=line><span class=cl>      <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=4-注释><a name=c4></a>4 注释</h1><p>一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明。
注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，<strong>按需注释</strong>。</p><p>注释内容要简洁、明了、无二义性，信息全面且不冗余。</p><p><strong>注释跟代码一样重要。</strong>
写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释，即注释解释代码难以表达的意图，不要重复代码信息。
修改代码时，也要保证其相关注释的一致性。只改代码，不改注释是一种不文明行为，破坏了代码与注释的一致性，让阅读者迷惑、费解，甚至误解。</p><p>使用英文进行注释。</p><h2 id=注释风格><a name=c3-1></a>注释风格</h2><p>在 C++ 代码中，使用 <code>/*</code> <code>*/</code>和 <code>//</code> 都是可以的。
按注释的目的和位置，注释可分为不同的类型，如文件头注释、函数头注释、代码注释等等；
同一类型的注释应该保持统一的风格。</p><p>注意：本文示例代码中，大量使用 &lsquo;//&rsquo; 后置注释只是为了更精确的描述问题，并不代表这种注释风格更好。</p><h2 id=文件头注释><a name=c4-2></a>文件头注释</h2><h3 id=规则31-文件头注释必须包含版权许可><a name=r3-1></a>规则3.1 文件头注释必须包含版权许可</h3><p>/*</p><ul><li>Copyright (c) 2020 XXX</li><li>Licensed under the Apache License, Version 2.0 (the &ldquo;License&rdquo;);</li><li>you may not use this file except in compliance with the License.</li><li>You may obtain a copy of the License at
*</li><li><pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre></li></ul><p>*</p><ul><li>Unless required by applicable law or agreed to in writing, software</li><li>distributed under the License is distributed on an &ldquo;AS IS&rdquo; BASIS,</li><li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li><li>See the License for the specific language governing permissions and</li><li>limitations under the License.
*/</li></ul><h2 id=函数头注释><a name=c4-3></a>函数头注释</h2><h3 id=规则431-公有public函数必须编写函数头注释><a name=r4-3-1></a>规则4.3.1 公有（public）函数必须编写函数头注释</h3><p>公有函数属于类对外提供的接口，调用者需要了解函数的功能、参数的取值范围、返回的结果、注意事项等信息才能正常使用。
特别是参数的取值范围、返回的结果、注意事项等都无法做到自注示，需要编写函数头注释辅助说明。</p><h3 id=规则432-禁止空有格式的函数头注释><a name=r4-3-2></a>规则4.3.2 禁止空有格式的函数头注释</h3><p>并不是所有的函数都需要函数头注释；
函数签名无法表达的信息，加函数头注释辅助说明;</p><p>函数头注释统一放在函数声明或定义上方，使用如下风格之一：
使用<code>//</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 单行函数头
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 多行函数头
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>使用<code>/* */</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 单行函数头 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种单行函数头
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 多行函数头
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func3</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>函数尽量通过函数名自注释，按需写函数头注释。
不要写无用、信息冗余的函数头；不要写空有格式的函数头。</p><p>函数头注释内容可选，但不限于：功能说明、返回值，性能约束、用法、内存约定、算法实现、可重入的要求等等。
模块对外头文件中的函数接口声明，其函数头注释，应当将重要、有用的信息表达清楚。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 返回实际写入的字节数，-1表示写入失败
</span></span></span><span class=line><span class=cl><span class=cm> * 注意，内存 buf 由调用者负责释放
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 函数名：WriteString
</span></span></span><span class=line><span class=cl><span class=cm> * 功能：写入字符串
</span></span></span><span class=line><span class=cl><span class=cm> * 参数：
</span></span></span><span class=line><span class=cl><span class=cm> * 返回值：
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>上面例子中的问题：</p><ul><li>参数、返回值，空有格式没内容</li><li>函数名信息冗余</li><li>关键的 buf 由谁释放没有说清楚</li></ul><h2 id=代码注释><a name=c4-4></a>代码注释</h2><h3 id=规则441-代码注释放于对应代码的上方或右边><a name=r4-4-1></a>规则4.4.1 代码注释放于对应代码的上方或右边</h3><h3 id=规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格><a name=r4-4-2></a>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</h3><p>代码上方的注释，应该保持对应代码一样的缩进。
选择并统一使用如下风格之一：
使用<code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是单行注释
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是多行注释
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>使用<code>/*' '*/</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 这是单行注释 */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种方式的多行注释
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>代码右边的注释，与代码之间，至少留1空格，建议不超过4空格。
通常使用扩展后的 TAB 键即可实现 1-4 空格的缩进。</p><p>选择并统一使用如下风格之一：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>  <span class=c1>// 放右边的注释
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>bar</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>  <span class=cm>/* 放右边的注释 */</span>
</span></span></code></pre></div><p>右置格式在适当的时候，上下对齐会更美观。
对齐后的注释，离左边代码最近的那一行，保证1-4空格的间隔。
例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>A_CONST</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>         <span class=cm>/* 相关的同类注释，可以考虑上下对齐 */</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>ANOTHER_CONST</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>   <span class=cm>/* 上下对齐时，与左侧代码保持间隔 */</span>
</span></span></code></pre></div><p>当右置的注释超过行宽时，请考虑将注释置于代码上方。</p><h3 id=规则443-不用的代码段直接删除不要注释掉><a name=r4-4-3></a>规则4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。
正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 /* */ 和 //，还包括 #if 0， #ifdef NEVER_DEFINED 等等。</p><h1 id=5-头文件><a name=c5></a>5 头文件</h1><h2 id=头文件职责><a name=c5-1></a>头文件职责</h2><p>头文件是模块或文件的对外接口，头文件的设计体现了大部分的系统设计。
头文件中适合放置接口的声明，不适合放置实现（内联函数除外）。对于cpp文件中内部才需要使用的函数、宏、枚举、结构定义等不要放在头文件中。
头文件应当职责单一。头文件过于复杂，依赖过于复杂还是导致编译时间过长的主要原因。</p><h3 id=建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口><a name=a5-1-1></a>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</h3><p>通常情况下，每个.cpp文件都有一个相应的.h，用于放置对外提供的函数声明、宏定义、类型定义等。
如果一个.cpp文件不需要对外公布任何接口，则其就不应当存在。
例外：<strong>程序的入口（如main函数所在的文件），单元测试代码，动态库代码。</strong></p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifndef FOO_H
</span></span></span><span class=line><span class=cl><span class=cp>#define FOO_H
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Foo.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span> <span class=c1>// Good: 对内函数的声明放在.cpp文件的头部，并声明为匿名namespace或者static限制其作用域
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=头文件依赖><a name=c5-2></a>头文件依赖</h2><h3 id=规则521-禁止头文件循环依赖><a name=r5-2-1></a>规则5.2.1 禁止头文件循环依赖</h3><p>头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。</p><p>头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。</p><h3 id=规则522-头文件必须编写define保护防止重复包含><a name=r5-2-4></a>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</h3><p>为防止头文件被重复包含，所有头文件都应当使用 #define 保护；不要使用 #pragma once</p><p>定义包含保护符时，应该遵守如下规则：
1）保护符使用唯一名称；
2）不要在受保护部分的前后放置代码或者注释，文件头注释除外。</p><p>示例：假定timer模块的timer.h，其目录为timer/include/timer.h,应按如下方式保护：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp>#define TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h3 id=规则523-禁止通过声明的方式引用外部函数接口变量><a name=r5-2-5></a>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。
通过 extern 声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。
同时这种隐式依赖，容易导致架构腐化。</p><p>不符合规范的案例：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>   <span class=c1>// Bad: 通过extern的方式使用外部函数
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>应该改为：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>   </span><span class=c1>// Good: 通过包含头文件的方式使用其他.cpp提供的接口
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例外，有些场景需要引用其内部函数，但并不想侵入代码时，可以 extern 声明方式引用。
如：
针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数；
当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数。</p><h3 id=规则524-禁止在extern-c中包含头文件><a name=r5-2-6></a>规则5.2.4 禁止在extern &ldquo;C"中包含头文件</h3><p>在 extern &ldquo;C&rdquo; 中包含头文件，有可能会导致 extern &ldquo;C&rdquo; 嵌套，部分编译器对 extern &ldquo;C&rdquo; 嵌套层次有限制，嵌套层次太多会编译错误。</p><p>在C，C++混合编程的情况下，在extern &ldquo;C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。</p><p>示例，存在a.h和b.h两个头文件：</p><p>// a.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define A(value) Foo(value)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>使用C++预处理器展开b.h，将会得到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按照 a.h 作者的本意，函数 Foo 是一个 C++ 自由函数，其链接规范为 &ldquo;C++"。
但在 b.h 中，由于 <code>#include "a.h"</code> 被放到了 <code>extern "C"</code> 的内部，函数 Foo 的链接规范被不正确地更改了。</p><p>例外：
如果在 C++ 编译环境中，想引用纯C的头文件，这些C头文件并没有<code> extern "C"</code> 修饰。非侵入式的做法是，在 <code>extern "C"</code> 中去包含C头文件。</p><h3 id=建议521尽量避免使用前置声明而是通过include来包含头文件><a name=a5-2-1></a>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</h3><p>前置声明（forward declaration）通常指类、模板的纯粹声明，没伴随着其定义。</p><ul><li>优点：<ol><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li></ol></li><li>缺点：<ol><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li><li>前置声明可能会被库的后续更改所破坏。前置声明模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间<code> std::</code> 的 symbol 时，其行为未定义（在C++11标准规范中明确说明）。</li><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</li><li>很难判断什么时候该用前置声明，什么时候该用<code>#include</code>，某些场景下面前置声明和<code>#include</code>互换以后会导致意想不到的结果。</li></ol></li></ul><p>所以我们尽可能避免使用前置声明，而是使用#include头文件来保证依赖关系。</p><h1 id=6-作用域><a name=c6></a>6 作用域</h1><h2 id=命名空间><a name=c6-1></a>命名空间</h2><h3 id=建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰><a name=a6-1-1></a>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</h3><p>在C++ 2003标准规范中，使用static修饰文件作用域的变量，函数等被标记为deprecated特性，所以更推荐使用匿名namespace。</p><p>主要原因如下：</p><ol><li>static在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数，静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li>static只能保证变量，常量和函数的文件作用域，但是namespace还可以封装类型等。</li><li>统一namespace来处理C++的作用域，而不需要同时使用static和namespace来管理。</li><li>static修饰的函数不能用来实例化模板，而匿名namespace可以。</li></ol><p>但是不要在 .h 中使用中使用匿名namespace或者static。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_COUNT</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InternalFun</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>MAX_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则611-不要在头文件中或者include之前使用using导入命名空间><a name=r6-1-1></a>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</h3><p>说明：使用using导入命名空间会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using导入命名空间。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件a.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件b.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Fun</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 源代码a.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>G</span><span class=p>();</span> <span class=c1>// using namespace NamespaceA在#include “b.h”之前，引发歧义：NamespaceA::Fun，NamespaceB::Fun调用不明确
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于在头文件中使用using导入单个符号或定义别名，允许在模块自定义名字空间中使用，但禁止在全局名字空间中使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fancy/string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Bad，禁止向全局名字空间导入符号
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Good，可以在模块自定义名字空间中导入符号
</span></span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>MyVector</span> <span class=o>=</span> <span class=n>fancy</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>  <span class=c1>// Good，C++11可在自定义名字空间中定义别名
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=全局函数和静态成员函数><a name=c6-2></a>全局函数和静态成员函数</h2><h3 id=建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数><a name=a6-2-1></a>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</h3><p>说明：非成员函数放在名字空间内可避免污染全局作用域， 也不要用类+静态成员方法来简单管理全局函数。 如果某个全局函数和某个类有紧密联系， 那么可以作为类的静态成员函数。</p><p>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>File</span> <span class=n>CreateTempFile</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局常量和静态成员常量><a name=c6-3></a>全局常量和静态成员常量</h2><h3 id=建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量><a name=a6-3-1></a>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</h3><p>说明：全局常量放在命名空间内可避免污染全局作用域， 也不要用类+静态成员常量来简单管理全局常量。 如果某个全局常量和某个类有紧密联系， 那么可以作为类的静态成员常量。</p><p>如果你需要定义一些全局常量，只给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>SEPARATOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局变量><a name=c6-4></a>全局变量</h2><h3 id=建议641-尽量避免使用全局变量考虑使用单例模式><a name=a6-4-1></a>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>说明：全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_counter</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>使用单实例模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Counter</span><span class=o>&amp;</span> <span class=n>GetInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Counter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  <span class=c1>// 单实例实现简单举例
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Increase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Print</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Counter</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Print</span><span class=p>();</span>
</span></span></code></pre></div><p>实现单例模式以后，实现了全局唯一一个实例，和全局变量同样的效果，并且单实例提供了更好的封装性。</p><p>例外：有的时候全局变量的作用域仅仅是模块内部，这样进程空间里面就会有多个全局变量实例，每个模块持有一份，这种场景下是无法使用单例模式解决的。</p><h1 id=7-类><a name=c7></a>7 类</h1><h2 id=构造拷贝构造赋值和析构函数><a name=c7-1></a>构造，拷贝构造，赋值和析构函数</h2><p>构造，拷贝，移动和析构函数提供了对象的生命周期管理方法：</p><ul><li>构造函数（constructor）： <code>X()</code></li><li>拷贝构造函数（copy constructor）：<code>X(const X&)</code></li><li>拷贝赋值操作符（copy assignment）：<code>operator=(const X&)</code></li><li>移动构造函数（move constructor）：<code>X(X&&)</code> <em>C++11以后提供</em></li><li>移动赋值操作符（move assignment）：<code>operator=(X&&)</code> <em>C++11以后提供</em></li><li>析构函数（destructor）：<code>~X()</code></li></ul><h3 id=规则711-类的成员变量必须显式初始化><a name=r7-1-1></a>规则7.1.1 类的成员变量必须显式初始化</h3><p>说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。</p><p>例外：</p><ul><li>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化。</li></ul><p>示例：如下代码没有构造函数，私有数据成员无法初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//…
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Message</span> <span class=n>message</span><span class=p>;</span>   <span class=c1>// message成员变量没有初始化
</span></span></span><span class=line><span class=cl><span class=n>message</span><span class=p>.</span><span class=n>ProcessOutMsg</span><span class=p>();</span>   <span class=c1>// 后续使用存在隐患
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因此，有必要定义默认构造函数，如下：
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgID_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgBuffer_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// …
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span> <span class=c1>// 具有默认构造函数，不需要显式初始化
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化><a name=a7-1-1></a>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</h3><p>说明：C++11的声明时初始化可以一目了然的看出成员初始值，应当优先使用。如果成员初始化值和构造函数相关，或者不支持C++11，则应当优先使用构造函数初始化列表来初始化成员。相比起在构造函数体中对成员赋值，初始化列表的代码更简洁，执行性能更好，而且可以对const成员和引用成员初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1>// Good，优先使用初始化列表
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>msgBuffer_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Bad，不推荐在构造函数中赋值
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>  <span class=c1>// Good，C++11中使用
</span></span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则712-为避免隐式转换将单参数构造函数声明为explicit><a name=r7-1-2></a>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</h3><p>说明：单参数构造函数如果没有用explicit声明，则会成为隐式转换函数。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span><span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ProcessFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFoo</span><span class=p>(</span><span class=n>test</span><span class=p>);</span>  <span class=c1>// 编译不通过
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码编译不通过，因为<code>ProcessFoo</code>需要的参数是Foo类型，传入的string类型不匹配。</p><p>如果将Foo构造函数的explicit关键字移除，那么调用<code>ProcessFoo</code>传入的string就会触发隐式转换，生成一个临时的Foo对象。往往这种隐式转换是让人迷惑的，并且容易隐藏Bug，得到了一个不期望的类型转换。所以对于单参数的构造函数是要求explicit声明。</p><h3 id=规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止><a name=r7-1-3></a>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</h3><p>说明：如果用户不定义，编译器默认会生成拷贝构造函数和拷贝赋值操作符， 移动构造和移动赋值操作符（移动语义的函数C++11以后才有）。
如果我们不要使用拷贝构造函数，或者赋值操作符，请明确拒绝：</p><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li><p>使用C++11提供的delete, 请参见后面现代C++的相关章节。</p></li><li><p>推荐继承NoCopyable、NoMovable，禁止使用DISALLOW_COPY_AND_MOVE，DISALLOW_COPY，DISALLOW_MOVE等宏。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NoCopyable</span><span class=p>,</span> <span class=k>public</span> <span class=n>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>NoCopyable和NoMovable的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoCopyable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止><a name=r7-1-4></a>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><p>拷贝构造函数和拷贝赋值操作符都是具有拷贝语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, C++11可以使用delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则715-移动构造和移动赋值操作符应该是成对出现或者禁止><a name=r7-1-5></a>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</h3><p>在C++11中增加了move操作，如果需要某个类支持移动操作，那么需要实现移动构造和移动赋值操作符。</p><p>移动构造函数和移动赋值操作符都是具有移动语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, 使用C++11的delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则716-禁止在构造函数和析构函数中调用虚函数><a name=r7-1-6></a>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>说明：在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。
在C++中，一个基类一次只构造一个完整的对象。</p><p>示例：类Base是基类，Sub是派生类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Log</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// 不同的派生类调用不同的日志文件
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>()</span>         <span class=c1>// 基类构造函数
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Log</span><span class=p>();</span>           <span class=c1>// 调用虚函数Log
</span></span></span><span class=line><span class=cl><span class=p>}</span>                                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Log</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当执行如下语句：
<code>Sub sub;</code>
会先执行Sub的构造函数，但首先调用Base的构造函数，由于Base的构造函数调用虚函数Log，此时Log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为。
同样的道理也适用于析构函数。</p><h3 id=规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数><a name=r7-1-7></a>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</h3><p>如果报一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。
【反例】
如下代码中，基类没有定义拷贝构造函数或拷贝赋值操作符，编译器会自动生成这两个特殊成员函数，
如果派生类对象赋值给基类对象时就发生切片。可以将此例中的拷贝构造函数和拷贝赋值操作符声明为delete，编译器可检查出此类赋值行为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=o>&amp;</span><span class=n>base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>other</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span> <span class=c1>// 不符合：发生切片
</span></span></span><span class=line><span class=cl>    <span class=n>other</span><span class=p>.</span><span class=n>Fun</span><span class=p>();</span> <span class=c1>// 调用的时Base类的Fun函数
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// 传入的是派生类对象
</span></span></span></code></pre></div><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><h2 id=继承><a name=c7-2></a>继承</h2><h3 id=规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final><a name=r7-2-1></a>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</h3><p>说明：只有基类析构函数是virtual，通过多态调用的时候才能保证派生类的析构函数被调用。</p><p>示例：基类的析构函数没有声明为virtual导致了内存泄漏。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=n>cpp</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=p>()</span> <span class=o>:</span> <span class=n>numbers_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Sub&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>size_t</span> <span class=n>numberCount</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers_</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=n>numberCount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>numbers_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>args</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由於基類Base的析構函數沒有聲明為virtual，當對象被銷毀時，只會調用基類的析構函數，不會調用派生類Sub的析構函數，導致內存泄漏。
例外：
NoCopyable、NoMovable這種沒有任何行為，僅僅用來做標識符的類，可以不定義虛析構也不定義final。</p><h3 id=規則722-禁止虛函數使用缺省參數值><a name=r7-2-2></a>規則7.2.2 禁止虛函數使用缺省參數值</h3><p>說明：在C++中，虛函數是動態綁定的，但函數的缺省參數卻是在編譯時就靜態綁定的。這意味著你最終執行的函數是一個定義在派生類，但使用了基類中的缺省參數值的虛函數。為了避免虛函數重載時，因參數聲明不一致給使用者帶來的困惑和由此導致的問題，規定所有虛函數均不允許聲明缺省參數值。
示例：虛函數display缺省參數值text是由編譯時刻決定的，而非運行時刻，沒有達到多態的目的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Base!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span>  <span class=o>=</span> <span class=s>&#34;Sub!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Sub</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>  <span class=c1>// 程序輸出結果: Base! 而期望輸出：Sub!
</span></span></span><span class=line><span class=cl>    <span class=n>sub</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>   <span class=c1>// 程序輸出結果: Sub!
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=規則723-禁止重新定義繼承而來的非虛函數><a name=r7-2-3></a>規則7.2.3 禁止重新定義繼承而來的非虛函數</h3><p>說明：因為非虛函數無法實現動態綁定，只有虛函數才能實現動態綁定：只要操作基類的指針，即可獲得正確的結果。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>                    
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sub</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>    <span class=c1>// 調用子類的Fun                 
</span></span></span><span class=line><span class=cl><span class=n>base</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>   <span class=c1>// 調用父類的Fun
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><h2 id=多重繼承><a name=c7-3></a>多重繼承</h2><p>在實際開發過程中使用多重繼承的場景是比較少的，因為多重繼承使用過程中有下面的典型問題：</p><ol><li>菱形繼承所帶來的數據重復，以及名字二義性。因此，C++引入了virtual繼承來解決這類問題;</li><li>即便不是菱形繼承，多個父類之間的名字也可能存在衝突，從而導致的二義性;</li><li>如果子類需要擴展或改寫多個父類的方法時，造成子類的職責不明，語義混亂;</li><li>相對於委托，繼承是一種白盒復用，即子類可以訪問父類的protected成員, 這會導致更強的耦合。而多重繼承，由於耦合了多個父類，相對於單根繼承，這會產生更強的耦合關係。</li></ol><p>多重繼承具有下面的優點：
多重繼承提供了一種更簡單的組合來實現多種接口或者類的組裝與復用。</p><p>所以，對於多重繼承的只有下面幾種情況下面才允許使用多重繼承。</p><h3 id=建議731-使用多重繼承來實現接口分離與多角色組合><a name=a7-3-1></a>建議7.3.1 使用多重繼承來實現接口分離與多角色組合</h3><p>如果某個類需要實現多重接口，可以通過多重繼承把多個分離的接口組合起來，類似 scala 語言的 traits 混入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role1</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role2</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role3</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object1</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role1</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role2</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在C++標準庫中也有類似的實現樣例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_istream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_ostream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_iostream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>basic_istream</span><span class=p>,</span> <span class=k>public</span> <span class=n>basic_ostream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=重載><a name=c7-4></a>重載</h2><p>重載操作符要有充分理由,而且不要改變操作符原有語義，例如不要使用 ‘+’ 操作符來做減運算。
操作符重載令代碼更加直觀，但也有一些不足：</p><ul><li>混淆直覺，誤以為該操作和內建類型一樣是高性能的，忽略了性能降低的可能；</li><li>問題定位時不夠直觀，按函數名查找比按操作符顯然更方便。</li><li>重載操作符如果行為定義不直觀(例如將‘+’ 操作符來做減運算)，會讓代碼產生混淆。</li><li>賦值操作符的重載引入的隱式轉換會隱藏很深的bug。可以定義類似Equals()、CopyFrom()等函數來替代=,==操作符。</li></ul><h1 id=8-函數><a name=c8></a>8 函數</h1><h2 id=函數設計><a name=c8-1></a>函數設計</h2><h3 id=規則811-避免函數過長函數不超過50行非空非注釋><a name=r8-1-1></a>規則8.1.1 避免函數過長，函數不超過50行（非空非注釋）</h3><p>函數應該可以一屏顯示完 (50行以內)，只做一件事情，而且把它做好。</p><p>過長的函數往往意味著函數功能不單一，過於復雜，或過分呈現細節，未進行進一步抽象。</p><p>例外：某些實現算法的函數，由於算法的聚合性與功能的全面性，可能會超過50行。</p><p>即使一個長函數現在工作的非常好, 一旦有人對其修改, 有可能出現新的問題, 甚至導致難以發現的bug。
建議將其拆分為更加簡短並易於管理的若干函數，以便於他人閱讀和修改代碼。</p><h2 id=內聯函數><a name=c8-2></a>內聯函數</h2><h3 id=建議821-內聯函數不超過10行非空非注釋><a name=a8-2-1></a>建議8.2.1 內聯函數不超過10行（非空非注釋）</h3><p><strong>說明</strong>：內聯函數具有一般函數的特性，它與一般函數不同之處只在於函數調用的處理。一般函數進行調用時，要將程序執行權轉到被調用函數中，然後再返回到調用它的函數中；而內聯函數在調用時，是將調用表達式用內聯函數體來替換。</p><p>內聯函數只適合於只有 1~10 行的小函數。對一個含有許多語句的大函數，函數調用和返回的開銷相對來說微不足道，也沒有必要用內聯函數實現，一般的編譯器會放棄內聯方式，而采用普通的方式調用函數。</p><p>如果內聯函數包含復雜的控制結構，如循環、分支(switch)、try-catch 等語句，一般編譯器將該函數視同普通函數。
<strong>虛函數、遞歸函數不能被用來做內聯函數</strong>。</p><h2 id=函數參數><a name=c8-3></a>函數參數</h2><h3 id=建議831-函數參數使用引用取代指針><a name=a8-3-1></a>建議8.3.1 函數參數使用引用取代指針</h3><p><strong>說明</strong>：引用比指針更安全，因為它一定非空，且一定不再指向其他目標；引用不需要檢查非法的NULL指針。</p><p>如果是基於老平台開發的產品，則優先順從原有平台的處理方式。
選擇 const 避免參數被修改，讓代碼閱讀者清晰地知道該參數不被修改，可大大增強代碼可讀性。</p><p>例外：當傳入參數為編譯期長度未知的數組時，可以使用指針而不是引用。</p><h3 id=建議832-使用強類型參數避免使用void><a name=a8-3-2></a>建議8.3.2 使用強類型參數，避免使用void*</h3><p>儘管不同的語言對待強類型和弱類型有自己的觀點，但是一般認為c/c++是強類型語言，既然我們使用的語言是強類型的，就應該保持這樣的風格。
好處是盡量讓編譯器在編譯階段就檢查出類型不匹配的問題。</p><p>使用強類型便於編譯器幫我們發現錯誤，如下代碼中注意函數 FooListAddNode 的使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FooNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BarNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FooListAddNode</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span> <span class=c1>// Bad: 這裡用 void * 類型傳遞參數
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=p>(</span><span class=n>FooNode</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAppend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_FooList</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>foo</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MakeTheList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BarNode</span> <span class=o>*</span><span class=n>bar</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FooListAddNode</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span>        <span class=c1>// Wrong: 這裡本意是想傳遞參數 foo，但錯傳了 bar，卻沒有報錯
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>可以使用模板函數來實現參數類型的變化。</li><li>可以使用基類指針來實現多態。</li></ol><h3 id=建議833-函數的參數個數不超過5個><a name=a8-3-3></a>建議8.3.3 函數的參數個數不超過5個</h3><p>函數的參數過多，會使得該函數易於受外部變化的影响，從而影響維護工作。函數的參數過多同時也會增大測試的工作量。</p><p>如果超過可以考慮:</p><ul><li>看能否拆分函數</li><li>看能否將相關參數合在一起，定義結構體</li></ul><h1 id=9-c其他特性><a name=c9></a>9 C++其他特性</h1><h2 id=常量與初始化><a name=c9-1></a>常量與初始化</h2><p>不變的值更易於理解、跟蹤和分析，所以應該盡可能地使用常量代替變量，定義值的時候，應該把const作為默認的選項。</p><h3 id=規則911-不允許使用宏來表示常量><a name=r9-1-1></a>規則9.1.1 不允許使用宏來表示常量</h3><p><strong>說明</strong>：宏是簡單的文本替換，在預處理階段時完成，運行報錯時直接報相應的值；跟蹤調試時也是顯示值，而不是宏名；宏沒有類型檢查，不安全；宏沒有作用域。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_MSISDN_LEN 20    </span><span class=c1>// 不好
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++請使用const常量
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 好
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 對於C++11以上版本，可以使用constexpr
</span></span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=建議911-一組相關的整型常量應定義為枚舉><a name=a9-1-1></a>建議9.1.1 一組相關的整型常量應定義為枚舉</h3><p><strong>說明</strong>：枚舉比<code>#define</code>或<code>const int</code>更安全。編譯器會檢查參數值是否位於枚舉取值範圍內，避免錯誤發生。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Week</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUNDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MONDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TUESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WEDNESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>THURSDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FRIDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SATURDAY</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLACK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=n>Week</span> <span class=n>today</span><span class=p>,</span> <span class=n>Color</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 編譯報錯，參數類型錯誤
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不好的例子:
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SUNDAY</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MONDAY</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLACK</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLUE</span>   <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=kt>int</span> <span class=n>today</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 不會報錯
</span></span></span></code></pre></div><p>當枚舉值需要對應到具體數值時，須在聲明時顯式賦值。否則不需要顯式賦值，以避免重復賦值，降低維護(增加、刪除成員)工作量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：S協議裡定義的設備ID值，用於標識設備類型
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>DeviceType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_UNKNOWN</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_DSMP</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_ISMG</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_WAPPORTAL</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>程序內部使用，僅用於分類的情況，不應該進行顯式的賦值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：程序中用來標識會話狀態的枚舉定義
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>SessionState</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INIT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WAITING_FOR_RESPONSE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>應當盡量避免枚舉值重復，如必須重復也要用已定義的枚舉來修飾</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RTCPType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SR</span> <span class=o>=</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MIN_TYPE</span> <span class=o>=</span> <span class=n>RTCP_SR</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RR</span>    <span class=o>=</span> <span class=mi>201</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SDES</span>  <span class=o>=</span> <span class=mi>202</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_BYE</span>   <span class=o>=</span> <span class=mi>203</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_APP</span>   <span class=o>=</span> <span class=mi>204</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RTPFB</span> <span class=o>=</span> <span class=mi>205</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PSFB</span>  <span class=o>=</span> <span class=mi>206</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_XR</span>  <span class=o>=</span> <span class=mi>207</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RSI</span> <span class=o>=</span> <span class=mi>208</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PUBPORTS</span> <span class=o>=</span> <span class=mi>209</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MAX_TYPE</span> <span class=o>=</span> <span class=n>RTCP_PUBPORTS</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=規則912-不允許使用魔鬼數字><a name=r9-1-2></a>規則9.1.2 不允許使用魔鬼數字</h3><p>所謂魔鬼數字即看不懂、難以理解的數字。</p><p>魔鬼數字並非一個非黑即白的概念，看不懂也有程度，需要自行判斷。
例如數字 12，在不同的上下文中情況是不一樣的：
type = 12; 就看不懂，但 <code>monthsCount = yearsCount * 12</code>; 就能看懂。
數字 0 有時候也是魔鬼數字，比如 <code>status = 0</code>; 並不能表達是什麼狀態。</p><p>解決途徑：
對於局部使用的數字，可以增加註釋說明
對於多處使用的數字，必須定義 const 常量，並通過符號命名自註釋。</p><p>禁止出現下列情況：
沒有通過符號來解釋數字含義，如<code> const int ZERO = 0</code>
符號命名限制了其取值，如 <code>const int XX_TIMER_INTERVAL_300MS = 300</code>，直接使用<code>XX_TIMER_INTERVAL_MS</code>來表示該常量是定時器的時間間隔。</p><h3 id=規則913-常量應該保證單一職責><a name=r9-1-3></a>規則9.1.3 常量應該保證單一職責</h3><p><strong>說明</strong>：一個常量只用來表示一個特定功能，即一個常量不能有多種用途。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：協議A和協議B，手機號(MSISDN)的長度都是20。
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>A_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>B_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 或者使用不同的名字空間：
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=規則914-禁止用memcpy_smemset_s初始化非pod對象><a name=r9-1-4></a>規則9.1.4 禁止用memcpy_s、memset_s初始化非POD對象</h3><p><strong>說明</strong>：<code>POD</code>全稱是<code>Plain Old Data</code>，是C++ 98標準(ISO/IEC 14882, first edition, 1998-09-01)中引入的一個概念，<code>POD</code>類型主要包括<code>int</code>, <code>char</code>, <code>float</code>，<code>double</code>，<code>enumeration</code>，<code>void</code>，指針等原始類型以及聚合類型，不能使用封裝和面向對象特性（如用戶定義的構造/賦值/析構函數、基類、虛函數等）。</p><p>由於非POD類型比如非聚合類型的class對象，可能存在虛函數，內存布局不確定，跟編譯器有關，濫用內存拷貝可能會導致嚴重的問題。</p><p>即使對聚合類型的class，使用直接的內存拷貝和比較，破壞了信息隱蔽和數據保護的作用，也不提倡<code>memcpy_s</code>、<code>memset_s</code>操作。</p><p>對於POD類型的詳細說明請參見附錄。</p><h3 id=建議912-變量使用時才聲明並初始化><a name=a9-1-2></a>建議9.1.2 變量使用時才聲明並初始化</h3><p><strong>說明</strong>：變量在使用前未賦初值，是常見的低級編程錯誤。使用前才聲明變量並同時初始化，非常方便地避免了此類低級錯誤。</p><p>在函數開始位置聲明所有變量，後面才使用變量，作用域覆蓋整個函數實現，容易導致如下問題：</p><ul><li>程序難以理解和維護：變量的定義與使用分離。</li><li>變量難以合理初始化：在函數開始時，經常沒有足夠的信息進行變量初始化，往往用某個默認的空值(比如零)來初始化，這通常是一種浪費，如果變量在被賦於有效值以前使用，還會導致錯誤。</li></ul><p>遵循變量作用域最小化原則與就近聲明原則， 使得代碼更容易閱讀,方便了解變量的類型和初始值。特別是，應使用初始化的方式替代聲明再賦值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子：聲明與初始化分離
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>        <span class=c1>// 聲明時未初始化：調用缺省構造函數
</span></span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>;</span>  <span class=c1>// 再次調用賦值操作符函數；聲明與定義在不同的地方，理解相對困難
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 好的例子：聲明與初始化一體，理解相對容易
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=nf>name</span><span class=p>(</span><span class=s>&#34;zhangsan&#34;</span><span class=p>);</span>  <span class=c1>// 調用構造函數
</span></span></span></code></pre></div><h2 id=表達式><a name=c9-2></a>表達式</h2><h3 id=規則921-含有變量自增或自減運算的表達式中禁止再次引用該變量><a name=r9-2-1></a>規則9.2.1 含有變量自增或自減運算的表達式中禁止再次引用該變量</h3><p>含有變量自增或自減運算的表達式中，如果再引用該變量，其結果在C++標準中未明確定義。各個編譯器或者同一個編譯器不同版本實現可能會不一致。
為了更好的可移植性，不應該對標準未定義的運算次序做任何假設。</p><p>注意，運算次序的問題不能使用括號來解決，因為這不是優先級的問題。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Bad: b[i]運算跟 i++，先後順序並不明確。
</span></span></span></code></pre></div><p>正確的寫法是將自增或自減運算單獨放一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 單獨一行
</span></span></span></code></pre></div><p>函數參數</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   <span class=c1>// Bad: 傳遞第2個參數時，不確定自增運算有沒有發生
</span></span></span></code></pre></div><p>正確的寫法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 單獨一行
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=規則922-switch語句要有default分支><a name=r9-2-2></a>規則9.2.2 switch語句要有default分支</h3><p>大部分情況下，switch語句中要有default分支，保證在遺漏case標簽處理時能夠有一個默認的處理行為。</p><p>特例：
如果switch條件變量是枚舉類型，並且 case 分支覆蓋了所有取值，則加上default處理分支有些多余。
現代編譯器都具備檢查是否在switch語句中遺漏了某些枚舉值的case分支的能力，會有相應的warning提示。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因為switch條件變量是枚舉值，這裡可以不用加default處理分支
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>RED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoRedThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>BLUE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoBlueThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=建議921-表達式的比較應當遵循左側傾向於變化右側傾向於不變的原則><a name=a9-2-1></a>建議9.2.1 表達式的比較，應當遵循左側傾向於變化、右側傾向於不變的原則</h3><p>當變量與常量比較時，如果常量放左邊，如 if (MAX == v) 不符合閱讀習慣，而 if (MAX > v) 更是難於理解。
應當按人的正常閱讀、表達習慣，將常量放右邊。寫成如下方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也有特殊情況，如：<code>if (MIN &lt; value && value &lt; MAX)</code> 用來描述區間時，前半段是常量在左的。</p><p>不用擔心將 &lsquo;==&rsquo; 誤寫成 &lsquo;=&rsquo;，因為<code> if (value = MAX)</code> 會有編譯告警，其他靜態檢查工具也會報錯。讓工具去解決筆誤問題，代碼要符合可讀性第一。</p><h3 id=建議922-使用括號明確操作符的優先級><a name=a9-2-2></a>建議9.2.2 使用括號明確操作符的優先級</h3><p>使用括號明確操作符的優先級，防止因默認的優先級與設計思想不符而導致程序出錯；同時使得代碼更為清晰可讀，然而過多的括號會分散代碼使其降低了可讀性。下面是如何使用括號的建議。</p><ul><li>二元及以上操作符, 如果涉及多種操作符，則應該使用括號</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>         <span class=cm>/* 操作符相同，可以不加括號 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>     <span class=cm>/* 逗號兩邊的表達式，不需要括號 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>      <span class=cm>/* 操作符不同，需要括號 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=p>(</span><span class=n>b</span> <span class=o>/</span> <span class=mi>5</span><span class=p>);</span>       <span class=cm>/* 操作符不同，需要括號 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=p>(</span><span class=n>a</span> <span class=err>–</span> <span class=n>b</span><span class=p>);</span>    <span class=cm>/* 操作符不同，需要括號 */</span>
</span></span></code></pre></div><h2 id=類型轉換><a name=c9-3></a>類型轉換</h2><p>避免使用類型分支來定制行為：類型分支來定制行為容易出錯，是企圖用C++編寫C代碼的明顯標志。這是一種很不靈活的技術，要添加新類型時，如果忘記修改所有分支，編譯器也不會告知。使用模板和虛函數，讓類型自己而不是調用它們的代碼來決定行為。</p><p>建議避免類型轉換，我們在代碼的類型設計上應該考慮到每種數據的數據類型是什麼，而不是應該過度使用類型轉換來解決問題。在設計某個基本類型的時候，請考慮：</p><ul><li>是無符號還是有符號的</li><li>是適合float還是double</li><li>是使用int8，int16，int32還是int64，確定整形的長度</li></ul><p>但是我們無法禁止使用類型轉換，因為C++語言是一門面向機器編程的語言，涉及到指針地址，並且我們會與各種第三方或者底層API交互，他們的類型設計不一定是合理的，在這個適配的過程中很容易出現類型轉換。</p><p>例外：在調用某個函數的時候，如果我們不想處理函數結果，首先要考慮這個是否是你的最好的選擇。如果確實不想處理函數的返回值，那麼可以使用(void)轉換來解決。</p><h3 id=規則931-如果確定要使用類型轉換請使用由c提供的類型轉換而不是c風格的類型轉換><a name=r9-3-1></a>規則9.3.1 如果確定要使用類型轉換，請使用由C++提供的類型轉換，而不是C風格的類型轉換</h3><p><strong>說明</strong>：</p><p>C++提供的類型轉換操作比C風格更有針對性，更易讀，也更加安全，C++提供的轉換有：</p><ul><li>類型轉換：</li></ul><ol><li><code>dynamic_cast</code>：主要用於繼承體系下行轉換，<code>dynamic_cast</code>具有類型檢查的功能，請做好基類和派生類的設計，避免使用dynamic_cast來進行轉換。</li><li><code>static_cast</code>：和C風格轉換相似可做值的強制轉換，或上行轉換(把派生類的指針或引用轉換成基類的指針或引用)。該轉換經常用於消除多重繼承帶來的類型歧義，是相對安全的。如果是純粹的算數轉換，那麼請使用後面的大括號轉換方式。</li><li><code>reinterpret_cast</code>：用於轉換不相關類型。<code>reinterpret_cast</code>強制編譯器將某個類型對象的內存重新解釋成另一種類型，這是一種不安全的轉換，建議盡可能少用<code>reinterpret_cast</code>。</li><li><code>const_cast</code>：用於移除對象的<code>const</code>屬性，使對象變得可修改，這樣會破壞數據的不變性，建議盡可能少用。</li></ol><ul><li>算數轉換： （C++11開始支持）
對於那種算數轉換，並且類型信息沒有丟失的，比如float到double， int32到int64的轉換，推薦使用大括號的初始方式。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=n>someFloat</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>i</span><span class=p>{</span> <span class=n>someInt32</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=建議931-避免使用dynamic_cast><a name=a9-3-1></a>建議9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依賴於C++的RTTI， 讓程序員在運行時識別C++類對象的類型。</li><li><code>dynamic_cast</code>的出現一般說明我們的基類和派生類設計出現了問題，派生類破壞了基類的契約，不得不通過<code>dynamic_cast</code>轉換到子類進行特殊處理，這個時候更希望來改善類的設計，而不是通過<code>dynamic_cast</code>來解決問題。</li></ol><h3 id=建議932-避免使用reinterpret_cast><a name=a9-3-2></a>建議9.3.2 避免使用<code>reinterpret_cast</code></h3><p><strong>說明</strong>：<code>reinterpret_cast</code>用於轉換不相關類型。嘗試用<code>reinterpret_cast</code>將一種類型強制轉換另一種類型，這破壞了類型的安全性與可靠性，是一種不安全的轉換。不同類型之間盡量避免轉換。</p><h3 id=建議933-避免使用const_cast><a name=a9-3-3></a>建議9.3.3 避免使用<code>const_cast</code></h3><p><strong>說明</strong>：<code>const_cast</code>用於移除對象的<code>const</code>和<code>volatile</code>性質。</p><p>使用const_cast轉換後的指針或者引用來修改const對象，行為是未定義的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>2048</span><span class=p>;</span>      <span class=c1>// 未定義行為
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>  <span class=c1>// 未定義行為
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=資源分配和釋放><a name=c9-4></a>資源分配和釋放</h2><h3 id=規則941-單個對象釋放使用delete數組對象釋放使用delete-><a name=r9-4-1></a>規則9.4.1 單個對象釋放使用delete，數組對象釋放使用delete []</h3><p>說明：單個對象刪除使用delete， 數組對象刪除使用delete []，原因：</p><ul><li>調用new所包含的動作：從系統中申請一塊內存，並調用此類型的構造函數。</li><li>調用new[n]所包含的動作：申請可容納n個對象的內存，並且對每一個對象調用其構造函數。</li><li>調用delete所包含的動作：先調用相應的析構函數，再將內存歸還系統。</li><li>調用delete[]所包含的動作：對每一個對象調用析構函數，再釋放所有內存</li></ul><p>如果new和delete的格式不匹配，結果是未知的。對於非class類型， new和delete不會調用構造與析構函數。</p><p>錯誤寫法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>正確寫法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=建議941-使用-raii-特性來幫助追蹤動態分配><a name=a9-4-1></a>建議9.4.1 使用 RAII 特性來幫助追蹤動態分配</h3><p>說明：RAII是“資源獲取就是初始化”的縮語(Resource Acquisition Is Initialization)，是一種利用對象生命周期來控制程序資源(如內存、文件句柄、網絡連接、互斥量等等)的簡單技術。</p><p>RAII 的一般做法是這樣的：在對象構造時獲取資源，接著控制對資源的訪問使之在對象的生命週期內始終保持有效，最後在對象析構的時候釋放資源。這種做法有兩大好處：</p><ul><li>我們不需要顯式地釋放資源。</li><li>對象所需的資源在其生命週期內始終保持有效。這樣，就不必檢查資源有效性的问题，可以簡化邏輯、提高效率。</li></ul><p>示例：使用RAII不需要顯式地釋放互斥資源。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockGuard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span><span class=p>(</span><span class=k>const</span> <span class=n>LockType</span><span class=o>&amp;</span> <span class=n>lockType</span><span class=p>)</span><span class=o>:</span> <span class=n>lock_</span><span class=p>(</span><span class=n>lockType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Acquire</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>LockGuard</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockType</span> <span class=n>lock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span> <span class=n>lockGuard</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 操作數據
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=標準庫><a name=c9-5></a>標準庫</h2><p>STL標準模板庫在不同產品使用程度不同，這裡列出一些基本規則和建議，供各團隊參考。</p><h3 id=規則951-不要保存stdstring的c_str返回的指針><a name=r9-5-1></a>規則9.5.1 不要保存std::string的c_str()返回的指針</h3><p>說明：在C++標準中並未規定string::c_str()指針持久有效，因此特定STL實現完全可以在調用string::c_str()時返回一個臨時存儲區並很快釋放。所以為了保證程序的可移植性，不要保存string::c_str()的結果，而是在每次需要時直接調用。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>  <span class=c1>// 表達式結束以後，name的生命週期還在，指針有效
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果中間調用了string的非const成員函數，導致string被修改，比如operator[], begin()等
</span></span></span><span class=line><span class=cl>    <span class=c1>// 可能會導致text的內容不可用，或者不是原來的字符串
</span></span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;2&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 後續使用text指針，其字符串內容不再是&#34;demo&#34;
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=p>(</span><span class=n>name</span> <span class=o>+</span> <span class=n>test</span><span class=p>).</span><span class=n>c_str</span><span class=p>();</span> <span class=c1>// 表達式結束以後，+號產生的臨時對象被銷毀，指針無效
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 後續使用text指針，其已不再指向合法內存空間
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例外：在少數對性能要求非常高的代碼中，為了適配已有的只接受const char*類型入參的函數，可以臨時保存string::c_str()返回的指針。但是必須嚴格保證string對象的生命週期長於所保存指針的生命週期，並且保證在所保存指針的生命週期內，string對象不會被修改。</p><h3 id=建議951-使用stdstring代替char><a name=a9-5-1></a>建議9.5.1 使用std::string代替char*</h3><p>說明：使用string代替<code>char*</code>有很多優勢，比如：</p><ol><li>不用考慮結尾的’\0’；</li><li>可以直接使用+, =, ==等運算符以及其它字符串操作函數；</li><li>不需要考慮內存分配操作，避免了顯式的new/delete，以及由此導致的錯誤；</li></ol><p>需要注意的是某些stl實現中string是基於寫時復制策略的，這會帶來2個問題，一是某些版本的寫時復制策略沒有實現線程安全，在多線程環境下會引起程序崩潰；二是當與動態鏈接庫相互傳遞基於寫時復制策略的string時，由於引用計數在動態鏈接庫被卸載時無法減少可能導致懸掛指針。因此，慎重選擇一個可靠的stl實現對於保證程序穩定是很重要的。</p><p>例外：
當調用系統或者其它第三方庫的API時，針對已經定義好的接口，只能使用<code>char*</code>。但是在調用接口之前都可以使用string，在調用接口時使用string::c_str()獲得字符指針。
當在棧上分配字符數組當作緩衝區使用時，可以直接定義字符數組，不要使用string，也沒有必要使用類似<code>vector&lt;char></code>等容器。</p><h3 id=規則952-禁止使用auto_ptr><a name=r9-5-2></a>規則9.5.2 禁止使用auto_ptr</h3><p>說明：在stl庫中的std::auto_ptr具有一個隱式的所有權轉移行為，如下代碼：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span>
</span></span></code></pre></div><p>當執行完第2行語句後，p1已經不再指向第1行中分配的對象，而是變為nullptr。正因為如此，auto_ptr不能被置於各種標準容器中。
轉移所有權的行為通常不是期望的結果。對於必須轉移所有權的場景，也不應該使用隱式轉移的方式。這往往需要程序員對使用auto_ptr的代碼保持額外的謹慎，否則出現對空指針的訪問。
使用auto_ptr常見的有兩種場景，一是作為智能指針傳遞到產生auto_ptr的函數外部，二是使用auto_ptr作為RAII管理類，在超出auto_ptr的生命週期時自動釋放資源。
對於第1種場景，可以使用std::shared_ptr來代替。
對於第2種場景，可以使用C++11標準中的std::unique_ptr來代替。其中std::unique_ptr是std::auto_ptr的代替品，支持顯式的所有權轉移。</p><p>例外：
在C++11標準得到普遍使用之前，在一定需要對所有權進行轉移的場景下，可以使用std::auto_ptr，但是建議對std::auto_ptr進行封裝，並禁用封裝類的拷貝構造函數和賦值運算符，以使該封裝類無法用於標準容器。</p><h3 id=建議952-使用新的標準頭文件><a name=a9-5-2></a>建議9.5.2 使用新的標準頭文件</h3><p>說明：
使用C++的標準頭文件時，請使用<code>&lt;cstdlib></code>這樣的，而不是<code>&lt;stdlib.h></code>這種的。</p><h2 id=const的用法><a name=c9-6></a>const的用法</h2><p>在聲明的變量或參數前加上關鍵字 const 用於指明變量值不可被篡改 (如 <code>const int foo</code> ). 為類中的函數加上 const 限定符表明該函數不會修改類成員變量的狀態 (如 <code>class Foo { int Bar(char c) const; };</code>)。 const 變量, 數據成員, 函數和參數為編譯時類型檢測增加了一層保障， 便於盡早發現錯誤。因此, 我們強烈建議在任何可能的情況下使用 const。
有時候，使用C++11的constexpr來定義真正的常量可能更好。</p><h3 id=規則961-對於指針和引用類型的形參如果是不需要修改的請使用const><a name=r9-6-1></a>規則9.6.1 對於指針和引用類型的形參，如果是不需要修改的，請使用const</h3><p>不變的值更易於理解/跟蹤和分析，把const作為默認選項，在編譯時會對其進行檢查，使代碼更牢固/更安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PrintFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=規則962-對於不會修改成員變量的成員函數請使用const修飾><a name=r9-6-2></a>規則9.6.2 對於不會修改成員變量的成員函數請使用const修飾</h3><p>盡可能將成員函數聲明為 const。 訪問函數應該總是 const。只要不修改數據成員的成員函數，都聲明為const。
對於虛函數，應當從設計意圖上考慮繼承鏈上的所有類是否需要在此虛函數中修改數據成員，而不是僅關注單個類的實現。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>PrintValue</span><span class=p>()</span> <span class=k>const</span> <span class=c1>// const修飾成員函數，不會修改成員變量
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetValue</span><span class=p>()</span> <span class=k>const</span>  <span class=c1>// const修飾成員函數，不會修改成員變量
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=建議961-初始化後再也不會修改的成員變量定義為const><a name=a9-6-1></a>建議9.6.1 初始化後再也不會修改的成員變量定義為const</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span> <span class=n>dataLength_</span><span class=p>(</span><span class=n>length</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>dataLength_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=異常><a name=c9-7></a>異常</h2><h3 id=建議971-c11中如果函數不會拋出異常聲明為noexcept><a name=a9-7-1></a>建議9.7.1 C++11中，如果函數不會拋出異常，聲明為<code>noexcept</code></h3><p><strong>理由</strong></p><ol><li>如果函數不會拋出異常，聲明為<code>noexcept</code>可以讓編譯器最大程度的優化函數，如減少執行路徑，提高錯誤退出的效率。</li><li><code>vector</code>等STL容器，為了保證接口的健壯性，如果保存元素的<code>move運算符</code>沒有聲明為<code>noexcept</code>，則在容器擴張搬移元素時不會使用<code>move機制</code>，而使用<code>copy機制</code>，帶來性能損失的風險。如果一個函數不能拋出異常，或者一個程序並沒有截獲某個函數所拋出的異常並進行處理，那麼這個函數可以用新的<code>noexcept</code>關鍵字對其進行修飾，表示這個函數不會拋出異常或者拋出的異常不會被截獲並處理。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>double</span> <span class=n>sqrt</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>  <span class=c1>// 永遠不會拋出異常
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 即使可能拋出異常，也可以使用 noexcept
</span></span></span><span class=line><span class=cl><span class=c1>// 這裡不準備處理內存耗盡的異常，簡單地將函數聲明為noexcept
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>MyComputation</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>noexcept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>    <span class=c1>// 可能會拋出異常
</span></span></span><span class=line><span class=cl>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>   <span class=c1>// 最大的優化
</span></span></span><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>);</span>            <span class=c1>// 更少的優化
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// std::vector 的 move 操作需要聲明 noexcept
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo1</span><span class=p>(</span><span class=n>Foo1</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>);</span>  <span class=c1>// no noexcept
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo1</span><span class=o>&gt;</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>  <span class=c1>// 觸發容器擴張，搬移已有元素時調用copy constructor
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo2</span><span class=p>(</span><span class=n>Foo2</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo2</span><span class=o>&gt;</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>  <span class=c1>// 觸發容器擴張，搬移已有元素時調用move constructor
</span></span></span></code></pre></div><p><strong>注意</strong>
默認構造函數、析構函數、<code>swap</code>函數，<code>move操作符</code>都不應該拋出異常。</p><h2 id=模板與泛型編程><a name=c9-8></a>模板與泛型編程</h2><h3 id=規則981-禁止在openharmony項目中進行泛型編程><a name=a9-8-1></a>規則9.8.1 禁止在OpenHarmony項目中進行泛型編程</h3><p>泛型編程和面向對象編程的思想、理念以及技巧完全不同，OpenHarmony項目主流使用面向對象的思想。</p><p>C++提供了強大的泛型編程的機制，能夠實現非常靈活簡潔的類型安全的接口，實現類型不同但是行為相同的代碼復用。</p><p>但是C++泛型編程存在以下缺點：</p><ol><li>對泛型編程不很熟練的人，常常會將面向對象的邏輯寫成模板、將不依賴模板參數的成員寫在模板中等等導致邏輯混亂代碼膨脹諸多問題。</li><li>模板編程所使用的技巧對於使用c++不是很熟練的人是比較晦澀難懂的。在復雜的地方使用模板的代碼讓人更不容易讀懂，並且debug 和維護起來都很麻煩。</li><li>模板如果使用不當，會導致運行時代碼過度膨脹。</li><li>模板代碼難以修改和重構。模板的代碼會在很多上下文裡面擴展開來, 所以很難確認重構對所有的這些展開的代碼有用。</li></ol><p>所以，OpenHarmony大部分部件禁止模板編程，僅有 <strong>少數部件</strong> 可以使用泛型編程，並且開發的模板要有詳細的註釋。
例外：</p><ol><li>stl適配層可以使用模板</li></ol><h2 id=宏><a name=c9-9></a>宏</h2><p>在C++語言中，我們強烈建議盡可能少使用復雜的宏</p><ul><li>對於常量定義，請按照前面章節所述，使用const或者枚舉；</li><li>對於宏函數，盡可能簡單，並且遵循下面的原則，並且優先使用內聯函數，模板函數等進行替換。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不推薦使用宏函數
</span></span></span><span class=line><span class=cl><span class=cp>#define SQUARE(a, b) ((a) * (b))
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 請使用模板函數，內聯函數等來替換。
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=n>Square</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><p>如果需要使用宏，請參考C語言規範的相關章節。
<strong>例外</strong>：一些通用且成熟的應用，如：對 new, delete 的封裝處理，可以保留對宏的使用。</p><h1 id=10-現代c特性><a name=c10></a>10 現代C++特性</h1><p>隨著 ISO 在2011年發布 C++11 語言標準，以及2017年3月發布 C++17 ，現代C++(C++11/14/17等)增加了大量提高編程效率、代碼質量的新語言特性和標準庫。
本章節描述了一些可以幫助團隊更有效率的使用現代C++，規避語言陷阱的指導意見。</p><h2 id=代碼簡潔性和安全性提升><a name=c10-1></a>代碼簡潔性和安全性提升</h2><h3 id=建議1011-合理使用auto><a name=a10-1-1></a>建議10.1.1 合理使用<code>auto</code></h3><p><strong>理由</strong></p><ul><li><code>auto</code>可以避免編寫冗長、重復的類型名，也可以保證定義變量時初始化。</li><li><code>auto</code>類型推導規則復雜，需要仔細理解。</li><li>如果能夠使代碼更清晰，繼續使用明確的類型，且只在局部變量使用<code>auto</code>。</li></ul><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 避免冗長的類型名
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 避免重復類型名
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 保證初始化
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// 編譯正確，沒有初始化
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>x</span><span class=p>;</span>   <span class=c1>// 編譯失敗，必須初始化
</span></span></span></code></pre></div><p>auto 的類型推導可能導致困惑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>           <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>ca</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>    <span class=c1>// const int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>   <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>aa</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>         <span class=c1>// int, 忽略 const 和 reference
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila1</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>   <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila2</span><span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>      <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura1</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>      <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura2</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>     <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura3</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>// int&amp;&amp;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>arr1</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>        <span class=c1>// const int*
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;</span> <span class=n>arr2</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>       <span class=c1>// const int(&amp;)[10]
</span></span></span></code></pre></div><p>如果沒有注意 <code>auto</code> 類型推導時忽略引用，可能引入難以發現的性能問題:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>  <span class=c1>// auto 推導為 std::string，拷貝 v[0]
</span></span></span></code></pre></div><p>如果使用<code>auto</code>定義接口，如頭文件中的常量，可能因為開發人員修改了值，而導致類型發生變化。</p><h3 id=規則1011-在重寫虛函數時請使用override或final關鍵字><a name=r10-1-1></a>規則10.1.1 在重寫虛函數時請使用<code>override</code>或<code>final</code>關鍵字</h3><p><strong>理由</strong>
<code>override</code>和<code>final</code>關鍵字都能保證函數是虛函數，且重寫了基類的虛函數。如果子類函數與基類函數原型不一致，則產生編譯告警。<code>final</code>還保證虛函數不會再被子類重寫。</p><p>使用<code>override</code>或<code>final</code>關鍵字後，如果修改了基類虛函數原型，但忘記修改子類重寫的虛函數，在編譯期就可以發現。也可以避免有多個子類時，重寫虛函數的修改遺漏。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// 編譯失敗: Derived::Foo 和 Base::Foo 原型不一致，不是重寫
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 正確: Derived::Foo 重寫 Base::Foo
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=k>final</span><span class=p>;</span>   <span class=c1>// 正確: Derived::Foo(int) 重寫 Base::Foo(int)，且Derived的派生類不能再重寫此函數
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 編譯失敗: Base::Bar 不是虛函數
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>總結</strong></p><ol><li>基類首次定義虛函數，使用<code>virtual</code>關鍵字</li><li>子類重寫基類虛函數（包括析構函數），使用<code>override</code>或<code>final</code>關鍵字（但不要兩者一起使用），並且不使用<code>virtual</code>關鍵字</li><li>非虛函數，<code>virtual</code>、<code>override</code>和<code>final</code>都不使用</li></ol><h3 id=規則1012-使用delete關鍵字刪除函數><a name=r10-1-2></a>規則10.1.2 使用<code>delete</code>關鍵字刪除函數</h3><p><strong>理由</strong>
相比於將類成員函數聲明為<code>private</code>但不實現，<code>delete</code>關鍵字更明確，且適用範圍更廣。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 只看頭文件不知道拷貝構造是否被刪除
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 明確刪除拷貝賦值函數
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>delete</code>關鍵字還支持刪除非成員函數</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=規則1013-使用nullptr而不是null或0><a name=r10-1-3></a>規則10.1.3 使用<code>nullptr</code>，而不是<code>NULL</code>或<code>0</code></h3><p><strong>理由</strong>
長期以來，C++沒有一個代表空指針的關鍵字，這是一件很尷尬的事：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NULL ((void *)0)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// 錯誤: void* 不能自動轉換為 char*
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=p>(</span><span class=n>C</span><span class=o>::*</span><span class=n>pmf</span><span class=p>)()</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>C</span><span class=o>::</span><span class=n>Func</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pmf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 錯誤: void* 不能自動轉換為指向成員函數的指針
</span></span></span></code></pre></div><p>如果把<code>NULL</code>被定義為<code>0</code>或<code>0L</code>。可以解決上面的問題。</p><p>或者在需要空指針的地方直接使用<code>0</code>。但這引入另一個問題，代碼不清晰，特別是使用<code>auto</code>自動推導：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() 返回的是 指針 還是 整數?
</span></span></span><span class=line><span class=cl>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>0</code>字面上是<code>int</code>類型(<code>0L</code>是<code>long</code>)，所以<code>NULL</code>和<code>0</code>都不是指針類型。
當重載指針和整數類型的函數時，傳遞<code>NULL</code>或<code>0</code>都調用到整數類型重載的函數:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>      <span class=c1>// 調用 F(int)，而非 F(int*)
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>   <span class=c1>// 調用 F(int)，而非 F(int*)
</span></span></span></code></pre></div><p>另外，<code>sizeof(NULL) == sizeof(void*)</code>並不一定總是成立的，這也是一個潛在的風險。</p><p>總結： 直接使用<code>0</code>或<code>0L</code>，代碼不清晰，且無法做到類型安全；使用<code>NULL</code>無法做到類型安全。這些都是潛在的風險。</p><p><code>nullptr</code>的優勢不僅僅是在字面上代表了空指針，使代碼清晰，而且它不再是一個整數類型。</p><p><code>nullptr</code>是<code>std::nullptr_t</code>類型，而<code>std::nullptr_t</code>可以隱式的轉換為所有的原始指針類型，這使得<code>nullptr</code>可以表現成指向任意類型的空指針。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// 調用 F(int*)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() 返回的是 指針
</span></span></span><span class=line><span class=cl>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=規則1014-使用using而非typedef><a name=r10-1-4></a>規則10.1.4 使用<code>using</code>而非<code>typedef</code></h3><p>在<code>C++11</code>之前，可以通過<code>typedef</code>定義類型的別名。沒人願意多次重復<code>std::map&lt;uint32_t, std::vector&lt;int>></code>這樣的代碼。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>SomeType</span><span class=p>;</span>
</span></span></code></pre></div><p>類型的別名實際是對類型的封裝。而通過封裝，可以讓代碼更清晰，同時在很大程度上避免類型變化帶來的散彈式修改。
在<code>C++11</code>之後，提供<code>using</code>，實現<code>聲明別名(alias declarations)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>SomeType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>對比兩者的格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Type</span> <span class=n>Alias</span><span class=p>;</span>   <span class=c1>// Type 在前，還是 Alias 在前
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Alias</span> <span class=o>=</span> <span class=n>Type</span><span class=p>;</span>   <span class=c1>// 符合&#39;賦值&#39;的用法，容易理解，不易出錯
</span></span></span></code></pre></div><p>如果覺得這點還不足以切換到<code>using</code>，我們接著看看<code>模板別名(alias template)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 定義模板的別名，一行代碼
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyAllocatorVector</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>       <span class=c1>// 使用 using 定義的別名
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data_</span><span class=p>;</span>   <span class=c1>// 模板類中使用 using 定義的別名
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>而<code>typedef</code>不支持帶模板參數的別名，只能"曲線救國&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 通過模板包裝 typedef，需要實現一個模板類
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyAllocatorVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// 使用 typedef 定義的別名，多寫 ::type
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data_</span><span class=p>;</span>  <span class=c1>// 模板類中使用，除了 ::type，還需要加上 typename
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=規則1015-禁止使用stdmove操作const對象><a name=r10-1-5></a>規則10.1.5 禁止使用std::move操作const對象</h3><p>從字面上看，<code>std::move</code>的意思是要移動一個對象。而const對象是不允許修改的，自然也無法移動。因此用<code>std::move</code>操作const對象會給代碼閱讀者帶來困惑。
在實際功能上，<code>std::move</code>會把對象轉換成右值引用類型；對於const對象，會將其轉換成const的右值引用。由於極少有類型會定義以const右值引用為參數的移動構造函數和移動賦值操作符，因此代碼實際功能往往退化成了對象拷貝而不是對象移動，帶來了性能上的損失。</p><p><strong>錯誤示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>g_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>g_stringList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>myString</span> <span class=o>=</span> <span class=s>&#34;String content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>myString</span><span class=p>);</span> <span class=c1>// bad:並沒有移動myString，而是進行了復制
</span></span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=s>&#34;Another string content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_stringList</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>anotherString</span><span class=p>));</span>    <span class=c1>// bad:並沒有移動anotherString，而是進行了復制
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=智能指針><a name=c10-2></a>智能指針</h2><h3 id=規則1021-單例類的成員等所有權不會被多方持有的優先使用原始指針而不是智能指針><a name=r10-2-1></a>規則10.2.1 單例、類的成員等所有權不會被多方持有的優先使用原始指針而不是智能指針</h3><p><strong>理由</strong>
智能指針會自動釋放對象資源避免資源泄露，但會帶額外的資源開銷。如：智能指針自动生成的類、構造和析構的開銷、內存占用多等。</p><p>單例、類的成員等對象的所有權不會被多方持有的情況，僅在類析構中釋放資源即可。不應該使用智能指針增加額外的開銷。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>foo_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>foo_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>例外</strong></p><ol><li>返回創建的對象時，需要指針銷毀函數的可以使用智能指針。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>CreateUniqueUser</span><span class=p>()</span> <span class=c1>// 可使用unique_ptr保證對象的創建和釋放在同一runtime
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=o>::</span><span class=k>new</span> <span class=n>User</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>),</span> <span class=p>[](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>user</span><span class=o>-&gt;</span><span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>::</span><span class=k>delete</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>CreateSharedUser</span><span class=p>()</span> <span class=c1>// 可使用shared_ptr保證對象的創建和釋放在同一runtime中
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>.</span><span class=n>GetRefPtr</span><span class=p>(),</span> <span class=p>[</span><span class=n>ipcUser</span><span class=p>](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ipcUser</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>返回創建的對象且對象需要被多方引用時，可以使用shared_ptr。</li></ol><h3 id=規則1022-使用stdmake_unique而不是new創建unique_ptr><a name=r10-2-2></a>規則10.2.2 使用<code>std::make_unique</code>而不是<code>new</code>創建<code>unique_ptr</code></h3><p><strong>理由</strong></p><ol><li><code>make_unique</code>提供了更簡潔的創建方式</li><li>保證了復雜表達式的異常安全</li></ol><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好：兩次出現 MyClass，重復導致不一致風險
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 好：只出現一次 MyClass，不存在不一致的可能
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>重復出現類型可能導致非常嚴重的問題，且很難發現：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 編譯正確，但new和delete不配套
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=mi>10</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 非異常安全: 編譯器可能按如下順序計算參數:
</span></span></span><span class=line><span class=cl><span class=c1>// 1. 分配 Foo 的內存,
</span></span></span><span class=line><span class=cl><span class=c1>// 2. 構造 Foo,
</span></span></span><span class=line><span class=cl><span class=c1>// 3. 調用 Bar,
</span></span></span><span class=line><span class=cl><span class=c1>// 4. 構造 unique_ptr&lt;Foo&gt;.
</span></span></span><span class=line><span class=cl><span class=c1>// 如果 Bar 拋出異常, Foo 不會被銷毀，產生內存泄露。
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>()),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 異常安全: 調用函數不會被打斷.
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>例外</strong>
<code>std::make_unique</code>不支持自定義<code>deleter</code>。
在需要自定義<code>deleter</code>的場景，建議在自己的命名空間實現定制版本的<code>make_unique</code>。
使用<code>new</code>創建自定義<code>deleter</code>的<code>unique_ptr</code>是最後的選擇。</p><h3 id=規則1024-使用stdmake_shared而不是new創建shared_ptr><a name=r10-2-4></a>規則10.2.4 使用<code>std::make_shared</code>而不是<code>new</code>創建<code>shared_ptr</code></h3><p><strong>理由</strong>
使用<code>std::make_shared</code>除了類似<code>std::make_unique</code>一致性等原因外，還有性能的因素。
<code>std::shared_ptr</code>管理兩個實體：</p><ul><li>控制塊(存儲引用計數，<code>deleter</code>等)</li><li>管理對象</li></ul><p><code>std::make_shared</code>創建<code>std::shared_ptr</code>，會一次性在堆上分配足夠容納控制塊和管理對象的內存。而使用<code>std::shared_ptr&lt;MyClass>(new MyClass)</code>創建<code>std::shared_ptr</code>，除了<code>new MyClass</code>會觸發一次堆分配外，<code>std::shard_ptr</code>的構造函數還會觸發第二次堆分配，產生額外的開銷。</p><p><strong>例外</strong>
類似<code>std::make_unique</code>，<code>std::make_shared</code>不支持定制<code>deleter</code></p><h2 id=lambda><a name=c10-3></a>Lambda</h2><h3 id=建議1031-當函數不能工作時選擇使用lambda捕獲局部變量或編寫局部函數><a name=a10-3-1></a>建議10.3.1 當函數不能工作時選擇使用<code>lambda</code>(捕獲局部變量，或編寫局部函數)</h3><p><strong>理由</strong>
函數無法捕獲局部變量或在局部範圍內聲明；如果需要這些東西，盡可能選擇<code>lambda</code>，而不是手寫的<code>functor</code>。
另一方面，<code>lambda</code>和<code>functor</code>不會重載；如果需要重載，則使用函數。
如果<code>lambda</code>和函數都可以的場景，則優先使用函數；盡可能使用最簡單的工具。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 編寫一個只接受 int 或 string 的函數
</span></span></span><span class=line><span class=cl><span class=c1>// -- 重載是自然的選擇
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 需要捕獲局部狀態，或出現在語句或表達式範圍
</span></span></span><span class=line><span class=cl><span class=c1>// -- lambda 是自然的選擇
</span></span></span><span class=line><span class=cl><span class=p>[</span><span class=n>Response</span> <span class=n>interrupted</span> <span class=n>by</span> <span class=n>a</span> <span class=n>tool</span> <span class=n>use</span> <span class=n>result</span><span class=p>.</span> <span class=n>Only</span> <span class=n>one</span> <span class=n>tool</span> <span class=n>may</span> <span class=n>be</span> <span class=n>used</span> <span class=n>at</span> <span class=n>a</span> <span class=n>time</span> <span class=n>and</span> <span class=n>should</span> <span class=n>be</span> <span class=n>placed</span> <span class=n>at</span> <span class=n>the</span> <span class=n>end</span> <span class=n>of</span> <span class=n>the</span> <span class=n>message</span><span class=p>.]</span>
</span></span></code></pre></div><br><script src=https://giscus.app/client.js data-repo=jqknono/blog data-repo-id=R_kgDONOhENQ data-category=Announcements data-category-id=DIC_kwDONOhENc4CkQDB data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script><br><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a href=/zh-tw/blog/2024/06/28/%E9%9B%BB%E4%BF%A1ipv6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E5%BE%B5/ aria-label="上一頁 - 電信IPv6的一些特徵" class="btn btn-primary"><span class=me-1>←</span>上一頁</a></li><li><a href=/zh-tw/blog/2024/06/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%8B%E5%86%8A%E4%B8%AD%E6%8B%AC%E8%99%9F%E7%9A%84%E5%90%AB%E7%BE%A9/ aria-label="下一頁 - 命令行手冊中括號的含義" class="btn btn-primary">下一頁<span class=ms-1>→</span></a></li></ul></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/jqknono aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2015&ndash;2026
<span class=td-footer__authors>jqknono</span></span><span class=td-footer__all_rights_reserved>保留所有權利</span></div></div></div></footer></div><script src=/js/main.min.70d2ef91374ec2569b2dc1ee9e7569822c0339dc6ba611092d40f6935e5c601a.js integrity="sha256-cNLvkTdOwlabLcHunnVpgiwDOdxrphEJLUD2k15cYBo=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>