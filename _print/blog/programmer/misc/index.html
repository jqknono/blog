<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en-us class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://blog.jqknono.com/blog/programmer/misc/><link rel=alternate type=application/rss+xml href=https://blog.jqknono.com/blog/programmer/misc/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Chat | Nono Blogs</title><meta name=description content="_index"><meta property="og:url" content="https://blog.jqknono.com/blog/programmer/misc/"><meta property="og:site_name" content="Nono Blogs"><meta property="og:title" content="Chat"><meta property="og:description" content="_index"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Chat"><meta itemprop=description content="_index"><meta itemprop=datePublished content="2024-06-28T19:00:37+08:00"><meta itemprop=dateModified content="2024-06-28T19:00:37+08:00"><meta itemprop=wordCount content="1"><meta itemprop=keywords content="Index,Chat"><meta name=twitter:card content="summary"><meta name=twitter:title content="Chat"><meta name=twitter:description content="_index"><link rel=preload href=/scss/main.min.0f2fa9571091c9ef7d3c35d7a3f7d09da4f49c5c7013a6ea9a0a80d216151751.css as=style integrity="sha256-Dy+pVxCRye99PDXXo/fQnaT0nFxwE6bqmgqA0hYVF1E=" crossorigin=anonymous><link href=/scss/main.min.0f2fa9571091c9ef7d3c35d7a3f7d09da4f49c5c7013a6ea9a0a80d216151751.css rel=stylesheet integrity="sha256-Dy+pVxCRye99PDXXo/fQnaT0nFxwE6bqmgqA0hYVF1E=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3FFTG72NE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3FFTG72NE")}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9457787069079604" crossorigin=anonymous></script></head><body class="td-section td-blog"><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Nono Blogs</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/docs/><i class='fas fa-book'></i><span>Docs</span></a></li><li class=nav-item><div class="td-lang-menu dropdown"><a class="nav-link dropdown-toggle td-lang-menu__title" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><span class=td-lang-menu__title-text>English</span>
<span class=td-lang-menu__title-code>EN-US</span></a><ul class=dropdown-menu><li><span class="dropdown-item active">English</span></li><li><a class=dropdown-item href=/zh-cn/blog/programmer/misc/>简体中文</a></li><li><span class="dropdown-item disabled">繁體中文</span></li><li><span class="dropdown-item disabled">日本語</span></li><li><span class="dropdown-item disabled">한국어</span></li><li><span class="dropdown-item disabled">العربية</span></li><li><span class="dropdown-item disabled">العربية</span></li><li><span class="dropdown-item disabled">Deutsch</span></li><li><span class="dropdown-item disabled">Español</span></li><li><span class="dropdown-item disabled">Français</span></li><li><span class="dropdown-item disabled">हिंदी</span></li><li><span class="dropdown-item disabled">Bahasa Indonesia</span></li><li><span class="dropdown-item disabled">Italiano</span></li><li><span class="dropdown-item disabled">Nederlands</span></li><li><span class="dropdown-item disabled">Polski</span></li><li><span class="dropdown-item disabled">Português</span></li><li><span class="dropdown-item disabled">Русский</span></li><li><span class="dropdown-item disabled">Türkçe</span></li></ul></div></li><li class=nav-item><div class="td-light-dark-menu dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown aria-label="Toggle theme (auto)">
<svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class=dropdown-menu aria-labelledby=bd-theme><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></div></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.e75c95a2035c0f6de97aadffbbc2017e.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/blog/programmer/misc/>Return to the regular view of this page</a>.</p></div><h1 class=title>Chat</h1><ul><li><a href=#pg-4715580aecd7f99d5f1d2596741fe673>Which Languages Are Best for Multilingual Projects</a></li><li><a href=#pg-b76987c1f943229523ed1e7b190953ce>Third-party Library Pitfalls</a></li><li><a href=#pg-b2075f5d67b31c9121400493c38d52c0>Design Specification Template</a></li><li><a href=#pg-9a83f3cf008d3b474647c108ce516035>Command Line Syntax Conventions</a></li><li><a href=#pg-0c87579cd7a3ba25ef5e14bf05e1c7e6>Meanings of brackets in man pages</a></li><li><a href=#pg-7ae20abfa23cd10f15a2834efe0cd517>Huawei C++ Coding Standards</a></li></ul><div class=content><ul><li><input disabled type=checkbox> _index</li></ul></div></div><div class=td-content><h1 id=pg-4715580aecd7f99d5f1d2596741fe673>Which Languages Are Best for Multilingual Projects</h1><div class="td-byline mb-4"><time datetime=2025-07-10 class=text-body-secondary>Thursday, July 10, 2025</time></div><p>Below are 15 countries/regions—selected based on population size, economic output, and international influence—together with their language codes (shortcodes) and brief rationales, intended as a reference for multilingual translation:</p><table><thead><tr><th>Country / Region</th><th>Shortcode</th><th>Brief Rationale</th></tr></thead><tbody><tr><td>United States</td><td>en-US</td><td>English is the global lingua franca; the U.S. has the world’s largest GDP (population: 333 million) and is a core market for international business and technology.</td></tr><tr><td>China</td><td>zh-CN</td><td>Most populous country (1.41 billion); 2nd-largest GDP; Chinese is a UN official language; Chinese market consumption potential is enormous.</td></tr><tr><td>Japan</td><td>ja-JP</td><td>Japanese is the official language of the world’s 5th-largest economy; leading in technology and manufacturing; population: 125 million with strong purchasing power.</td></tr><tr><td>Germany</td><td>de-DE</td><td>Core of the Eurozone economy; largest GDP in Europe; German wields significant influence within the EU; population: 83.2 million with a robust industrial base.</td></tr><tr><td>France</td><td>fr-FR</td><td>French is a UN official language; France has the 7th-largest GDP globally; population: 67.81 million; widely used in Africa and international organizations.</td></tr><tr><td>India</td><td>hi-IN</td><td>Hindi is one of India’s official languages; India’s population (1.4 billion) is the world’s 2nd-largest; 6th-largest GDP and among the fastest-growing major economies.</td></tr><tr><td>Spain</td><td>es-ES</td><td>Spanish has the 2nd-largest number of native speakers worldwide (548 million); Spain’s GDP is 4th in Europe, and Spanish is common throughout Latin America.</td></tr><tr><td>Brazil</td><td>pt-BR</td><td>Portuguese is the native language of Brazil (population: 214 million); Brazil is South America’s largest economy with the 9th-largest GDP globally.</td></tr><tr><td>South Korea</td><td>ko-KR</td><td>Korean corresponds to South Korea (population: 51.74 million); 10th-largest GDP globally; powerful in technology and cultural industries such as K-pop.</td></tr><tr><td>Russia</td><td>ru-RU</td><td>Russian is a UN official language; population: 146 million; GDP ranks 11th globally; widely spoken in Central Asia and Eastern Europe.</td></tr><tr><td>Italy</td><td>it-IT</td><td>Italy’s GDP is 3rd in Europe; population: 59.06 million; strong in tourism and luxury goods; Italian is an important EU language.</td></tr><tr><td>Indonesia</td><td>id-ID</td><td>Indonesian is the official language of the world’s largest archipelagic nation (population: 276 million) and the largest GDP in Southeast Asia, presenting a high market potential.</td></tr><tr><td>Turkey</td><td>tr-TR</td><td>Turkish is spoken by 85 million people; Turkey’s strategic position bridging Europe and Asia; GDP ranks 19th globally and exerts cultural influence in the Middle East and Central Asia.</td></tr><tr><td>Netherlands</td><td>nl-NL</td><td>Dutch is spoken in the Netherlands (population: 17.5 million); GDP ranks 17th globally; leading in trade and shipping; although English penetration is high, the local market still requires the native language.</td></tr><tr><td>United Arab Emirates</td><td>ar-AE</td><td>Arabic is central to the Middle East; the UAE is a Gulf economic hub (population: 9.5 million, 88 % expatriates) with well-developed oil and finance sectors, radiating influence across the Arab world.</td></tr></tbody></table><p>Notes:
Language codes follow the ISO 639-1 (language) + ISO 3166-1 (country) standards, facilitating adaptation to localization tools.<br>Priority has been given to countries with populations over 100 million, GDPs in the world’s top 20, and those with notable regional influence, balancing international applicability and market value.<br>For particular domains (e.g., the Latin American market can add es-MX (Mexico), Southeast Asia can add vi-VN (Vietnam)), the list can be further refined as needed.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b76987c1f943229523ed1e7b190953ce>Third-party Library Pitfalls</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Third-party library pitfalls</li></ul><p>Today we talked about a vulnerability in a recently released third-party logging library that can be exploited with minimal effort to execute remote commands. A logging library and remote command execution seem completely unrelated, yet over-engineered third-party libraries are everywhere.</p><p>The more code I read, the more I feel that a lot of open-source code is of very poor quality—regardless of how many k-stars it has. Stars represent needs, not engineering skill.</p><p>The advantage of open source is that more people contribute, allowing features to grow quickly, bugs to get fixed, and code to be reviewed. But skill levels vary wildly.</p><p>Without strong commit constraints, code quality is hard to guarantee.</p><p>The more code you add, the larger the attack surface.</p><p>Although reinventing the wheel is usually bad, product requirements are like a stroller wheel: a plastic wheel that never breaks. Attaching an airplane tire to it just adds attack surface and maintenance costs. So if all you need is a stroller wheel, don’t over-engineer.</p><p>Maintenance is expensive. Third-party libraries require dedicated processes and people to maintain them. Huawei once forked a test framework, and when we upgraded the compiler the test cases failed. Upgrading the test framework clashed with the compiler upgrade, so we burned ridiculous time making further invasive changes. As one of the people involved, I deeply felt the pain of forking third-party libraries. If the modifications were feature-worthy they could be upstreamed, but tailoring them to our own needs through intrusive customization makes future maintenance nearly impossible.</p><p>Huawei created a whole series of processes for third-party libraries—one could say the friction was enormous.</p><p>The bar is set very high: adding a library requires review by a level-18 expert and approval from a level-20 director. Only longtime, well-known libraries even have a chance.</p><p>All third-party libraries live under a thirdparty folder. A full build compares them byte-for-byte with the upstream repo; any invasive change is strictly forbidden.</p><p>Dedicated tooling tracks every library’s version, managed by outsourced staff. If a developer wants to upgrade a library, they must submit a formal request—and the director has to sign off.</p><p>Getting a director to handle something like that is hard. When a process is deliberately convoluted, its real message is “please don’t do this.”</p><p>Approach third-party libraries with skepticism—trust code written by your own team.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2075f5d67b31c9121400493c38d52c0>Design Specification Template</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Design Specification Template</li></ul><h1 id=detailed-design-of-xxx-system--sub-system>Detailed Design of XXX System / Sub-system</h1><table><thead><tr><th>System Name</th><th>XXX System</th></tr></thead><tbody><tr><td>Author</td><td>XXX</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>Submission Date</td><td>2021-06-30</td></tr></tbody></table><h2 id=revision-history>Revision History</h2><table><thead><tr><th>Revised Version</th><th>Change Description</th><th>Date of Change</th><th>Author</th></tr></thead><tbody><tr><td>v1.0</td><td>XXXXXXX</td><td>2021-06-30</td><td>XXX</td></tr><tr><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr></tbody></table><h2 id=technical-review-comments>Technical Review Comments</h2><table><thead><tr><th>No.</th><th>Reviewer</th><th>Review Comment (Pass/Fail/Pending, comments allowed)</th><th>Review Time</th></tr></thead><tbody><tr><td>1</td><td>XXX</td><td>Pass</td><td>2022.1.1</td></tr></tbody></table><h2 id=background>Background</h2><h2 id=glossary>Glossary</h2><ul><li>SIP: Session Initiation Protocol</li><li>RTP: Real-time Transport Protocol</li></ul><h2 id=design-objectives>Design Objectives</h2><h3 id=functional-requirements>Functional Requirements</h3><h3 id=non-functional-requirements-mandatory>Non-Functional Requirements (mandatory)</h3><h2 id=environment>Environment</h2><h3 id=related-software--hardware-optional>Related Software & Hardware (optional)</h3><h3 id=system-constraints>System Constraints</h3><h3 id=estimated-data-scale-mandatory>Estimated Data Scale (mandatory)</h3><h2 id=existing-solutions>Existing Solutions</h2><h2 id=design-ideas--trade-offs>Design Ideas & Trade-offs</h2><h3 id=assumptions--dependencies--relationships-with-other-systems>Assumptions & Dependencies / Relationships with Other Systems</h3><h2 id=system-design>System Design</h2><h3 id=overview>Overview</h3><h3 id=architecture-diagram--explanation>Architecture Diagram & Explanation</h3><h3 id=system-flow--explanation-optional>System Flow & Explanation (optional)</h3><h3 id=interfaces-with-external-systems>Interfaces with External Systems</h3><h3 id=global-data-structure-descriptions>Global Data-Structure Descriptions</h3><h3 id=brief-description-of-module-xxx1>Brief Description of Module XXX1</h3><h4 id=functionality-of-module-xxx1>Functionality of Module XXX1</h4><h4 id=interfaces-with-other-modules>Interfaces with Other Modules</h4><h3 id=brief-description-of-module-xxx2>Brief Description of Module XXX2</h3><h4 id=functionality-of-module-xxx2>Functionality of Module XXX2</h4><h4 id=interfaces-with-other-modules-1>Interfaces with Other Modules</h4><h2 id=threat-modeling>Threat Modeling</h2><h2 id=upgrade-impact-mandatory>Upgrade Impact (mandatory)</h2><h2 id=risk-assessment--impact-on-other-systems-optional>Risk Assessment & Impact on Other Systems (optional)</h2><h3 id=known-or-foreseeable-risks>Known or Foreseeable Risks</h3><h3 id=potential-impact-with-other-systemsmodules>Potential Impact with Other Systems/Modules</h3><h2 id=innovation-points-optional>Innovation Points (optional)</h2><h2 id=attachments--references>Attachments & References</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-9a83f3cf008d3b474647c108ce516035>Command Line Syntax Conventions</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Command line syntax conventions</li></ul><h2 id=references>References</h2><ul><li><a href="https://www.ibm.com/docs/en/iotdm/11.3?topic=interface-command-line-syntax">https://www.ibm.com/docs/en/iotdm/11.3?topic=interface-command-line-syntax</a></li><li><a href=https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key>https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key</a></li><li><a href=https://developers.google.com/style/code-syntax>https://developers.google.com/style/code-syntax</a></li><li><a href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01>https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01</a></li><li><a href=https://ftpdocs.broadcom.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/cl_cmd_line_syntax_char.htm>https://ftpdocs.broadcom.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/cl_cmd_line_syntax_char.htm</a></li></ul><p>e.g.</p><table><thead><tr><th>Notation</th><th>Description</th></tr></thead><tbody><tr><td>Text without brackets or braces</td><td>Items you must type as shown.</td></tr><tr><td><code>&lt;</code>Text inside angle brackets<code>></code></td><td>Placeholder for which you must supply a value.</td></tr><tr><td><code>[</code>Text inside square brackets<code>]</code></td><td>Optional items.</td></tr><tr><td><code>{</code>Text inside braces<code>}</code></td><td>Set of required items. You must choose one.</td></tr><tr><td>Vertical bar ( <code>|</code> )</td><td>Separator for mutually exclusive items. You must choose one.</td></tr><tr><td>Ellipsis (<code>…</code>)</td><td>Items that can be repeated and used multiple times.</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-0c87579cd7a3ba25ef5e14bf05e1c7e6>Meanings of brackets in man pages</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Meanings of brackets in man pages</li></ul><h1 id=meanings-of-brackets-in-man-pages>Meanings of brackets in man pages</h1><p>In command-line help, different types of brackets generally carry the following meanings:</p><ol><li>Angle brackets <code>&lt;></code>:<ul><li>Angle brackets denote required arguments—values you must provide when running the command. They’re typically used to express the core syntax and parameters of a command.</li><li>Example: <code>command &lt;filename></code> means you must supply a filename as a required argument, e.g., <code>command file.txt</code>.</li></ul></li><li>Square brackets <code>[]</code>:<ul><li>Square brackets indicate optional arguments—values you may or may not provide when running the command. They’re commonly used to mark optional parameters and options.</li><li>Example: <code>command [option]</code> means you can choose to provide an option, e.g., <code>command -v</code> or simply <code>command</code>.</li></ul></li><li>Curly braces <code>{}</code>:<ul><li>Curly braces usually represent a set of choices, indicating that you must select one. These are also called “choice parameter groups.”</li><li>Example: <code>command {option1 | option2 | option3}</code> means you must pick one of the given options, e.g., <code>command option2</code>.</li></ul></li><li>Parentheses <code>()</code>:<ul><li>Parentheses are generally used to group arguments, clarifying structure and precedence in a command’s syntax.</li><li>Example: <code>command (option1 | option2) filename</code> means you must choose either <code>option1</code> or <code>option2</code> and supply a filename as an argument, e.g., <code>command option1 file.txt</code>.</li></ul></li></ol><p>These bracket conventions are intended to help users understand command syntax and parameter choices so they can use command-line tools correctly. When reading man pages or help text, paying close attention to the meaning and purpose of each bracket type is crucial—it prevents incorrect commands and achieves the desired results.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7ae20abfa23cd10f15a2834efe0cd517>Huawei C++ Coding Standards</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Huawei C++ Coding Standards</li></ul><h1 id=c-language-coding-standards>C++ Language Coding Standards</h1><h2 id=purpose><a name=c0-1></a>Purpose</h2><p>Rules are not perfect; by prohibiting features useful in specific situations, they may impact code implementation. However, the purpose of establishing rules is “to benefit the majority of developers.” If, during team collaboration, a rule is deemed unenforceable, we hope to improve it together.</p><p>Before referencing this standard, it is assumed that you already possess the corresponding basic C++ language capabilities; do not rely on this document to learn the C++ language.</p><ol><li>Understand the C++ language ISO standard;</li><li>Be familiar with basic C++ language features, including those related to C++ 03/11/14/17;</li><li>Understand the C++ standard library;</li></ol><h2 id=general-principles><a name=c0-2></a>General Principles</h2><p>Code must, while ensuring functional correctness, meet the feature requirements of <strong>readability, maintainability, safety, reliability, testability, efficiency, and portability</strong>.</p><h2 id=key-focus-areas><a name=c0-2></a>Key Focus Areas</h2><ol><li>Define the C++ coding style, such as naming, formatting, etc.</li><li>C++ modular design—how to design header files, classes, interfaces, and functions.</li><li>Best practices for C++ language features, such as constants, type casting, resource management, templates, etc.</li><li>Modern C++ best practices, including conventions in C++11/14/17 that can improve maintainability and reliability.</li><li>This standard is primarily applicable to C++17.</li></ol><h2 id=conventions><a name=c0-3></a>Conventions</h2><p><strong>Rule</strong>: A convention that <strong>must</strong> be followed during programming (must).<br><strong>Recommendation</strong>: A convention that <strong>should</strong> be followed during programming (should).</p><p>This standard applies to common C++ standards; when no specific standard version is noted, it applies to all versions (C++03/11/14/17).</p><h2 id=exceptions><a name=c0-4></a>Exceptions</h2><p>Regardless of ‘Rule’ or ‘Recommendation’, you must understand the reasons behind each item and strive to follow them.<br>However, there may be exceptions to some rules and recommendations.</p><p>If it does not violate the general principles and, after thorough consideration, there are sufficient reasons, it is acceptable to deviate from the conventions in the specification.<br>Exceptions break code consistency—please avoid them. Exceptions to a ‘Rule’ should be extremely rare.</p><p>In the following situations, stylistic consistency should take priority:<br><strong>When modifying external open-source code or third-party code, follow the existing code style to maintain uniformity.</strong></p><h1 id=2-naming><a name=c2></a>2 Naming</h1><h2 id=general-naming><a name=c2-1></a>General Naming</h2><p><strong>CamelCase</strong><br>Mixed case letters with words connected. Words are separated by capitalizing the first letter of each word.<br>Depending on whether the first letter after concatenation is capitalized, it is further divided into UpperCamelCase and lowerCamelCase.</p><table><thead><tr><th>Type</th><th>Naming Style</th></tr></thead><tbody><tr><td>Type definitions such as classes, structs, enums, and unions, as well as scope names</td><td>UpperCamelCase</td></tr><tr><td>Functions (including global, scoped, and member functions)</td><td>UpperCamelCase</td></tr><tr><td>Global variables (including global and namespace-scoped variables, class static variables), local variables, function parameters, member variables of classes, structs, and unions</td><td>lowerCamelCase</td></tr><tr><td>Macros, constants (const), enum values, goto labels</td><td>ALL CAPS, underscore separator</td></tr></tbody></table><p>Notes:<br>The <strong>constant</strong> in the above table refers to variables at global scope, namespace scope, or static member scope that are basic data types, enums, or string types qualified with const or constexpr; arrays and other types of variables are excluded.<br>The <strong>variable</strong> in the above table refers to all variables other than the constant definition above, which should all use the lowerCamelCase style.</p><h2 id=file-naming><a name=c2-2></a>File Naming</h2><h3 id=rule-221-c-implementation-files-end-with-cpp-header-files-end-with-h><a name=r2-2-1></a>Rule 2.2.1 C++ implementation files end with .cpp, header files end with .h</h3><p>We recommend using .h as the header suffix so header files can be directly compatible with both C and C++.<br>We recommend using .cpp as the implementation file suffix to clearly distinguish C++ code from C code.</p><p>Some other suffixes used in the industry:</p><ul><li>Header files: .hh, .hpp, .hxx</li><li>cpp files: .cc, .cxx, .c</li></ul><p>If your project team already uses a specific suffix, you can continue using it, but please maintain stylistic consistency.<br>For this document, we default to .h and .cpp as suffixes.</p><h3 id=rule-222-c-file-names-correspond-to-the-class-name><a name=r2-2-2></a>Rule 2.2.2 C++ file names correspond to the class name</h3><p>C++ header and cpp file names should correspond to the class names in lowercase with underscores.</p><p>If a class is named DatabaseConnection, then the corresponding filenames should be:</p><ul><li>database_connection.h</li><li>database_connection.cpp</li></ul><p>File naming for structs, namespaces, enums, etc., follows a similar pattern.</p><h2 id=function-naming><a name=c2-3></a>Function Naming</h2><p>Function names use the UpperCamelCase style, usually a verb or verb-object structure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>AddElement</span><span class=p>(</span><span class=k>const</span> <span class=n>Element</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Element</span> <span class=nf>GetElement</span><span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteUser</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=type-naming><a name=c2-4></a>Type Naming</h2><p>Type names use the UpperCamelCase style.<br>All type names—classes, structs, unions, type aliases (typedef), and enums—use the same convention, e.g.:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// classes, structs and unions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>UrlTable</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTableTester</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UrlTableProperties</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>Packet</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedefs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>UrlTableProperties</span><span class=o>*&gt;</span> <span class=n>PropertiesMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// enums
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>UrlTableErrors</span> <span class=p>{</span> <span class=p>...</span>
</span></span></code></pre></div><p>For namespaces, UpperCamelCase is recommended:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// namespace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>OsUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FileUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=recommendation-241-avoid-misusing-typedef-or-define-to-alias-basic-types><a name=a2-4-1></a>Recommendation 2.4.1 Avoid misusing typedef or #define to alias basic types</h3><p>Do not redefine basic data types with typedef/#define unless there is a clear necessity.<br>Prefer using basic types from the <code>&lt;cstdint></code> header:</p><table><thead><tr><th>Signed Type</th><th>Unsigned Type</th><th>Description</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>Exactly 8-bit signed/unsigned integer</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>Exactly 16-bit signed/unsigned integer</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>Exactly 32-bit signed/unsigned integer</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>Exactly 64-bit signed/unsigned integer</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>Signed/unsigned integer to hold a pointer</td></tr></tbody></table><h2 id=variable-naming><a name=c2-5></a>Variable Naming</h2><p>General variables use lowerCamelCase, covering global variables, function parameters, local variables, and member variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tableName</span><span class=p>;</span>  <span class=c1>// Good: recommended
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tablename</span><span class=p>;</span>  <span class=c1>// Bad: prohibited
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span>       <span class=c1>// Good: single-word lowercase per lowerCamelCase
</span></span></span></code></pre></div><h3 id=rule-251-global-variables-must-have-a-g_-prefix-static-variables-need-no-special-prefix><a name=r2-5-1></a>Rule 2.5.1 Global variables must have a &lsquo;g_&rsquo; prefix; static variables need no special prefix</h3><p>Global variables should be used sparingly; adding the prefix visually reminds developers to use them carefully.</p><ul><li>Static global variables share the same naming as global variables.</li><li>Function-local static variables share normal local variable naming.</li><li>Class static member variables share normal member variable naming.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_activeConnectCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>packetCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rule-252-class-member-variables-are-named-in-lowercamelcase-followed-by-a-trailing-underscore><a name=r2-5-2></a>Rule 2.5.2 Class member variables are named in lowerCamelCase followed by a trailing underscore</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileName_</span><span class=p>;</span>   <span class=c1>// trailing _ suffix, similar to K&amp;R style
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>For struct/union member variables, use lowerCamelCase without suffix, consistent with local variables.</p><h2 id=macro-constant-and-enum-naming><a name=c2-6></a>Macro, Constant, and Enum Naming</h2><p>Macros and enum values use ALL CAPS, underscore-connected format.<br>Global-scope or named/anonymous-namespace const constants, as well as class static member constants, use ALL CAPS, underscore-connected; function-local const constants and ordinary const member variables use lowerCamelCase.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX(a, b)   (((a) &lt; (b)) ? (b) : (a)) </span><span class=c1>// macro naming example only—macro not recommended for such a feature
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TintColor</span> <span class=p>{</span>    <span class=c1>// enum type name in UpperCamelCase, values in ALL CAPS, underscore-connected
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DARK_RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>GREEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LIGHT_GREEN</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>    <span class=c1>// local constant
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>DEFAULT_FILE_SIZE_KB</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>        <span class=c1>// global constant
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h1 id=3-format><a name=c3></a>3 Format</h1><h2 id=line-length><a name=c3-1></a>Line Length</h2><h3 id=rule-311-do-not-exceed-120-characters-per-line><a name=r3-1-1></a>Rule 3.1.1 Do not exceed 120 characters per line</h3><p>We recommend keeping each line under 120 characters. If 120 characters are exceeded, choose a reasonable wrapping method.</p><p>Exceptions:</p><ul><li>Lines containing commands or URLs in comments may remain on one line for copy/paste / grep convenience, even above 120 chars.</li><li>#include statements with long paths may exceed 120 chars but should be avoided when possible.</li><li>Preprocessor error messages may span one line for readability, even above 120 chars.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef XXX_YYY_ZZZ
</span></span></span><span class=line><span class=cl><span class=cp>#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 id=indentation><a name=c3-2></a>Indentation</h2><h3 id=rule-321-use-spaces-for-indentation4-spaces-per-level><a name=r3-2-1></a>Rule 3.2.1 Use spaces for indentation—4 spaces per level</h3><p>Only use spaces for indentation (4 spaces per level). Do not use tab characters.<br>Almost all modern IDEs can be configured to automatically expand tabs to 4 spaces—please configure yours accordingly.</p><h2 id=braces><a name=c3-3></a>Braces</h2><h3 id=rule-331-use-kr-indentation-style><a name=r3-3-1></a>Rule 3.3.1 Use K&amp;R indentation style</h3><p><strong>K&amp;R Style</strong><br>For functions (excluding lambda expressions), place the left brace on a new line at the beginning of the line, alone; for other cases, the left brace should follow statements and stay at the end of the line.<br>Right braces are always on their own line, unless additional parts of the same statement follow—e.g., while in do-while, else/else-if of an if-statement, comma, or semicolon.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span> <span class=p>{</span>     <span class=c1>// brace follows statement with one preceding space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                   <span class=c1>// function left brace on a new line, alone
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Reason for recommending this style:</p><ul><li>Code is more compact.</li><li>Continuation improves reading rhythm compared to new-line placement.</li><li>Aligns with later language conventions and industry mainstream practice.</li><li>Modern IDEs provide alignment aids so the end-of-line brace does not hinder scoping comprehension.</li></ul><p>For empty function bodies, the braces may be placed on the same line:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=function-declarations-and-definitions><a name=c3-4></a>Function Declarations and Definitions</h2><h3 id=rule-341-both-return-type-and-function-name-must-be-on-the-same-line-break-and-align-parameters-reasonably-when-line-limit-is-exceeded><a name=r3-4-1></a>Rule 3.4.1 Both return type and function name must be on the same line; break and align parameters reasonably when line limit is exceeded</h3><p>When declaring or defining functions, the return type and function name must appear on the same line; if permitted by the column limit, place parameters on the same line as well—otherwise break parameters onto the next line with proper alignment.<br>The left parenthesis always stays on the same line as the function name; placing it on its own line is prohibited. The right parenthesis always follows the last parameter.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>FunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>)</span>   <span class=c1>// Good: all on one line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>VeryVeryVeryLongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span>     <span class=c1>// line limit exceeded, break
</span></span></span><span class=line><span class=cl><span class=c1></span>                                        <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span>     <span class=c1>// Good: align with previous
</span></span></span><span class=line><span class=cl><span class=c1></span>                                        <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>LongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=c1>// line limit exceeded
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName5</span><span class=p>)</span>    <span class=c1>// Good: 4-space indent after break
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>ReallyReallyReallyReallyLongFunctionName</span><span class=p>(</span>            <span class=c1>// will not fit first parameter, break immediately
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span> <span class=c1>// Good: 4-space indent after break
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=function-calls><a name=c3-5></a>Function Calls</h2><h3 id=rule-351-keep-function-argument-lists-on-one-line-if-line-limit-is-exceeded-align-parameters-correctly-when-wrapping><a name=r3-5-1></a>Rule 3.5.1 Keep function argument lists on one line. If line limit is exceeded, align parameters correctly when wrapping</h3><p>Function calls should have their parameter list on one line—if exceeding the line length, break and align parameters accordingly.<br>Left parenthesis always follows the function name; right parenthesis always follows the last parameter.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>);</span>   <span class=c1>// Good: single line
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>paramName2</span><span class=p>,</span>                <span class=c1>// Good: aligned with param above
</span></span></span><span class=line><span class=cl><span class=c1></span>                                 <span class=n>paramName3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>paramName3</span><span class=p>,</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>paramName5</span><span class=p>);</span>                    <span class=c1>// Good: 4-space indent on break
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>VeryVeryVeryLongFunctionName</span><span class=p>(</span>           <span class=c1>// cannot fit first param, break immediately
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>paramName3</span><span class=p>);</span>                    <span class=c1>// 4-space indent after break
</span></span></span></code></pre></div><p>If parameters are intrinsically related, grouping them for readability may take precedence over strict formatting.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Good: each line represents a group of related parameters
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DealWithStructureLikeParams</span><span class=p>(</span><span class=n>left</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>left</span><span class=p>.</span><span class=n>y</span><span class=p>,</span>     <span class=c1>// group 1
</span></span></span><span class=line><span class=cl><span class=c1></span>                                         <span class=n>right</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>right</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>  <span class=c1>// group 2
</span></span></span></code></pre></div><h2 id=if-statements><a name=c3-6></a>if Statements</h2><h3 id=rule-361-if-statements-must-use-braces><a name=r3-6-1></a>Rule 3.6.1 if statements must use braces</h3><p>We require braces for all if statements—even for single-line conditions.</p><p>Rationale:</p><ul><li>Code logic is intuitive and readable.</li><li>Adding new code to an existing conditional is less error-prone.</li><li>Braces protect against macro misbehavior when using functional macros (in case the macro omitted braces).</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>objectIsNotExist</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Good: braces for single-line condition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>CreateNewObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rule-362-prohibit-writing-ifelseelse-if-on-the-same-line><a name=r3-6-2></a>Rule 3.6.2 Prohibit writing if/else/else if on the same line</h3><p>Branches in conditional statements must appear on separate lines.</p><p>Correct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// Good: else on new line
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Incorrect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=c1>// Bad: else same line as if
</span></span></span></code></pre></div><h2 id=loops><a name=c3-7></a>Loops</h2><h3 id=rule-371-loop-statements-must-use-braces><a name=r3-7-1></a>Rule 3.7.1 Loop statements must use braces</h3><p>Similar to conditions, we require braces for all for/while loops—even if the body is empty or contains only one statement.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// Good: braces used
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>   <span class=c1>// Good: empty body with braces
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>continue</span><span class=p>;</span>           <span class=c1>// Good: continue indicates empty logic, still braces
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Bad examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>      <span class=c1>// Bad: missing braces
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>);</span>      <span class=c1>// Bad: semicolon appears part of loop, confusing
</span></span></span></code></pre></div><h2 id=switch-statements><a name=c3-8></a>switch Statements</h2><h3 id=rule-381-indent-casedefault-within-switch-bodies-one-additional-level><a name=r3-8-1></a>Rule 3.8.1 Indent case/default within switch bodies one additional level</h3><p>Indentation for switch statements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>             <span class=c1>// Good: indented
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DoSomething1</span><span class=p>();</span> <span class=c1>// Good: indented
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span>           <span class=c1>// Good: brace indentation if needed
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DoSomething2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Bad:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=o>:</span>                 <span class=c1>// Bad: case not indented
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span>                <span class=c1>// Bad: default not indented
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=expressions><a name=c3-9></a>Expressions</h2><h3 id=recommendation-391-consistently-break-long-expressions-at-operators-operators-stranded-at-eol><a name=a3-9-1></a>Recommendation 3.9.1 Consistently break long expressions at operators, operators stranded at EOL</h3><p>When an expression is too long for one line, break at an appropriate operator. Place the operator at the end-of-line, indicating ‘to be continued’.</p><p>Example:<br>// Assume first line exceeds limit</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>currentValue</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span>  <span class=c1>// Good: logical operator at EOL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>someCondition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>reallyReallyLongVariableName1</span> <span class=o>+</span>    <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span>             <span class=n>reallyReallyLongVariableName2</span><span class=p>;</span>
</span></span></code></pre></div><p>After wrapping, either align appropriately or indent subsequent lines by 4 spaces.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>        <span class=c1>// Good: 4-space indent
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>          <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>  <span class=c1>// Good: aligned
</span></span></span></code></pre></div><h2 id=variable-assignment><a name=c3-10></a>Variable Assignment</h2><h3 id=rule-3101-multiple-variable-declarations-and-initializations-are-forbidden-on-the-same-line><a name=r3-10-1></a>Rule 3.10.1 Multiple variable declarations and initializations are forbidden on the same line</h3><p>One variable initialization per line improves readability and comprehension.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span></code></pre></div><p>Bad examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Bad: multiple initializations must span separate lines
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Bad: multiple declarations must be on separate lines
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>pointX</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>pointY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Bad: multiple assignments placed on same line
</span></span></span></code></pre></div><p>Exception: for loop headers, if-with-initializer (C++17), structured binding statements (C++17), etc., may declare and initialize multiple variables; forcing separation would hinder scope correctness and clarity.</p><h2 id=initialization><a name=c3-11></a>Initialization</h2><p>Includes initialization for structs, unions, and arrays.</p><h3 id=rule-3111-indent-initialization-lists-when-wrapping-align-elements-properly><a name=r3-11-1></a>Rule 3.11.1 Indent initialization lists when wrapping; align elements properly</h3><p>When breaking struct/array initializers, each continuation is indented 4 spaces. Choose break and alignment points for readability.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=pointers-and-references><a name=c3-12></a>Pointers and References</h2><h3 id=recommendation-3121-place-the-pointer-star--adjacent-to-the-variable-or-typenever-add-spaces-on-both-sides-or-omit-both><a name=a3-12-1></a>Recommendation 3.12.1 Place the pointer star &lsquo;*&rsquo; adjacent to the variable or type—never add spaces on both sides or omit both</h3><p>Pointer naming: align &lsquo;*&rsquo; to either left (type) or right (variable) but never leave/pad both sides.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Bad
</span></span></span></code></pre></div><p>Exception when const is involved—&rsquo;*&rsquo; cannot trail the variable, so avoid trailing the type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>VERSION</span> <span class=o>=</span> <span class=s>&#34;V100&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=recommendation-3122-place-the-reference-operator--adjacent-to-the-variable-or-typenever-pad-both-sides-nor-omit-both><a name=a3-12-2></a>Recommendation 3.12.2 Place the reference operator &lsquo;&&rsquo; adjacent to the variable or type—never pad both sides nor omit both</h3><p>Reference naming: & aligned either left (type) or right (variable); never pad both sides or omit spacing.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*&amp;</span> <span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good: reference to pointer; *&amp; together after type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good: reference to pointer; *&amp; together after variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good: pointer followed by reference—* with type, &amp; with variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>&amp;</span><span class=n>reeeenamespace</span><span class=o>=</span> <span class=n>i</span><span class=p>;</span>  <span class=c1>// Bad—illustrates missing space or doubled up spacing issues
</span></span></span></code></pre></div><h2 id=preprocessor-directives><a name=c3-13></a>Preprocessor Directives</h2><h3 id=rule-3131-place-preprocessing--at-the-start-of-the-line-nested-preprocessor-statements-may-indent--accordingly><a name=r3-13-1></a>Rule 3.13.1 Place preprocessing &lsquo;#&rsquo; at the start of the line; nested preprocessor statements may indent &lsquo;#&rsquo; accordingly</h3><p>Preprocessing directives&rsquo; &lsquo;#&rsquo; must be placed at the beginning of the line—even if inside function bodies.</p><h3 id=rule-3132-avoid-macros-except-where-necessary><a name=r3-13-2></a>Rule 3.13.2 Avoid macros except where necessary</h3><p>Macros ignore scope, type systems, and many rules and are prone to error. Prefer non-macro approaches, and if macros must be used, ensure unique macro names.<br>In C++, many macro use cases can be replaced:</p><ul><li>Use const or enum for intuitive constants</li><li>Use namespaces to prevent name conflicts</li><li>Use inline functions to avoid call overhead</li><li>Use template functions for type abstraction</li></ul><p>Macros may be used for include guards, conditional compilation, and logging where required.</p><h3 id=rule-3133-do-not-use-macros-to-define-constants><a name=r3-13-3></a>Rule 3.13.3 Do not use macros to define constants</h3><p>Macros are simple text substitution completed during pre-processing; typeless, unscoped, and unsafe. Debugging errors display the value, not the macro name.</p><h3 id=rule-3134-do-not-use-function-like-macros><a name=r3-13-4></a>Rule 3.13.4 Do not use function-like macros</h3><p>Before defining a function-like macro, consider if a real function can be used. When alternatives exist, favor functions.<br>Disadvantages of function-like macros:</p><ul><li>Lack type checking vs function calls</li><li>Macro arguments are <em>not</em> evaluated (behaves differently than function calls)</li><li>No scope encapsulation</li><li>Heavily cryptic syntax (macro operator <code>#</code> and eternal parentheses) harms readability</li><li>Extensions needed (e.g., GCC statement expressions) hurt portability</li><li>Compiler sees the macro <em>after</em> pre-processing; multi-line macro expansions collapse into one line, hard to debug or breakpoint</li><li>Repeated expansion of large macros increases code size</li></ul><p>Functions do not suffer the above negatives, although worst-case cost is reduced performance via call overhead (or due to micro-architecture optimization hassles).<br>To mitigate, use <code>inline</code>. Inline functions:</p><ul><li>Perform strict type checking</li><li>Evaluate each argument once</li><li>Expand in place with no call overhead</li><li>May optimize better than macros</li></ul><p>For performance-critical production code, prefer inline functions over macros.</p><p>Exception:<br>logging macros may need to retain <strong>FILE</strong>/<strong>LINE</strong> of the call site.</p><h2 id=whitespaceblank-lines><a name=c3-14></a>Whitespace/Blank Lines</h2><h3 id=rule-3141-horizontal-spaces-should-emphasize-keywords-and-key-information-avoid-excessive-whitespace><a name=r3-14-1></a>Rule 3.14.1 Horizontal spaces should emphasize keywords and key information, avoid excessive whitespace</h3><p>Horizontal spaces should highlight keywords and key info; do <strong>not</strong> pad trailing spaces. General rules:</p><ul><li>Add space after keywords: if, switch, case, do, while, for</li><li>Do not pad inside parentheses both-left-and-right</li><li>Maintain symmetry around braces</li><li>No space after unary operators (& * + - ~ !)</li><li>Add spaces around binary operators (= + - &lt; > * / % | & ^ &lt;= >= == !=)</li><li>Add spaces around ternary operators ( ? : )</li><li>No space between pre/post inc/dec (++, &ndash;) and variable</li><li>No space around struct member access (., ->)</li><li>No space before comma, but space after</li><li>No space between &lt;> and type names as in templates or casts</li><li>No space around scope operator ::</li><li>Colon (:) spaced according to context when needed</li></ul><p>Typical cases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: space before left brace
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Good: spaces around =; no space before semicolon
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>    <span class=c1>// Good: no space after {
</span></span></span></code></pre></div><p>Function definition/call examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//                      ^    Bad: comma needs trailing space
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//               ^        ^     Bad: no space after ( before args; none before )
</span></span></span></code></pre></div><p>Pointer/address examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>     <span class=c1>// Good: no space between * and p
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good: no space between &amp; and x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>    <span class=c1>// Good: no space around .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>   <span class=c1>// Good: no space around -&gt;
</span></span></span></code></pre></div><p>Operators:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// Good: spaces around =
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5</span><span class=p>;</span>  <span class=c1>// Good: no space between - and 5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good: no space between ++ and x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>y</span><span class=p>)</span>  <span class=c1>// Good: spaces around &amp;&amp;, none between ! and y
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>v = w * x + y / z;  // Good: Binary operators are surrounded by spaces.
</span></span><span class=line><span class=cl>v = w * (x + z);    // Good: Expressions inside parentheses are not padded with spaces.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int a = (x <span class=p>&lt;</span> <span class=nt>y</span><span class=err>)</span> <span class=err>?</span> <span class=na>x</span> <span class=na>:</span> <span class=na>y</span><span class=err>;</span>  <span class=err>//</span> <span class=na>Good:</span> <span class=na>Ternary</span> <span class=na>operators</span> <span class=na>require</span> <span class=na>spaces</span> <span class=na>before</span> <span class=err>?</span> <span class=na>and</span> <span class=na>:</span><span class=err>.</span>
</span></span></code></pre></div><p>Loops and conditional statements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: A space after if, none inside the parentheses
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>           <span class=c1>// Good: A space after else
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{}</span>   <span class=c1>// Good: Same rules as if
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: Space after for, after each semicolon
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: One space between switch and (
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>     <span class=c1>// Good: No space between case label and colon
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Templates and casts</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Angle brackets (&lt; and &gt;) are never preceded by spaces, nor followed directly by spaces.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// One space between a type and * is acceptable; keep it consistent.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>Scope resolution operator</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>    <span class=c1>// Good: No spaces around ::
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>GetValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{}</span>  <span class=c1>// Good: No spaces around ::
</span></span></span></code></pre></div><p>Colons</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// When spaces are required
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Good: Space before colon with class derivation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Constructor initializer list needs spaces
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Bit field width also gets a space
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>XX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// When spaces are NOT required
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Good: No space after public:, private:, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// No space after case or default in switch statements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note: Configure your IDE to strip trailing whitespace.</p><h3 id=advice-3141-arrange-blank-lines-to-keep-code-compact><a name=a3-14-1></a>Advice 3.14.1 Arrange blank lines to keep code compact</h3><p>Avoid needless blank lines to display more code on screen and improve readability. Observe these guidelines:</p><ul><li>Insert blank lines based on logical sections, not on automatic habits.</li><li>Do not use consecutive blank lines inside functions, type definitions, macros, or initializer lists.</li><li>Never use three or more consecutive blank lines.</li><li>Do not leave blank lines right after a brace that opens a block or right before the closing brace; the only exception is within namespace scopes.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Bar</span><span class=p>()</span>  <span class=c1>// Bad: more than two consecutive blank lines.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad: blank line immediately after opening brace
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad: blank line immediately before closing brace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad: blank line at start of function body
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=classes><a name=c3-15></a>Classes</h2><h3 id=rule-3151-order-class-access-specifiers-as-public-protected-private-at-the-same-indentation-level-as-class><a name=r3-15-1></a>Rule 3.15.1 Order class access specifiers as public:, protected:, private: at the same indentation level as class</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>      <span class=c1>// Note: no extra indentation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MyClass</span><span class=p>();</span>  <span class=c1>// standard 4-space indent
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>explicit</span> <span class=nf>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunctionThatDoesNothing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetVar</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=p>{</span> <span class=n>someVar_</span> <span class=o>=</span> <span class=n>var</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVar</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>someVar_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>SomeInternalFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someOtherVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Within each section group similar declarations and order them roughly as follows: type aliases (typedef, using, nested structs / classes), constants, factory functions, constructors, assignment operators, destructor, other member functions, data members.</p><h3 id=rule-3152-constructor-initializer-lists-should-fit-on-one-line-or-be-indented-four-spaces-and-line-wrapped><a name=r3-15-2></a>Rule 3.15.2 Constructor initializer lists should fit on one line or be indented four spaces and line-wrapped</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// If everything fits on one line:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Otherwise, place after the colon and indent four spaces
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span> <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Good: space after comma
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// If multiple lines are needed, align each initializer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span>            <span class=c1>// indent 4 spaces
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=4-comments><a name=c4></a>4 Comments</h1><p>Prefer clear architecture and naming; only add comments when necessary to aid understanding.</p><p>Keep comments concise, accurate, and non-redundant.<br><strong>Comments are as important as code.</strong><br>When you change code, update all relevant comments—leaving old comments is destructive.</p><p>Use English for all comments.</p><h2 id=comment-style><a name=c3-1></a>Comment style</h2><p>Both <code>/* */</code> and <code>//</code> are acceptable.<br>Choose one consistent style for each comment category (file header, function header, inline, etc.).</p><p>Note: samples in this document frequently use trailing <code>//</code> merely for explanation—do not treat it as an endorsed style.</p><h2 id=file-header><a name=c4-2></a>File header</h2><h3 id=rule-31-file-headers-must-contain-a-valid-license-notice><a name=r3-1></a>Rule 3.1 File headers must contain a valid license notice</h3><p>/*</p><ul><li>Copyright (c) 2020 XXX</li><li>Licensed under the Apache License, Version 2.0 (the &ldquo;License&rdquo;);</li><li>you may not use this file except in compliance with the License.</li><li>You may obtain a copy of the License at</li><li></li><li><pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre></li><li></li><li>Unless required by applicable law or agreed to in writing, software</li><li>distributed under the License is distributed on an &ldquo;AS IS&rdquo; BASIS,</li><li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li><li>See the License for the specific language governing permissions and</li><li>limitations under the License.
*/</li></ul><h2 id=function-header-comments><a name=c4-3></a>Function header comments</h2><h3 id=rule-431-provide-headers-for-public-functions><a name=r4-3-1></a>Rule 4.3.1 Provide headers for public functions</h3><p>Callers need to know behavior, parameter ranges, return values, side effects, ownership, etc.—and the function signature alone cannot express everything.</p><h3 id=rule-432-never-leave-noisy-or-empty-function-headers><a name=r4-3-2></a>Rule 4.3.2 Never leave noisy or empty function headers</h3><p>Not every function needs a comment.<br>Only add a header when the signature is insufficient.</p><p>Headers appear above the declaration/definition using one of the following styles:
With <code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// One-line function header
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Multi-line function header
</span></span></span><span class=line><span class=cl><span class=c1>// Second line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>With <code>/* */</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Single-line function header */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Alternative single-line style
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Multi-line header
</span></span></span><span class=line><span class=cl><span class=cm> * Second line
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func3</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>Cover: purpose, return value, performance hints, usage notes, memory ownership, re-entrancy etc.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Returns bytes actually written, -1 on failure.
</span></span></span><span class=line><span class=cl><span class=cm> * Caller owns the buffer buf.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>Bad:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Function name: WriteString
</span></span></span><span class=line><span class=cl><span class=cm> * Purpose: write string
</span></span></span><span class=line><span class=cl><span class=cm> * Parameters:
</span></span></span><span class=line><span class=cl><span class=cm> * Return:
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>Problems:‐ parameters/return empty, function name redundant, unclear ownership.</p><h2 id=inline-code-comments><a name=c4-4></a>Inline code comments</h2><h3 id=rule-441-place-comments-directly-above-or-to-the-right-of-the-code><a name=r4-4-1></a>Rule 4.4.1 Place comments directly above or to the right of the code</h3><h3 id=rule-442-put-one-space-after-the-comment-token-right-side-comments-need--1-space><a name=r4-4-2></a>Rule 4.4.2 Put one space after the comment token; right-side comments need ≥ 1 space</h3><p>Above code: indent comment same as code.<br>Pick one consistent style.</p><p>With <code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Single-line comment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Multi-line
</span></span></span><span class=line><span class=cl><span class=c1>// comment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>With <code>/* */</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Single-line comment */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Alternative multi-line comment
</span></span></span><span class=line><span class=cl><span class=cm> * second line
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>Right-of-code style: 1–4 spaces between code and token.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>  <span class=c1>// Right-side comment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>bar</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>  <span class=cm>/* Right-side comment */</span>
</span></span></code></pre></div><p>Aligning right-side comments is acceptable when cluster is tall:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>A_CONST</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>         <span class=cm>/* comments may align */</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>ANOTHER_CONST</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>   <span class=cm>/* keep uniform gap */</span>
</span></span></code></pre></div><p>If the right-side comment would exceed the line limit, move it to the previous standalone line.</p><h3 id=rule-443-delete-unused-code-do-not-comment-it-out><a name=r4-4-3></a>Rule 4.4.3 Delete unused code, do not comment it out</h3><p>Commented-out code cannot be maintained; resurrecting it later risks bugs.<br>When you no longer need code, remove it. Recoveries use version control.</p><p>This applies to /* */, //, #if 0, #ifdef NEVER_DEFINED, etc.</p><h1 id=5-headers><a name=c5></a>5 Headers</h1><h2 id=responsibilities><a name=c5-1></a>Responsibilities</h2><p>Headers list a module’s public interface; design is reflected mostly here.<br>Keep implementation out of headers (inline functions are OK).<br>Headers should be single-minded; complexity and excessive dependencies hurt compile time.</p><h3 id=advice-511-every-cpp-file-should-have-a-matching-h-file-for-the-interface-it-provides><a name=a5-1-1></a>Advice 5.1.1 Every .cpp file should have a matching .h file for the interface it provides</h3><p>A .h file declares what the .cpp decides to expose.<br>If a .cpp publishes nothing to other TUs, it shouldn’t exist—except: program entry point, test code, or DLL edge cases.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef FOO_H
</span></span></span><span class=line><span class=cl><span class=cp>#define FOO_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;Foo.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span> <span class=c1>// Good: internal helper declared in .cpp, hidden by unnamed namespace or static
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=header-dependencies><a name=c5-2></a>Header dependencies</h2><h3 id=rule-521-forbid-circular-includes><a name=r5-2-1></a>Rule 5.2.1 Forbid circular #includes</h3><p>a.h → b.h → c.h → a.h causes full rebuild on any change.<br>Refactor architecture to break cycles.</p><h3 id=rule-522-every-header-must-have-an-include-guard-define><a name=r5-2-4></a>Rule 5.2.2 Every header must have an include guard #define</h3><p>Do not use #pragma once.</p><p>Guidelines:</p><ol><li>Use a unique macro per file.</li><li>No code/comments except the header license between #ifndef/#define and the matching #endif.</li></ol><p>Example: For timer/include/timer.h:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp>#define TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h3 id=rule-523-forbid-extern-declarations-of-external-functionsvariables><a name=r5-2-5></a>Rule 5.2.3 Forbid extern declarations of external functions/variables</h3><p>Always <code>#include</code> the proper header instead of duplicating signatures with extern.<br>Inconsistencies may appear when the real signature changes; also encourages architectural decay.</p><p>Bad:
// a.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span></code></pre></div><p>Good:
// a.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>   </span><span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span></code></pre></div><p>// b.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span></code></pre></div><p>// b.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span></code></pre></div><p>Exception: testing private members, stubs, or patches may use extern when the header itself cannot be augmented.</p><h3 id=rule-524-do-not-include-inside-extern-c><a name=r5-2-6></a>Rule 5.2.4 Do not #include inside extern &ldquo;C&rdquo;</h3><p>Such includes may nest extern &ldquo;C&rdquo; blocks, and some compilers have limited nesting.<br>Likewise, C/C++ inter-op headers may silently change linkage specifiers.</p><p>Example—files a.h / b.h:</p><p>// a.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define A(value) Foo(value)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>// b.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>After preprocessing b.h in C++:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Foo now gets C linkage although author wanted C++ linkage.</p><p>Exception: including a pure C header lacking <code>extern "C"</code> inside <code>extern "C"</code> is acceptable when non-intrusive.</p><h3 id=advice-521-prefer-include-over-forward-declarations><a name=a5-2-1></a>Advice 5.2.1 Prefer #include over forward declarations</h3><p>Forward declaration quick wins:</p><ol><li>Saves compile time by reducing header bloat.</li><li>Breaks needless rebuilds on unrelated header edits.</li></ol><p>Drawbacks:</p><ol><li>Hides real dependencies—changes in the header may not trigger recompilation.</li><li>Subsequent library changes can break your declaration.</li><li>Forward declaring std:: names is undefined by C++11.</li><li>Many declarations are longer than a single #include.</li><li>Refactoring code just to support forward declaration often hurts performance (pointer members) and clarity.</li><li>It is hard to decide when it is truly safe.</li></ol><p>Hence, prefer <code>#include</code> to keep dependencies explicit.</p><h1 id=6-scope><a name=c6></a>6 Scope</h1><h2 id=namespaces><a name=c6-1></a>Namespaces</h2><h3 id=advice-611-use-anonymous-namespaces-or-static-to-hide-file-local-symbols><a name=a6-1-1></a>Advice 6.1.1 Use anonymous namespaces or static to hide file-local symbols</h3><p>In C++03 static globals/funcs are deprecated, so unnamed namespaces are preferred.</p><p>Reasons:</p><ol><li>static already means too many things.</li><li>namespace can also encapture types.</li><li>Encourage uniform namespace usage.</li><li>static functions cannot instantiate templates—namespaces can.</li></ol><p>Never use anonymous namespace or static in a .h file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_COUNT</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>MAX_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rule-611-never-use-using-namespace-in-headers-or-before-includes><a name=r6-1-1></a>Rule 6.1.1 Never use <code>using namespace</code> in headers or before #includes</h3><p>Doing so pollutes every translation unit that includes it.<br>Example:</p><p>// a.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceB</span><span class=p>;</span>  <span class=c1>// Bad
</span></span></span></code></pre></div><p>// a.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>         </span><span class=c1>// ambiguity: NamespaceA::Fun vs NamespaceB::Fun
</span></span></span></code></pre></div><p>Allowed: bringing in single symbols or aliases inside a custom module namespace in headers:</p><p>// foo.h</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fancy/string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>                        <span class=c1>// Bad in global namespace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>                    <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>MyVector</span> <span class=o>=</span> <span class=n>fancy</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>    <span class=c1>// C++11 type alias OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=global-and-static-member-functions><a name=c6-2></a>Global and static member functions</h2><h3 id=advice-621-prefer-namespaces-for-free-functions-use-static-members-only-when-tightly-coupled-to-a-class><a name=a6-2-1></a>Advice 6.2.1 Prefer namespaces for free functions; use static members only when tightly coupled to a class</h3><p>Namespace usage avoids global namespace pollution. Only when a free function is intrinsically related to a specific class should it live as a static member.</p><p>Helper logic needed only by a single .cpp belongs in an anonymous namespace.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>File</span> <span class=n>CreateTempFile</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=global-and-static-member-constants><a name=c6-3></a>Global and static member constants</h2><h3 id=advice-631-use-namespaces-to-hold-constants-use-static-members-only-when-tied-to-a-class><a name=a6-3-1></a>Advice 6.3.1 Use namespaces to hold constants; use static members only when tied to a class</h3><p>Namespaces guard against global namespace clutter. Only when the constant is logically owned by a specific class should it be a static member.</p><p>Implementation-only constants belong in an anonymous namespace.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>SEPARATOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=global-variables><a name=c6-4></a>Global variables</h2><h3 id=advice-641-minimize-global-variables-use-a-singleton-instead><a name=a6-4-1></a>Advice 6.4.1 Minimize global variables; use a singleton instead</h3><p>Mutable globals create tight, invisible coupling across TUs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_counter</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>Singleton pattern (global unique object):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Counter</span><span class=o>&amp;</span> <span class=n>GetInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Counter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Increase</span><span class=p>()</span>   <span class=p>{</span> <span class=n>value_</span><span class=o>++</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Print</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Counter</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Print</span><span class=p>();</span>
</span></span></code></pre></div><p>This keeps state shared globally but with better encapsulation.</p><p>Exception: if the variable is module-local (each DLL/so or executable instance carries its own), you cannot use a singleton.</p><h1 id=7-classes><a name=c7></a>7 Classes</h1><h2 id=constructors-copy-move-assignment-and-destructors><a name=c7-1></a>Constructors, copy, move, assignment, and destructors</h2><p>These special members manage object lifetime:</p><ul><li>Constructor: <code>X()</code></li><li>Copy constructor: <code>X(const X&)</code></li><li>Copy assignment operator: <code>operator=(const X&)</code></li><li>Move constructor: <code>X(X&&)</code> <em>available since C++11</em></li><li>Move assignment operator: <code>operator=(X&&)</code> <em>available since C++11</em></li><li>Destructor: <code>~X()</code></li></ul><h3 id=rule-711-all-member-variables-of-a-class-must-be-explicitly-initialized><a name=r7-1-1></a>Rule 7.1.1 All member variables of a class must be explicitly initialized</h3><p>Rationale: If a class has member variables, does not define any constructors, and lacks a default constructor, the compiler will implicitly generate one, but that generated constructor will not initialize the member variables, leaving the object in an indeterminate state.</p><p>Exceptions:</p><ul><li>If the member variable has a default constructor, explicit initialization is not required.</li></ul><p>Example: The following code lacks a constructor, so the private data members are uninitialized:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//…
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Message</span> <span class=n>message</span><span class=p>;</span>   <span class=c1>// message members are not initialized
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>message</span><span class=p>.</span><span class=n>ProcessOutMsg</span><span class=p>();</span>   <span class=c1>// subsequent use is dangerous
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Therefore, providing a default constructor is necessary, as follows:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgID_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgBuffer_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span> <span class=c1>// has a default constructor, no explicit initialization needed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=advice-711-prefer-in-class-member-initialization-c11-and-constructor-initializer-lists><a name=a7-1-1></a>Advice 7.1.1 Prefer in-class member initialization (C++11) and constructor initializer lists</h3><p>Rationale: C++11 in-class initialization makes the default member value obvious at a glance and should be preferred. If initialization depends on constructor parameters or C++11 is unavailable, prefer the initializer list. Compared with assigning inside the constructor body, the initializer list is more concise, performs better, and can initialize <code>const</code> members and references.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1>// Good: prefer initializer list
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>msgBuffer_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Bad: avoid assignment in constructor body
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>  <span class=c1>// Good: use C++11 in-class initialization
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-712-declare-single-argument-constructors-explicit-to-prevent-implicit-conversions><a name=r7-1-2></a>Rule 7.1.2 Declare single-argument constructors <code>explicit</code> to prevent implicit conversions</h3><p>Rationale: A single-argument constructor not declared <code>explicit</code> acts as an implicit conversion function.<br>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span><span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ProcessFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFoo</span><span class=p>(</span><span class=n>test</span><span class=p>);</span>  <span class=c1>// compile fails
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Compilation fails because <code>ProcessFoo</code> expects a <code>Foo</code>, but a <code>std::string</code> is supplied.</p><p>If <code>explicit</code> were removed, the <code>std::string</code> would implicitly convert into a temporary <code>Foo</code> object. Such silent conversions are confusing and may hide bugs. Hence single-argument constructors must be declared <code>explicit</code>.</p><h3 id=rule-713-explicitly-prohibit-copymove-constructsassignment-when-not-needed><a name=r7-1-3></a>Rule 7.1.3 Explicitly prohibit copy/move constructs/assignment when not needed</h3><p>Rationale: Unless the user defines them, the compiler will generate copy constructor, copy assignment operator, move constructor and move assignment operator (move semantics are C++11+).<br>If the class should not support copying/moving, forbid them explicitly:</p><ol><li>Make the copy/move ctor or assignment operator <code>private</code> and leave it undefined:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li><p>Use <code>= delete</code> from C++11, see the Modern C++ section.</p></li><li><p>Prefer inheriting from <code>NoCopyable</code>, <code>NoMovable</code>; disallow macros such as <code>DISALLOW_COPY_AND_MOVE</code>, <code>DISALLOW_COPY</code>, <code>DISALLOW_MOVE</code>.</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NoCopyable</span><span class=p>,</span> <span class=k>public</span> <span class=n>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Implementation of <code>NoCopyable</code> and <code>NoMovable</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoCopyable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-714-provide-or-prohibit-both-copy-constructor-and-copy-assignment-together><a name=r7-1-4></a>Rule 7.1.4 Provide or prohibit both copy constructor and copy assignment together</h3><p>Since both operations have copy semantics, allow or forbid them in pairs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Both provided
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Both defaulted (C++11)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Both prohibited; in C++11 use `delete`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-715-provide-or-prohibit-both-move-constructor-and-move-assignment-together><a name=r7-1-5></a>Rule 7.1.5 Provide or prohibit both move constructor and move assignment together</h3><p>Move semantics were added in C++11. If a class needs to support moving, both move constructor and move assignment must be present or both deleted.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Both provided
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Both defaulted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Both deleted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-716-never-call-virtual-functions-in-constructors-or-destructors><a name=r7-1-6></a>Rule 7.1.6 Never call virtual functions in constructors or destructors</h3><p>Rationale: Calling a virtual function on the object under construction/destruction prevents the intended polymorphic behavior.<br>In C++, a base class is only building one sub-object at a time.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Log</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// Derived classes use different log files
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>()</span>         <span class=c1>// base constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Log</span><span class=p>();</span>           <span class=c1>// virtual call inside ctor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>                                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Log</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>When executing <code>Sub sub;</code>, <code>Sub</code>&rsquo;s ctor runs first but calls <code>Base()</code> first; during <code>Base()</code>, the virtual call to <code>Log</code> binds to <code>Base::Log</code>, not <code>Sub::Log</code>. The same applies in destructors.</p><h3 id=rule-717-copymove-constructsassignment-of-polymorphic-bases-must-be-non-public-or-deleted><a name=r7-1-7></a>Rule 7.1.7 Copy/move constructs/assignment of polymorphic bases must be non-public or deleted</h3><p>Assigning a derived object to a base object causes slicing: only the base part is copied/moved, breaking polymorphism.<br>Negative Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=o>&amp;</span><span class=n>base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>other</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span> <span class=c1>// slicing occurs
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>other</span><span class=p>.</span><span class=n>Fun</span><span class=p>();</span> <span class=c1>// calls Base::Fun
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// derived passed in
</span></span></span></code></pre></div><p>Declare copy/move operations <code>delete</code> or <code>private</code> so the compiler rejects such assignments.</p><h2 id=inheritance><a name=c7-2></a>Inheritance</h2><h3 id=rule-721-base-class-destructors-must-be-virtual-classes-not-intended-for-inheritance-should-be-marked-final><a name=r7-2-1></a>Rule 7.2.1 Base class destructors must be <code>virtual</code>; classes not intended for inheritance should be marked <code>final</code></h3><p>Rationale: A base destructor must be virtual to ensure derived destructors run when the object is deleted via a base pointer.</p><p>Example: A base destructor missing <code>virtual</code> causes memory leaks.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=p>()</span> <span class=o>:</span> <span class=n>numbers_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Sub&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>size_t</span> <span class=n>numberCount</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers_</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=n>numberCount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>numbers_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>args</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Because <code>Base::~Base</code> is not virtual, only its destructor is invoked; <code>Sub::~Sub</code> is skipped and <code>numbers_</code> leaks.<br>Exceptions: Marker classes like <code>NoCopyable</code>, <code>NoMovable</code> need neither virtual destructors nor <code>final</code>.</p><h3 id=rule-722-virtual-functions-must-not-have-default-arguments><a name=r7-2-2></a>Rule 7.2.2 Virtual functions must not have default arguments</h3><p>Rationale: In C++, virtual dispatch happens at runtime but default arguments are bound at compile time. The selected function body is from the derived class while its default parameter values come from the base, causing surprising behavior.</p><p>Example: the program emits “Base!” instead of the expected “Sub!”</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Base!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span>  <span class=o>=</span> <span class=s>&#34;Sub!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Sub</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>  <span class=c1>// prints: Base!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sub</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>   <span class=c1>// prints: Sub!
</span></span></span><span class=line><span class=cl><span class=c1></span>   
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-723-do-not-override-an-inherited-non-virtual-function><a name=r7-2-3></a>Rule 7.2.3 Do not override an inherited non-virtual function</h3><p>Non-virtual functions are bound statically; only virtual functions provide dynamic dispatch.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>                    
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sub</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>    <span class=c1>// calls Sub::Fun               
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>base</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>   <span class=c1>// calls Base::Fun
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><h2 id=multiple-inheritance><a name=c7-3></a>Multiple Inheritance</h2><p>Real-world use of multiple inheritance in our code base is rare because it brings several typical problems:</p><ol><li>The diamond inheritance issue causes data duplication and name ambiguity; C++ introduces virtual inheritance to address it.</li><li>Even without diamond inheritance, name clashes between different bases can create ambiguity.</li><li>When a subclass needs to extend/override methods in multiple bases, its responsibilities become unclear, leading to confusing semantics.</li><li>Inheritance is white-box reuse: subclasses have access to parents’ <code>protected</code> members, creating stronger coupling. Multiple inheritance compounds the coupling.</li></ol><p>Benefits:<br>Multiple inheritance offers a simpler way to assemble interfaces and behaviors.</p><p>Hence multiple inheritance is allowed only in the following cases.</p><h3 id=advice-731-use-multiple-inheritance-for-interface-segregation-and-multi-role-composition><a name=a7-3-1></a>Advice 7.3.1 Use multiple inheritance for interface segregation and multi-role composition</h3><p>If a class must implement several unrelated interfaces, inherit from separate base classes that represent those roles—similar to Scala traits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role1</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role2</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role3</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object1</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role1</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role2</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>The C++ standard library also demonstrates this pattern:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_istream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_ostream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_iostream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>basic_istream</span><span class=p>,</span> <span class=k>public</span> <span class=n>basic_ostream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=overloading><a name=c7-4></a>Overloading</h2><p>Overload operators only with good reason and without altering their intuitive semantics; e.g., never use ‘+’ for subtraction.<br>Operator overloading makes code intuitive, but also has drawbacks:</p><ul><li>It can mislead readers into assuming built-in efficiency and overlook potential slowdowns;</li><li>Debugging is harder—finding a function name is easier than locating operator usage.</li><li>Non-intuitive behaviour (e.g., ‘+’ subtracting) obfuscates code.</li><li>Implicit conversions triggered by assignment operator overloads can hide deep bugs. Prefer functions like <code>Equals()</code>, <code>CopyFrom()</code> instead of overloading <code>==</code>, <code>=</code>.</li></ul><h1 id=8-functions><a name=c8></a>8 Functions</h1><h2 id=function-design><a name=c8-1></a>Function Design</h2><h3 id=rule-811-keep-functions-short-no-more-than-50-non-blank-non-comment-lines><a name=r8-1-1></a>Rule 8.1.1 Keep functions short; no more than 50 non-blank non-comment lines</h3><p>A function should fit on one screen (≤ 50 lines), do one thing, and do it well.<br>Long functions often indicate mixed concerns, excessive complexity, or missing abstractions.</p><p>Exceptions: Algorithmic routines that are inherently cohesive and complete might exceed 50 lines.</p><p>Even if the current version works well, future changes may introduce subtle bugs. Splitting into smaller, focused functions eases readability and maintenance.</p><h2 id=inline-functions><a name=c8-2></a>Inline Functions</h2><h3 id=advice-821-inline-functions-should-be-no-more-than-10-lines-non-blank-non-comment><a name=a8-2-1></a>Advice 8.2.1 Inline functions should be no more than 10 lines (non-blank non-comment)</h3><p>Inline functions retain the usual semantics; they just expand in place. Ordinary functions incur call/return overhead; inline functions substitute the body directly.</p><p>Inlining only makes sense for very small functions (1–10 lines). For large functions the call-cost is negligible, and compilers usually fall back to normal calls.<br>Complex control flow (loops, <code>switch</code>, <code>try-catch</code>) normally precludes inlining.</p><p><strong>Virtual functions and recursive functions cannot be inlined.</strong></p><h2 id=function-parameters><a name=c8-3></a>Function Parameters</h2><h3 id=advice-831-prefer-references-over-pointers-for-parameters><a name=a8-3-1></a>Advice 8.3.1 Prefer references over pointers for parameters</h3><p>References are safer: they cannot be null and cannot be reseated after binding; no null pointer checks required.<br>On legacy platforms follow existing conventions.<br>Use <code>const</code> to enforce immutability and document the intent, enhancing readability.</p><p>Exception: when passing run-time sized arrays, pointers may be used.</p><h3 id=advice-832-use-strong-typing-avoid-void><a name=a8-3-2></a>Advice 8.3.2 Use strong typing; avoid <code>void*</code></h3><p>C/C++ is strongly typed; keep the style consistent. Strong type checking allows the compiler to detect mismatches early.</p><p>Using strong types prevents defects. Watch the poorly typed <code>FooListAddNode</code> below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FooNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BarNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FooListAddNode</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span> <span class=c1>// Bad: using `void *`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=p>(</span><span class=n>FooNode</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAppend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_FooList</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>foo</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MakeTheList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BarNode</span> <span class=o>*</span><span class=n>bar</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FooListAddNode</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span>        <span class=c1>// Wrong: meant `foo`, compiles anyway
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ol><li>Use template functions for variant parameter types.</li><li>Prefer polymorphic base-class pointers/ references.</li></ol><h3 id=advice-833-functions-shall-have-no-more-than-5-parameters><a name=a8-3-3></a>Advice 8.3.3 Functions shall have no more than 5 parameters</h3><p>Too many parameters increase coupling to callers and complicate testing.</p><p>If you exceed this:</p><ul><li>Consider splitting the function.</li><li>Group related parameters into a single struct.</li></ul><h1 id=9-additional-c-features><a name=c9></a>9 Additional C++ Features</h1><h2 id=constants-and-initialization><a name=c9-1></a>Constants and Initialization</h2><p>Immutable values are easier to understand, trace and analyze; default to <code>const</code> for any definition.</p><h3 id=rule-911-do-not-use-macros-to-define-constants><a name=r9-1-1></a>Rule 9.1.1 Do not use macros to define constants</h3><p>Macros perform simple textual substitution at preprocessing time; error traces and debuggers show raw values instead of names.<br>Macros lack type checking and scope.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_MSISDN_LEN 20    </span><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// use C++ const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// for C++11+, prefer constexpr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=advice-911-group-related-integer-constants-using-enums><a name=a9-1-1></a>Advice 9.1.1 Group related integer constants using enums</h3><p>Enums are safer than <code>#define</code> or <code>const int</code>; the compiler validates values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// good:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>Week</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUNDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MONDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TUESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WEDNESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>THURSDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FRIDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SATURDAY</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLACK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=n>Week</span> <span class=n>today</span><span class=p>,</span> <span class=n>Color</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// compile-time error: type mismatch
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// poor:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>SUNDAY</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MONDAY</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLACK</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLUE</span>   <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=kt>int</span> <span class=n>today</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// compiles fine
</span></span></span></code></pre></div><p>When enum values map to specific constants, assign them explicitly; otherwise omit assignments to avoid redundancy.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// good: device types per protocol S
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>DeviceType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_UNKNOWN</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_DSMP</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_ISMG</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_WAPPORTAL</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Internal enums used only for categorization should not have explicit values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// good: session states
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>SessionState</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INIT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WAITING_FOR_RESPONSE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Avoid duplicate values; if unavoidable, qualify them:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RTCPType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SR</span> <span class=o>=</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MIN_TYPE</span> <span class=o>=</span> <span class=n>RTCP_SR</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RR</span>    <span class=o>=</span> <span class=mi>201</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SDES</span>  <span class=o>=</span> <span class=mi>202</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_BYE</span>   <span class=o>=</span> <span class=mi>203</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_APP</span>   <span class=o>=</span> <span class=mi>204</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RTPFB</span> <span class=o>=</span> <span class=mi>205</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PSFB</span>  <span class=o>=</span> <span class=mi>206</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_XR</span>  <span class=o>=</span> <span class=mi>207</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RSI</span> <span class=o>=</span> <span class=mi>208</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PUBPORTS</span> <span class=o>=</span> <span class=mi>209</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MAX_TYPE</span> <span class=o>=</span> <span class=n>RTCP_PUBPORTS</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-912-forbid-magic-numbers><a name=r9-1-2></a>Rule 9.1.2 Forbid magic numbers</h3><p>“Magic numbers” are literals whose meaning is opaque or unclear.<br>Clarity is contextual: <code>type = 12</code> is unclear, whereas <code>monthsCount = yearsCount * 12</code> is understandable.<br>Even <code>0</code> can be cryptic, e.g., <code>status = 0</code>.</p><p>Solution:<br>Comment locally used literals, or create named <code>const</code> for widely used ones.</p><p>Prohibited practices:</p><ul><li>Names just map a macro to the literal, e.g., <code>const int ZERO = 0</code></li><li>Names hard-code limits, e.g., <code>const int XX_TIMER_INTERVAL_300MS = 300</code>; use <code>XX_TIMER_INTERVAL_MS</code>.</li></ul><h3 id=rule-913-each-constant-shall-have-a-single-responsibility><a name=r9-1-3></a>Rule 9.1.3 Each constant shall have a single responsibility</h3><p>A constant must express only one concept; avoid reuse for unrelated purposes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// good: for two protocols that both allow 20-digit MSISDNs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>A_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>B_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// or use distinct namespaces
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>Namespace1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rule-914-do-not-use-memcpy_s-memset_s-to-initialize-non-pod-objects><a name=r9-1-4></a>Rule 9.1.4 Do not use <code>memcpy_s</code>, <code>memset_s</code> to initialize non-POD objects</h3><p>POD (“Plain Old Data”) includes primitive types, aggregates, etc., without non-trivial default constructors, virtual functions, or base classes.<br>Non-POD objects (e.g., classes with virtual functions) have uncertain layouts defined by the ABI; misusing memory routines leads to undefined behavior. Even for aggregates, raw memory manipulation violates information hiding and should be avoided.</p><p>See the appendix for detailed POD specifications.</p><h3 id=advice-912-declare-variables-at-point-of-first-use-and-initialize-them><a name=a9-1-2></a>Advice 9.1.2 Declare variables at point of first use and initialize them</h3><p>Using un-initialized variables is a common bug. Defining variables as late as possible and initializing immediately avoids such errors.</p><p>Declaring all variables up front leads to:</p><ul><li>Poor readability and maintenance: definition sites are far from usage sites.</li><li>Variables are hard to initialize appropriately: at the beginning of a function, we often lack enough information to initialize them, so we initialize them with some empty default (e.g., zero). That is usually a waste and can also lead to errors if the variable is used before it is assigned a valid value.</li></ul><p>Following the principle of minimizing variable scope and declaring variables as close as possible to their first use makes code easier to read and clarifies the type and initial value of every variable. In particular, initialization should be used instead of declaration followed by assignment.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad: declaration and initialization are separated
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>        <span class=c1>// default-constructed at declaration
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>;</span>  <span class=c1>// assignment operator called; definition far from declaration, harder to understand
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Good: declaration and initialization are combined, easier to understand
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=nf>name</span><span class=p>(</span><span class=s>&#34;zhangsan&#34;</span><span class=p>);</span>  <span class=c1>// constructor called directly
</span></span></span></code></pre></div><h2 id=expressions-1><a name=c9-2></a>Expressions</h2><h3 id=rule-921-do-not-reference-a-variable-again-inside-the-same-expression-that-increments-or-decrements-it><a name=r9-2-1></a>Rule 9.2.1 Do not reference a variable again inside the same expression that increments or decrements it</h3><p>C++ makes no guarantee about the order of evaluation when a variable that undergoes pre/post increment or decrement is referenced again within the same expression. Different compilers—or even different versions of the same compiler—may behave differently.<br>For portable code, never rely on such unspecified sequencing.</p><p>Notice that adding parentheses does not solve the problem, because this is a sequencing issue, not a precedence issue.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Bad: the order of evaluating b[i] and i++ is unspecified.
</span></span></span></code></pre></div><p>Write the increment/decrement on its own line:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: on its own line
</span></span></span></code></pre></div><p>Function arguments</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   <span class=c1>// Bad: cannot tell whether the increment has happened when passing the second argument
</span></span></span></code></pre></div><p>Correct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: on its own line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=rule-922-provide-a-default-branch-in-every-switch-statement><a name=r9-2-2></a>Rule 9.2.2 Provide a default branch in every switch statement</h3><p>In most cases, a switch statement must contain a default branch so that unlisted cases have well-defined behavior.</p><p>Exception:
If the control variable is of an enum type and all enumerators are covered by explicit case labels, a default branch is superfluous.<br>Modern compilers issue a warning when an enumerator in an enum is missing from the switch.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Because the switch variable is an enum and all enumerators are covered, we can omit default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>RED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoRedThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>BLUE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoBlueThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=suggestion-921-when-writing-comparisons-put-the-variable-on-the-left-and-the-constant-on-the-right><a name=a9-2-1></a>Suggestion 9.2.1 When writing comparisons, put the variable on the left and the constant on the right</h3><p>It is unnatural to read <code>if (MAX == v)</code> or even harder <code>if (MAX > v)</code>.<br>Write the more readable form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>One exception is range checks: <code>if (MIN &lt; value && value &lt; MAX)</code>, where the left boundary is a constant.</p><p>Do not worry about accidentally typing <code>=</code> instead of <code>==</code>; compilers and static-analysis tools will warn about <code>if (value = MAX)</code>. Leave typos to the tools; the code must be clear to humans.</p><h3 id=suggestion-922-use-parentheses-to-clarify-operator-precedence><a name=a9-2-2></a>Suggestion 9.2.2 Use parentheses to clarify operator precedence</h3><p>Parentheses make the intended precedence explicit, preventing bugs caused by mismatching the default precedence rules, while simultaneously improving readability. Excessive parentheses, however, can clutter the code. Some guidance:</p><ul><li>If an expression contains two or more <em>different</em> binary operators, parenthesize it.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>         <span class=cm>/* same operators, parentheses optional */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>     <span class=cm>/* comma operator, no need for extra parentheses */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>      <span class=cm>/* different operators, parentheses needed */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=p>(</span><span class=n>b</span> <span class=o>/</span> <span class=mi>5</span><span class=p>);</span>       <span class=cm>/* different operators, parentheses needed */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=p>(</span><span class=n>a</span> <span class=err>–</span> <span class=n>b</span><span class=p>);</span>    <span class=cm>/* different operators, parentheses needed */</span>
</span></span></code></pre></div><h2 id=type-casting><a name=c9-3></a>Type Casting</h2><p>Never customize behavior through type branching: that style is error-prone and a clear sign of writing C code in C++. It is inflexible; when a new type is added, every branch must be changed—and the compiler will not remind you. Use templates or virtual functions to let each type determine its behavior, rather than letting the calling code do it.</p><p>Avoid type casting; design types that clearly express what kind of object they represent without the need for casting. When designing a numeric type, decide:</p><ul><li>signed or unsigned</li><li>float vs double</li><li>int8, int16, int32, or int64</li></ul><p>Inevitably, some casts remain; C++ is close to the machine and talks to APIs whose type designs are not ideal. Still, keep them to a minimum.</p><p>Exception: if a function’s return value is intentionally ignored, first reconsider the design. If ignoring it is really appropriate, cast it to <code>(void)</code>.</p><h3 id=rule-931-use-the-c-style-casts-never-c-style-casts><a name=r9-3-1></a>Rule 9.3.1 Use the C++-style casts; never C-style casts</h3><p>C++ casts are more specific, more readable, and safer. The C++ casts are:</p><ul><li><p>For type conversions</p><ol><li><code>dynamic_cast</code> — down-cast in an inheritance hierarchy and provides run-time type checking. Avoid it by improving base/derived design instead.</li><li><code>static_cast</code> — like C-style but safer. Used for value conversions or up-casting, and resolving multiple-inheritance ambiguities. Prefer brace-init for pure arithmetic.</li><li><code>reinterpret_cast</code> — reinterprets one type as another. Undefined behaviour potential, use sparingly.</li><li><code>const_cast</code> — removes const or volatile. Suppresses immutability, leading to UB if misused.</li></ol></li><li><p>Numeric conversions (C++11 onwards)<br>Use brace-init for converting between numeric types without loss.</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=n>someFloat</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>i</span><span class=p>{</span> <span class=n>someInt32</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=suggestion-931-avoid-dynamic_cast><a name=a9-3-1></a>Suggestion 9.3.1 Avoid <code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code> depends on RTTI, letting programs discover an object’s concrete type at run time.</li><li>Its necessity usually signals a flaw in the class hierarchy; prefer redesigning classes instead.</li></ol><h3 id=suggestion-932-avoid-reinterpret_cast><a name=a9-3-2></a>Suggestion 9.3.2 Avoid <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> performs low-level re-interpretations of memory layouts and is inherently unsafe. Avoid crossing unrelated type boundaries.</p><h3 id=suggestion-933-avoid-const_cast><a name=a9-3-3></a>Suggestion 9.3.3 Avoid <code>const_cast</code></h3><p><code>const_cast</code> strips the <code>const</code> and <code>volatile</code> qualifiers off an object. Modifying a formerly const variable via such a cast yields Undefined Behaviour.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>2048</span><span class=p>;</span>      <span class=c1>// Undefined Behaviour
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span> <span class=n>i</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>  <span class=c1>// Undefined Behaviour
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=resource-acquisition-and-release><a name=c9-4></a>Resource Acquisition and Release</h2><h3 id=rule-941-use-delete-for-single-objects-and-delete-for-arrays><a name=r9-4-1></a>Rule 9.4.1 Use delete for single objects and delete[] for arrays</h3><ul><li><em>single object</em>: <code>new</code> allocates and constructs exactly one object ⇒ dispose with <code>delete</code>.</li><li><em>array</em>: <code>new[]</code> allocates space for (n) objects and constructs them ⇒ dispose with <code>delete[]</code>.</li></ul><p>Mismatching <code>new</code>/<code>new[]</code> with the wrong form of <code>delete</code> yields UB.</p><p>Wrong:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>numberArray</span><span class=p>;</span>        <span class=c1>// ← wrong
</span></span></span></code></pre></div><p>Right:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=suggestion-941-use-raii-to-track-dynamic-resources><a name=a9-4-1></a>Suggestion 9.4.1 Use RAII to track dynamic resources</h3><p>RAII = Resource Acquisition Is Initialization. Acquire a resource in a constructor; the destructor releases it. Benefits:</p><ul><li>No manual cleanup.</li><li>The resource remains valid for the scope’s lifetime.</li></ul><p>Example: mutex guard</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockGuard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span><span class=p>(</span><span class=k>const</span> <span class=n>LockType</span><span class=o>&amp;</span> <span class=n>lock</span><span class=p>)</span> <span class=o>:</span> <span class=n>lock_</span><span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span> <span class=n>lock_</span><span class=p>.</span><span class=n>Acquire</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>LockGuard</span><span class=p>()</span> <span class=p>{</span> <span class=n>lock_</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockType</span> <span class=n>lock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Update</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span> <span class=n>g</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=standard-library><a name=c9-5></a>Standard Library</h2><p>STL usage varies between products; basic rules below.</p><h3 id=rule-951-never-store-the-pointer-returned-by-stdstringc_str><a name=r9-5-1></a>Rule 9.5.1 Never store the pointer returned by std::string::c_str()</h3><p><code>string::c_str()</code> is not guaranteed to point at stable memory. A specific implementation may return memory that is released soon after the call. Therefore, call <code>string::c_str()</code> at point of use; do <strong>not</strong> store the pointer.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>   <span class=c1>// still valid here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>                     <span class=c1>// may invalidate text
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Exception: in extremely performance-critical code it is acceptable to store the pointer, provided the <code>std::string</code> is guaranteed to outlive the pointer <strong>and</strong> remain unmodified while the pointer is used.</p><h3 id=suggestion-951-prefer-stdstring-over-char><a name=a9-5-1></a>Suggestion 9.5.1 Prefer std::string over char*</h3><p>Advantages:</p><ul><li>no manual null-termination</li><li>built-in operators (<code>+</code>, <code>=</code>, <code>==</code>)</li><li>automatic memory management</li></ul><p>Be aware: some legacy STL implementations use Copy-On-Write (COW) strings. COW is not thread-safe and can cause crashes. Passing COW strings across DLL boundaries can leave dangling references. Choose a modern, non-COW STL when possible.</p><p>Exception: APIs that require <code>'char*'</code> get it from <code>std::string::c_str()</code>. Stack buffers should be plain char arrays, not <code>std::string</code> or <code>std::vector&lt;char></code>.</p><h3 id=rule-952-do-not-use-auto_ptr><a name=r9-5-2></a>Rule 9.5.2 Do not use auto_ptr</h3><p><code>std::auto_ptr</code> performs implicit (and surprising) ownership transfer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span>   <span class=c1>// p1 becomes nullptr
</span></span></span></code></pre></div><p>Therefore it is forbidden.<br>Use <code>std::unique_ptr</code> for exclusive ownership, <code>std::shared_ptr</code> for shared ownership.</p><h3 id=suggestion-952-prefer-canonical-c-headers><a name=a9-5-2></a>Suggestion 9.5.2 Prefer canonical C++ headers</h3><p>Use <code>&lt;cstdlib></code> instead of <code>&lt;stdlib.h></code>, etc.</p><h2 id=const-qualifier><a name=c9-6></a>const Qualifier</h2><p>Add <code>const</code> to variables and parameters whose values must not change. Mark member functions <code>const</code> if they do not modify the observable state.</p><h3 id=rule-961-use-const-for-pointerreference-parameters-that-are-read-only><a name=r9-6-1></a>Rule 9.6.1 Use const for pointer/reference parameters that are read-only</h3><p>Write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PrintFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>);</span>
</span></span></code></pre></div><p>instead of <code>Foo&</code>.</p><h3 id=rule-962-mark-member-functions-const-when-they-do-not-modify-the-object><a name=r9-6-2></a>Rule 9.6.2 Mark member functions const when they do not modify the object</h3><p>Accessors should always be const.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>PrintValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=suggestion-961-declare-member-variables-const-when-they-never-change-after-initialization><a name=a9-6-1></a>Suggestion 9.6.1 Declare member variables const when they never change after initialization</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span> <span class=n>dataLength_</span><span class=p>(</span><span class=n>length</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>dataLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=exceptions-1><a name=c9-7></a>Exceptions</h2><h3 id=suggestion-971-mark-functions-that-never-throw-as-noexcept-c11><a name=a9-7-1></a>Suggestion 9.7.1 Mark functions that never throw as noexcept (C++11)</h3><p>Benefits:</p><ol><li>Enables better code generation.</li><li>Standard containers only use move-construction when a move operator is noexcept. Without <code>noexcept</code> they fall back to (slower) copy-construction.</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>double</span> <span class=n>sqrt</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>Compute</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Destructor, default constructors, <code>swap</code>, and move operations must never throw.</p><h2 id=templates--generic-programming><a name=c9-8></a>Templates & Generic Programming</h2><h3 id=rule-981-prohibit-generic-programming-in-the-openharmony-project><a name=a9-8-1></a>Rule 9.8.1 Prohibit generic programming in the OpenHarmony project</h3><p>Generic programming, templates, and OOP are driven by entirely different ideas and techniques. OpenHarmony is mainly based on OOP.</p><p>Avoid templates because:</p><ol><li>Inexperienced developers tend to produce bloated, confusing code.</li><li>Template code is hard to read and debug.</li><li>Error messages are notoriously cryptic.</li><li>Templates may generate excessive code size.</li><li>Refactoring template code is difficult because its instantiations are spread across the codebase.</li></ol><p>OpenHarmony forbids template programming in <em>most</em> modules.<br>Exception: STL adaptation layers may still use templates.</p><h2 id=macros><a name=c9-9></a>Macros</h2><p>Avoid complex macros. Instead:</p><ul><li>Use <code>const</code> or enums for constants.</li><li>Replace macro functions with inline or template functions.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SQUARE(a, b) ((a) * (b))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Prefer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>Square</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><h1 id=10-modern-c-features><a name=c10></a>10 Modern C++ Features</h1><p>ISO standardized C++11 in 2011 and C++17 in March 2017. These standards add countless improvements. This chapter highlights best practices for using them effectively.</p><h2 id=brevity--safety><a name=c10-1></a>Brevity & Safety</h2><h3 id=suggestion-1011-use-auto-judiciously><a name=a10-1-1></a>Suggestion 10.1.1 Use auto judiciously</h3><ul><li>Eliminates long type names, guarantees initialization.</li><li>Deduction rules are subtle—understand them.</li><li>Prefer explicit types if clarity improves. Use <code>auto</code> only for local variables.</li></ul><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// uninitialized
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>x</span><span class=p>;</span>   <span class=c1>// compile-time error—uninitialized
</span></span></span></code></pre></div><p>Beware deduced types:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>   <span class=c1>// std::string, makes a copy
</span></span></span></code></pre></div><h3 id=rule-1011-override-virtual-functions-with-override-or-final><a name=r10-1-1></a>Rule 10.1.1 Override virtual functions with override or final</h3><p>They ensure correctness: the compiler rejects overrides whose signatures do not match the base declaration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>  <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// Error: signature differs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-1012-delete-functions-with-the-delete-keyword><a name=r10-1-2></a>Rule 10.1.2 Delete functions with the delete keyword</h3><p>Clearer and broader than making members private and undefined.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=rule-1013-prefer-nullptr-to-null-or-0><a name=r10-1-3></a>Rule 10.1.3 Prefer nullptr to NULL or 0</h3><p><code>nullptr</code> has its own type (<code>std::nullptr_t</code>) and unambiguous behaviour; 0/NULL cannot.
Or, when a null pointer is required, directly using <code>0</code> can introduce another problem: the code becomes unclear—especially when <code>auto</code> is used:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Does Find() return a pointer or an integer?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Literally, <code>0</code> is of type <code>int</code> (<code>0L</code> is <code>long</code>), so neither <code>NULL</code> nor <code>0</code> is of a pointer type.<br>When a function is overloaded for both pointer and integer types, passing <code>NULL</code> or <code>0</code> will invoke the integer overload:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>      <span class=c1>// Calls F(int), not F(int*)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>   <span class=c1>// Calls F(int), not F(int*)
</span></span></span></code></pre></div><p>Moreover, <code>sizeof(NULL) == sizeof(void*)</code> is not necessarily true, which is another potential pitfall.</p><p>Summary: directly using <code>0</code> or <code>0L</code> makes the code unclear and type-unsafe; using <code>NULL</code> is no better than <code>0</code> because it is also type-unsafe. All of them involve potential risks.</p><p>The advantage of <code>nullptr</code> is not just being a literal representation of the null pointer that clarifies the code, but also that it is definitively not an integer type.</p><p><code>nullptr</code> is of type <code>std::nullptr_t</code>, and <code>std::nullptr_t</code> can be implicitly converted to any raw pointer type, so <code>nullptr</code> can act as the null pointer for any type.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// Calls F(int*)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() returns a pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=rule-1014-prefer-using-over-typedef><a name=r10-1-4></a>Rule 10.1.4: Prefer <code>using</code> over <code>typedef</code></h3><p>Prior to C++11, you could define type aliases with <code>typedef</code>; nobody wants to repeatedly type <code>std::map&lt;uint32_t, std::vector&lt;int>></code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>SomeType</span><span class=p>;</span>
</span></span></code></pre></div><p>An alias is essentially an encapsulation of the real type. This encapsulation makes code clearer and prevents shotgun surgery when the underlying type changes.</p><p>Since C++11, <code>using</code> provides alias declarations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>SomeType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>Compare their syntaxes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Type</span> <span class=n>Alias</span><span class=p>;</span>   <span class=c1>// Is Type first or Alias first?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>Alias</span> <span class=o>=</span> <span class=n>Type</span><span class=p>;</span>   <span class=c1>// Reads like assignment—intuitive and error-proof
</span></span></span></code></pre></div><p>If that alone isn’t enough to adopt <code>using</code>, look at alias templates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Alias template definition—one line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyAllocatorVector</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>       <span class=c1>// Using the alias
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data_</span><span class=p>;</span>   <span class=c1>// Alias usable inside a template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p><code>typedef</code> does not support template parameters in aliases; workarounds are required:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Need to wrap typedef in a template struct
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyAllocatorVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// Using typedef—must append ::type
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data_</span><span class=p>;</span>  <span class=c1>// Need typename too
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=rule-1015-do-not-apply-stdmove-to-const-objects><a name=r10-1-5></a>Rule 10.1.5: Do not apply <code>std::move</code> to const objects</h3><p>Semantically, <code>std::move</code> is about <em>moving</em> an object. A const object cannot be modified and is therefore immovable, so applying <code>std::move</code> confuses readers.</p><p>Functionally, <code>std::move</code> yields an rvalue reference; for const objects this becomes <code>const&&</code>. Very few types provide move constructors or move-assignment operators taking <code>const&&</code>, so the operation usually degrades to a copy, harming performance.</p><p><strong>Bad:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>g_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>g_stringList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>myString</span> <span class=o>=</span> <span class=s>&#34;String content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>myString</span><span class=p>);</span> <span class=c1>// Bad: copies, does not move
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=s>&#34;Another string content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_stringList</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>anotherString</span><span class=p>));</span> <span class=c1>// Bad: also copies
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=smart-pointers><a name=c10-2></a>Smart Pointers</h2><h3 id=rule-1021-prefer-raw-pointers-for-singletons-data-members-etc-whose-ownership-is-never-shared><a name=r10-2-1></a>Rule 10.2.1: Prefer raw pointers for singletons, data members, etc., whose ownership is never shared</h3><p><strong>Rationale</strong><br>Smart pointers prevent leaks by automatically releasing resources but add overhead—code bloat, extra construction/destruction cost, increased memory footprint, etc.</p><p>For objects whose ownership is never transferred (singletons, data members), simply deleting them in the destructor is sufficient; avoid the extra smart-pointer overhead.</p><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>foo_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>foo_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>Exceptions</strong></p><ol><li>When returning newly created objects that need custom deleters, smart pointers are acceptable.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>CreateUniqueUser</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=o>::</span><span class=k>new</span> <span class=n>User</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>),</span> <span class=p>[](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>user</span><span class=o>-&gt;</span><span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>::</span><span class=k>delete</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>CreateSharedUser</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>.</span><span class=n>GetRefPtr</span><span class=p>(),</span> <span class=p>[</span><span class=n>ipcUser</span><span class=p>](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ipcUser</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>Use <code>shared_ptr</code> when returning a newly created object that can have multiple owners.</li></ol><h3 id=rule-1022-use-stdmake_unique-not-new-to-create-a-unique_ptr><a name=r10-2-2></a>Rule 10.2.2: Use <code>std::make_unique</code>, not <code>new</code>, to create a <code>unique_ptr</code></h3><p><strong>Rationale</strong></p><ol><li><code>make_unique</code> is more concise.</li><li>It provides exception safety in complex expressions.</li></ol><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad: type appears twice—possible inconsistency
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// Good: type appears only once
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>Repetition can cause subtle bugs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Compiles, but mismatched new[] and delete
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=mi>10</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Not exception-safe: evaluation order may be
</span></span></span><span class=line><span class=cl><span class=c1>// 1. allocate Foo
</span></span></span><span class=line><span class=cl><span class=c1>// 2. construct Foo
</span></span></span><span class=line><span class=cl><span class=c1>// 3. call Bar
</span></span></span><span class=line><span class=cl><span class=c1>// 4. construct unique_ptr&lt;Foo&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// If Bar throws, Foo leaks.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>()),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Exception-safe: no interleaving
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>Exception</strong><br><code>std::make_unique</code> does not support custom deleters.<br>Fall back to <code>new</code> only when a custom deleter is required.</p><h3 id=rule-1024-use-stdmake_shared-not-new-to-create-a-shared_ptr><a name=r10-2-4></a>Rule 10.2.4: Use <code>std::make_shared</code>, not <code>new</code>, to create a <code>shared_ptr</code></h3><p><strong>Rationale</strong><br>Besides the same consistency benefits as <code>make_unique</code>, <code>make_shared</code> offers performance gains.<br>A <code>shared_ptr</code> manages two entities:</p><ul><li>Control block (ref-count, deleter, etc.)</li><li>The owned object</li></ul><p><code>make_shared</code> allocates <em>one</em> heap block for both, whereas<br><code>std::shared_ptr&lt;MyClass>(new MyClass)</code> performs two allocations: one for <code>MyClass</code> and one for the control block, adding overhead.</p><p><strong>Exception</strong><br>Like <code>make_unique</code>, <code>make_shared</code> cannot accept a custom deleter.</p><hr><h2 id=lambda-expressions><a name=c10-3></a>Lambda Expressions</h2><h3 id=advice-1031-prefer-lambda-expressions-when-a-function-cannot-express-what-you-need-capture-locals-local-function><a name=a10-3-1></a>Advice 10.3.1: Prefer lambda expressions when a function cannot express what you need (capture locals, local function)</h3><p><strong>Rationale</strong><br>Functions cannot capture locals nor be declared in local scope. When you need such features, use lambda rather than hand-written functors.<br>Conversely, lambdas and functors can’t be overloaded; overloadable cases favor functions.<br>When both lambdas and functions work, prefer functions—always reach for the simplest tool.</p><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Overloads for int and string—natural to choose
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Needed: capture locals or appear inline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Work</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=n>LotsOfWork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>taskNum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>taskNum</span> <span class=o>&lt;</span> <span class=n>max</span><span class=p>;</span> <span class=o>++</span><span class=n>taskNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pool</span><span class=p>.</span><span class=n>Run</span><span class=p>([</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>]</span> <span class=p>{...});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=rule-1031-return-or-store-lambdas-outside-local-scope-only-by-value-capture-never-by-reference><a name=r10-3-2></a>Rule 10.3.1: Return or store lambdas outside local scope only by value capture; never by reference</h3><p><strong>Rationale</strong><br>A non-local lambda (returned, stored on heap, passed to another thread) must not hold dangling references; avoid capture by reference.</p><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Capture by reference; `local` dangles after return
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Capture by value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=advice-1032-if-you-capture-this-write-all-other-captures-explicitly><a name=a10-3-2></a>Advice 10.3.2: If you capture <code>this</code>, write all other captures explicitly</h3><p><strong>Rationale</strong><br>Inside a member function <code>[=]</code> <em>looks</em> like capture-by-copy, but it implicitly captures <code>this</code> by copy, yielding handles to every data member (i.e., <strong>reference</strong> semantics in disguise). When you really want that, write it explicitly.</p><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span>   <span class=c1>// Bad: not a true copy of data_
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span>  <span class=c1>// Uses 42
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span>  <span class=c1>// Uses 43; shows reference semantics
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda2</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=k>this</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span>   <span class=c1>// Good: explicit, no surprises
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=advice-1033-avoid-default-capture-modes><a name=a10-3-3></a>Advice 10.3.3: Avoid default capture modes</h3><p><strong>Rationale</strong><br>Lambdas support default-by-reference (<code>&</code>) and default-by-value (<code>=</code>).<br>Default-by-reference silently binds every local variable; easy to create dangling refs.</p><p>Default-by-value implicitly captures <code>this</code> and hides which variables are actually used; readers may mistakenly believe static variables are copied too.</p><p>Therefore always list the captures explicitly.</p><p><strong>Bad</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span>           <span class=c1>// only copies addend
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>         <span class=c1>// modifies global
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Good</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>addend</span><span class=p>,</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=n>baseValue</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span>   <span class=c1>// C++14 capture-init
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>        <span class=c1>// modifies local copy
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Reference: <em>Effective Modern C++</em>, Item 31: Avoid default capture modes.</p><hr><h2 id=interfaces><a name=c10-4></a>Interfaces</h2><h3 id=advice-1041-in-interfaces-not-concerned-with-ownership-pass-t-or-t-not-smart-pointers><a name=a10-4-1></a>Advice 10.4.1: In interfaces not concerned with ownership, pass <code>T*</code> or <code>T&</code>, not smart pointers</h3><p><strong>Rationale</strong></p><ol><li>Smart pointers transfer or share ownership only when needed.</li><li>Requiring smart pointers forces callers to use them (e.g., impossible to pass <code>this</code>).</li><li>Passing shared-ownership smart pointers incurs runtime overhead.</li></ol><p><strong>Example</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Accepts any int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Accepts only when ownership is to be transferred
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Accepts only when ownership is to be shared
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Ownership unchanged, but caller must hold a unique_ptr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=k>const</span> <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Accepts any int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Use</span><span class=p>(</span><span class=o>*</span><span class=n>w</span><span class=p>);</span> <span class=c1>// lifetime not relevant
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Telegram aria-label=Telegram><a target=_blank rel=noopener href=https://t.me/jqknono aria-label=Telegram><i class="fab fa-telegram"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/jqknono aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2015&ndash;2025
<span class=td-footer__authors>jqknono</span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span></div></div></div></footer></div><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script><script src=/js/deflate.js></script><script src=/js/main.min.ef02deeaa00500a3225379b19170d5b9d432263216df8955d03c6c7e12b892e4.js integrity="sha256-7wLe6qAFAKMiU3mxkXDVudQyJjIW34lV0DxsfhK4kuQ=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>