<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ko-kr class=no-js data-theme-init><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=color-scheme content="light dark"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#000000"><style>html{background:Canvas;color:CanvasText}@media(prefers-color-scheme:dark){html{background:#0b0d12;color:#e6e6e6}}html[data-theme-init] *{transition:none!important}</style><script>(function(){const t="td-color-theme",n=localStorage.getItem(t);let e=n||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");e==="auto"&&(e=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"),document.documentElement.setAttribute("data-bs-theme",e)})()</script><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>华为C++编程规范 | jqknono Blogs</title><meta name=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:url" content="https://blog.jqknono.com/ko-kr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"><meta property="og:site_name" content="jqknono Blogs"><meta property="og:title" content="华为C++编程规范"><meta property="og:description" content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta property="og:locale" content="ko_kr"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-28T17:30:10+08:00"><meta property="article:modified_time" content="2024-06-28T17:30:10+08:00"><meta property="article:tag" content="教程"><meta property="article:tag" content="程序员"><meta itemprop=name content="华为C++编程规范"><meta itemprop=description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><meta itemprop=datePublished content="2024-06-28T17:30:10+08:00"><meta itemprop=dateModified content="2024-06-28T17:30:10+08:00"><meta itemprop=wordCount content="9314"><meta itemprop=keywords content="教程,程序员"><meta name=twitter:card content="summary"><meta name=twitter:title content="华为C++编程规范"><meta name=twitter:description content="华为C++编程规范 C++语言编程规范 目的 规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。 参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。
了解C++语言的ISO标准； 熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性； 了解C++语言的标准库； 总体原则 代码需要在保证功能正确的前提下，满足可读、可维护、安全、可靠、可测试、高效、可移植的特征要求。
重点关注 约定C++语言的编程风格，比如命名，排版等。 C++语言的模块化设计，如何设计头文件，类，接口和函数。 C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。 现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。 本规范优先适于用C++17版本。 约定 规则：编程时必须遵守的约定(must)
建议：编程时应该遵守的约定(should)
本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。
例外 无论是’规则’还是’建议’，都必须理解该条目这么规定的原因，并努力遵守。 但是，有些规则和建议可能会有例外。
在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。 例外破坏了代码的一致性，请尽量避免。‘规则’的例外应该是极少的。
下列情况，应风格一致性原则优先： 修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。
2 命名 通用命名 驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)
类型 命名风格 类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称 大驼峰 函数(包括全局函数，作用域函数，成员函数) 大驼峰 全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量 小驼峰 宏，常量(const)，枚举值，goto 标签 全大写，下划线分割 注意： 上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。 上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。
文件命名 规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾 我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。
目前业界还有一些其他的后缀的表示方法：
头文件： .hh, .hpp, .hxx cpp文件：.cc, .cxx, .c 如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。 但是对于本文档，我们默认使用.h和.cpp作为后缀。"><link rel=preload href=/scss/main.min.19deb9bb49a16bab1391617801cf2d75f58ded83cae46516f211ba8fc3e9f6f9.css as=style integrity="sha256-Gd65u0mha6sTkWF4Ac8tdfWN7YPK5GUW8hG6j8Pp9vk=" crossorigin=anonymous><link href=/scss/main.min.19deb9bb49a16bab1391617801cf2d75f58ded83cae46516f211ba8fc3e9f6f9.css rel=stylesheet integrity="sha256-Gd65u0mha6sTkWF4Ac8tdfWN7YPK5GUW8hG6j8Pp9vk=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3FFTG72NE"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3FFTG72NE")}</script></head><body class="td-page td-blog"><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="td-navbar-container container-fluid flex-column flex-md-row"><a class=navbar-brand href=/ko-kr/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>jqknono Blogs</span></a><div class="td-navbar-nav-scroll td-navbar-nav-scroll--indicator" id=main_navbar><div class="scroll-indicator scroll-left"></div><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://jqknono.com target=_blank rel=noopener><span>About</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class=nav-item><a class=nav-link href=https://github.com/jqknono target=_blank rel=noopener><i class="fab fa-github" aria-hidden=true></i><span>GitHub</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class="nav-item td-navbar__lang-menu"><div class="td-lang-menu dropdown"><a class="nav-link dropdown-toggle td-lang-menu__title" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><span class=td-lang-menu__title-text>한국어</span>
<span class=td-lang-menu__title-code>KO-KR</span></a><ul class=dropdown-menu><li><a class=dropdown-item href=/blog/2024/06/28/huawei-c-programming-specification/>English</a></li><li><a class=dropdown-item href=/zh-tw/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>繁體中文</a></li><li><a class=dropdown-item href=/ja-jp/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>日本語</a></li><li><span class="dropdown-item active">한국어</span></li><li><a class=dropdown-item href=/ar-sa/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/de-de/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Deutsch</a></li><li><a class=dropdown-item href=/fr-fr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Français</a></li><li><a class=dropdown-item href=/hi-in/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>हिंदी</a></li><li><a class=dropdown-item href=/es-es/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Español</a></li><li><a class=dropdown-item href=/pt-br/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Português</a></li><li><a class=dropdown-item href=/ru-ru/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Русский</a></li><li><a class=dropdown-item href=/it-it/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Italiano</a></li><li><span class="dropdown-item disabled">Bahasa Indonesia</span></li><li><a class=dropdown-item href=/tr-tr/blog/2024/06/28/huawei-c-programlama-kurallar%C4%B1/>Türkçe</a></li><li><a class=dropdown-item href=/nl-nl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Nederlands</a></li><li><a class=dropdown-item href=/pl-pl/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>Polski</a></li><li><a class=dropdown-item href=/ar-ae/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>العربية</a></li><li><a class=dropdown-item href=/zh-cn/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/>简体中文</a></li></ul></div></li><li class="nav-item td-navbar__light-dark-menu"><div class="td-light-dark-menu dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown aria-label="Toggle theme (auto)">
<svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class=dropdown-menu aria-labelledby=bd-theme><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></div></li></ul><div class="scroll-indicator scroll-right"></div></div><div class="d-none d-lg-block td-navbar__search"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main data-bs-spy=scroll data-bs-target=.td-toc data-bs-root-margin="0px 0px -10%"><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="td-sidebar-nav collapse td-sidebar-nav--search-disabled foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-ko-krblog-li><a href=/ko-kr/blog/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-ko-krblog><span>Blogs</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20260107vibe-coding-cost-formulas-li><input type=checkbox id=m-ko-krblog20260107vibe-coding-cost-formulas-check>
<label for=m-ko-krblog20260107vibe-coding-cost-formulas-check><a href=/ko-kr/blog/2026/01/07/vibe-coding-cost-formulas/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20260107vibe-coding-cost-formulas><span>Vibe Coding 절약 비용 공식 및 임계점</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20260101windows-remote-browser-cdp-li><input type=checkbox id=m-ko-krblog20260101windows-remote-browser-cdp-check>
<label for=m-ko-krblog20260101windows-remote-browser-cdp-check><a href=/ko-kr/blog/2026/01/01/windows-remote-browser-cdp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20260101windows-remote-browser-cdp><span>Windows에서 원격 브라우저 디버깅 엔트리 포인트 설정하기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251223technical-blogs-are-dead-li><input type=checkbox id=m-ko-krblog20251223technical-blogs-are-dead-check>
<label for=m-ko-krblog20251223technical-blogs-are-dead-check><a href=/ko-kr/blog/2025/12/23/technical-blogs-are-dead/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251223technical-blogs-are-dead><span>기술 블로그는 죽었다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251212openaiec9d98-ec9e91ebaa85-ec9888ec88a0-eab090ec8381-li><input type=checkbox id=m-ko-krblog20251212openaiec9d98-ec9e91ebaa85-ec9888ec88a0-eab090ec8381-check>
<label for=m-ko-krblog20251212openaiec9d98-ec9e91ebaa85-ec9888ec88a0-eab090ec8381-check><a href=/ko-kr/blog/2025/12/12/openai%EC%9D%98-%EC%9E%91%EB%AA%85-%EC%98%88%EC%88%A0-%EA%B0%90%EC%83%81/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251212openaiec9d98-ec9e91ebaa85-ec9888ec88a0-eab090ec8381><span>OpenAI의 작명 예술 감상</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-li><input type=checkbox id=m-ko-krblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-check>
<label for=m-ko-krblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c-check><a href=/ko-kr/blog/2025/12/05/%E6%8A%A2%E5%8D%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E4%B8%AA%E5%A4%A7%E4%BE%BF%E5%AE%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251205e68aa2e58da0e69c8de58aa1e599a8e698afe4b8aae5a4a7e4bebfe5ae9c><span>선점 서버는 큰 이득입니다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251203ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-esa-pages-eab8b0eb8aa5ec9d84-eba8bceca080-ec82acec9aa9ed9598eca780-ec958aeb8a94-eab283ec9d84-eab68cec9ea5ed95a9eb8b88eb8ba4-li><input type=checkbox id=m-ko-krblog20251203ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-esa-pages-eab8b0eb8aa5ec9d84-eba8bceca080-ec82acec9aa9ed9598eca780-ec958aeb8a94-eab283ec9d84-eab68cec9ea5ed95a9eb8b88eb8ba4-check>
<label for=m-ko-krblog20251203ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-esa-pages-eab8b0eb8aa5ec9d84-eba8bceca080-ec82acec9aa9ed9598eca780-ec958aeb8a94-eab283ec9d84-eab68cec9ea5ed95a9eb8b88eb8ba4-check><a href=/ko-kr/blog/2025/12/03/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-esa-pages-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%A8%BC%EC%A0%80-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B2%83%EC%9D%84-%EA%B6%8C%EC%9E%A5%ED%95%A9%EB%8B%88%EB%8B%A4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251203ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-esa-pages-eab8b0eb8aa5ec9d84-eba8bceca080-ec82acec9aa9ed9598eca780-ec958aeb8a94-eab283ec9d84-eab68cec9ea5ed95a9eb8b88eb8ba4><span>알리바바 클라우드 ESA Pages 기능을 먼저 사용하지 않는 것을 권장합니다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251202ec958ceba6acebb094ebb094-esaec9980-ossec9d98-ed95a8eca095-li><input type=checkbox id=m-ko-krblog20251202ec958ceba6acebb094ebb094-esaec9980-ossec9d98-ed95a8eca095-check>
<label for=m-ko-krblog20251202ec958ceba6acebb094ebb094-esaec9980-ossec9d98-ed95a8eca095-check><a href=/ko-kr/blog/2025/12/02/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-esa%EC%99%80-oss%EC%9D%98-%ED%95%A8%EC%A0%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251202ec958ceba6acebb094ebb094-esaec9980-ossec9d98-ed95a8eca095><span>알리바바 ESA와 OSS의 함정</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251202windows-eab3b5ec9ca0-eb9494ebb284eab985-chrome-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20251202windows-eab3b5ec9ca0-eb9494ebb284eab985-chrome-ebb0a9ebb295-check>
<label for=m-ko-krblog20251202windows-eab3b5ec9ca0-eb9494ebb284eab985-chrome-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/12/02/windows-%EA%B3%B5%EC%9C%A0-%EB%94%94%EB%B2%84%EA%B9%85-chrome-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251202windows-eab3b5ec9ca0-eb9494ebb284eab985-chrome-ebb0a9ebb295><span>windows 공유 디버깅 chrome 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251202cloudflareeab080-ec9984eca084ed9e88-ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94eab080-li><input type=checkbox id=m-ko-krblog20251202cloudflareeab080-ec9984eca084ed9e88-ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94eab080-check>
<label for=m-ko-krblog20251202cloudflareeab080-ec9984eca084ed9e88-ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94eab080-check><a href=/ko-kr/blog/2025/12/02/cloudflare%EA%B0%80-%EC%99%84%EC%A0%84%ED%9E%88-%EC%8B%A0%EB%A2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EA%B0%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251202cloudflareeab080-ec9984eca084ed9e88-ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94eab080><span>Cloudflare가 완전히 신뢰할 수 있는가</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251201ec8b9ceba0a5-eab09cec84a0-ec9d98ebacb8-li><input type=checkbox id=m-ko-krblog20251201ec8b9ceba0a5-eab09cec84a0-ec9d98ebacb8-check>
<label for=m-ko-krblog20251201ec8b9ceba0a5-eab09cec84a0-ec9d98ebacb8-check><a href=/ko-kr/blog/2025/12/01/%EC%8B%9C%EB%A0%A5-%EA%B0%9C%EC%84%A0-%EC%9D%98%EB%AC%B8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251201ec8b9ceba0a5-eab09cec84a0-ec9d98ebacb8><span>시력 개선 의문</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251127freebies-you-can-snag-by-owning-a-domain-li><input type=checkbox id=m-ko-krblog20251127freebies-you-can-snag-by-owning-a-domain-check>
<label for=m-ko-krblog20251127freebies-you-can-snag-by-owning-a-domain-check><a href=/ko-kr/blog/2025/11/27/freebies-you-can-snag-by-owning-a-domain/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251127freebies-you-can-snag-by-owning-a-domain><span>도메인 보유 시 받을 수 있는 혜택</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251126gpt-5-higheb8a94-eab09cebb09cec9e90ec9790eab28c-eab080ec9ea5-eca081ed95a9ed959c-ebaaa8eb8db8-li><input type=checkbox id=m-ko-krblog20251126gpt-5-higheb8a94-eab09cebb09cec9e90ec9790eab28c-eab080ec9ea5-eca081ed95a9ed959c-ebaaa8eb8db8-check>
<label for=m-ko-krblog20251126gpt-5-higheb8a94-eab09cebb09cec9e90ec9790eab28c-eab080ec9ea5-eca081ed95a9ed959c-ebaaa8eb8db8-check><a href=/ko-kr/blog/2025/11/26/gpt-5-high%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EA%B0%80%EC%9E%A5-%EC%A0%81%ED%95%A9%ED%95%9C-%EB%AA%A8%EB%8D%B8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251126gpt-5-higheb8a94-eab09cebb09cec9e90ec9790eab28c-eab080ec9ea5-eca081ed95a9ed959c-ebaaa8eb8db8><span>gpt-5-high는 개발자에게 가장 적합한 모델</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251124llmec9d98-eab080eca79c-ec9db8eab084-eab090eab081-li><input type=checkbox id=m-ko-krblog20251124llmec9d98-eab080eca79c-ec9db8eab084-eab090eab081-check>
<label for=m-ko-krblog20251124llmec9d98-eab080eca79c-ec9db8eab084-eab090eab081-check><a href=/ko-kr/blog/2025/11/24/llm%EC%9D%98-%EA%B0%80%EC%A7%9C-%EC%9D%B8%EA%B0%84-%EA%B0%90%EA%B0%81/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251124llmec9d98-eab080eca79c-ec9db8eab084-eab090eab081><span>llm의 가짜 인간 감각</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251107useful-mouse-key-mapping-share-li><input type=checkbox id=m-ko-krblog20251107useful-mouse-key-mapping-share-check>
<label for=m-ko-krblog20251107useful-mouse-key-mapping-share-check><a href=/ko-kr/blog/2025/11/07/useful-mouse-key-mapping-share/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251107useful-mouse-key-mapping-share><span>유용한 마우스 키 매핑 공유</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251015traeeab080-ec8b9cec8aa4ed859c-ed9484eba1aced9484ed8ab8-ec9ca0ecb69cec9d84-ebb0a9eca780ed9598eb8a94-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20251015traeeab080-ec8b9cec8aa4ed859c-ed9484eba1aced9484ed8ab8-ec9ca0ecb69cec9d84-ebb0a9eca780ed9598eb8a94-ebb0a9ebb295-check>
<label for=m-ko-krblog20251015traeeab080-ec8b9cec8aa4ed859c-ed9484eba1aced9484ed8ab8-ec9ca0ecb69cec9d84-ebb0a9eca780ed9598eb8a94-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/10/15/trae%EA%B0%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%9C%A0%EC%B6%9C%EC%9D%84-%EB%B0%A9%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251015traeeab080-ec8b9cec8aa4ed859c-ed9484eba1aced9484ed8ab8-ec9ca0ecb69cec9d84-ebb0a9eca780ed9598eb8a94-ebb0a9ebb295><span>Trae가 시스템 프롬프트 유출을 방지하는 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251014eb8c80eab79cebaaa8-ebaaa8eb8db8ec9d98-eba6acecbd9ceba5a0-eca780ed919ceab080-eca491ec9a94ed959c-ec9db4ec9ca0-li><input type=checkbox id=m-ko-krblog20251014eb8c80eab79cebaaa8-ebaaa8eb8db8ec9d98-eba6acecbd9ceba5a0-eca780ed919ceab080-eca491ec9a94ed959c-ec9db4ec9ca0-check>
<label for=m-ko-krblog20251014eb8c80eab79cebaaa8-ebaaa8eb8db8ec9d98-eba6acecbd9ceba5a0-eca780ed919ceab080-eca491ec9a94ed959c-ec9db4ec9ca0-check><a href=/ko-kr/blog/2025/10/14/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%A6%AC%EC%BD%9C%EB%A5%A0-%EC%A7%80%ED%91%9C%EA%B0%80-%EC%A4%91%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251014eb8c80eab79cebaaa8-ebaaa8eb8db8ec9d98-eba6acecbd9ceba5a0-eca780ed919ceab080-eca491ec9a94ed959c-ec9db4ec9ca0><span>대규모 모델의 리콜률 지표가 중요한 이유</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251009dns-ed9484eb9dbcec9db4ebb284ec8b9c-ebb3b4ed98b8-ebb08f-ec82acec9aa9ec9e90-ed9484eba19ced9584-ebb0a9ec96b4-eca084eb9eb5-li><input type=checkbox id=m-ko-krblog20251009dns-ed9484eb9dbcec9db4ebb284ec8b9c-ebb3b4ed98b8-ebb08f-ec82acec9aa9ec9e90-ed9484eba19ced9584-ebb0a9ec96b4-eca084eb9eb5-check>
<label for=m-ko-krblog20251009dns-ed9484eb9dbcec9db4ebb284ec8b9c-ebb3b4ed98b8-ebb08f-ec82acec9aa9ec9e90-ed9484eba19ced9584-ebb0a9ec96b4-eca084eb9eb5-check><a href=/ko-kr/blog/2025/10/09/dns-%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C-%EB%B3%B4%ED%98%B8-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%ED%95%84-%EB%B0%A9%EC%96%B4-%EC%A0%84%EB%9E%B5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251009dns-ed9484eb9dbcec9db4ebb284ec8b9c-ebb3b4ed98b8-ebb08f-ec82acec9aa9ec9e90-ed9484eba19ced9584-ebb0a9ec96b4-eca084eb9eb5><span>DNS 프라이버시 보호 및 사용자 프로필 방어 전략</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251009dns-ec9594ed98b8ed9994-ed9484eba19ced86a0ecbd9c-ebb984eab590-dot-doh-doq-li><input type=checkbox id=m-ko-krblog20251009dns-ec9594ed98b8ed9994-ed9484eba19ced86a0ecbd9c-ebb984eab590-dot-doh-doq-check>
<label for=m-ko-krblog20251009dns-ec9594ed98b8ed9994-ed9484eba19ced86a0ecbd9c-ebb984eab590-dot-doh-doq-check><a href=/ko-kr/blog/2025/10/09/dns-%EC%95%94%ED%98%B8%ED%99%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B9%84%EA%B5%90-dot-doh-doq/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251009dns-ec9594ed98b8ed9994-ed9484eba19ced86a0ecbd9c-ebb984eab590-dot-doh-doq><span>DNS 암호화 프로토콜 비교: DoT, DoH, DoQ</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250930github-spec-kit-eab3b5ec8b9d-ebaa85ec84b8-eab8b0ebb098-eab09cebb09c-ed88b4ed82b7-ec8bacecb8b5-ebb684ec849d-li><input type=checkbox id=m-ko-krblog20250930github-spec-kit-eab3b5ec8b9d-ebaa85ec84b8-eab8b0ebb098-eab09cebb09c-ed88b4ed82b7-ec8bacecb8b5-ebb684ec849d-check>
<label for=m-ko-krblog20250930github-spec-kit-eab3b5ec8b9d-ebaa85ec84b8-eab8b0ebb098-eab09cebb09c-ed88b4ed82b7-ec8bacecb8b5-ebb684ec849d-check><a href=/ko-kr/blog/2025/09/30/github-spec-kit-%EA%B3%B5%EC%8B%9D-%EB%AA%85%EC%84%B8-%EA%B8%B0%EB%B0%98-%EA%B0%9C%EB%B0%9C-%ED%88%B4%ED%82%B7-%EC%8B%AC%EC%B8%B5-%EB%B6%84%EC%84%9D/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250930github-spec-kit-eab3b5ec8b9d-ebaa85ec84b8-eab8b0ebb098-eab09cebb09c-ed88b4ed82b7-ec8bacecb8b5-ebb684ec849d><span>GitHub Spec Kit: 공식 명세 기반 개발 툴킷 심층 분석</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250917claude-code-ec849ceb939ced8c8ced8bb0-eab3b5eab889ec9785ecb2b4-ec82acec9aa9-eab080ec9db4eb939c-ec8bacecb8b5-ebb684ec849d-ebb08f-ecb59ceca081-ed999cec9aa9ebb295-li><input type=checkbox id=m-ko-krblog20250917claude-code-ec849ceb939ced8c8ced8bb0-eab3b5eab889ec9785ecb2b4-ec82acec9aa9-eab080ec9db4eb939c-ec8bacecb8b5-ebb684ec849d-ebb08f-ecb59ceca081-ed999cec9aa9ebb295-check>
<label for=m-ko-krblog20250917claude-code-ec849ceb939ced8c8ced8bb0-eab3b5eab889ec9785ecb2b4-ec82acec9aa9-eab080ec9db4eb939c-ec8bacecb8b5-ebb684ec849d-ebb08f-ecb59ceca081-ed999cec9aa9ebb295-check><a href=/ko-kr/blog/2025/09/17/claude-code-%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0-%EA%B3%B5%EA%B8%89%EC%97%85%EC%B2%B4-%EC%82%AC%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%8B%AC%EC%B8%B5-%EB%B6%84%EC%84%9D-%EB%B0%8F-%EC%B5%9C%EC%A0%81-%ED%99%9C%EC%9A%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250917claude-code-ec849ceb939ced8c8ced8bb0-eab3b5eab889ec9785ecb2b4-ec82acec9aa9-eab080ec9db4eb939c-ec8bacecb8b5-ebb684ec849d-ebb08f-ecb59ceca081-ed999cec9aa9ebb295><span>Claude Code 서드파티 공급업체 사용 가이드 - 심층 분석 및 최적 활용법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250827ddnseba5bc-ec82acec9aa9ed9598eba0a4eba9b4-eb8f84eba994ec9db8ec9db4-ebb098eb939cec8b9c-ed9584ec9a94ed95a0eab98c-li><input type=checkbox id=m-ko-krblog20250827ddnseba5bc-ec82acec9aa9ed9598eba0a4eba9b4-eb8f84eba994ec9db8ec9db4-ebb098eb939cec8b9c-ed9584ec9a94ed95a0eab98c-check>
<label for=m-ko-krblog20250827ddnseba5bc-ec82acec9aa9ed9598eba0a4eba9b4-eb8f84eba994ec9db8ec9db4-ebb098eb939cec8b9c-ed9584ec9a94ed95a0eab98c-check><a href=/ko-kr/blog/2025/08/27/ddns%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A0%A4%EB%A9%B4-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%B4-%EB%B0%98%EB%93%9C%EC%8B%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250827ddnseba5bc-ec82acec9aa9ed9598eba0a4eba9b4-eb8f84eba994ec9db8ec9db4-ebb098eb939cec8b9c-ed9584ec9a94ed95a0eab98c><span>DDNS를 사용하려면 도메인이 반드시 필요할까?</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250722trae-ec82acec9aa9ec9790-eb8c80ed959c-eab084eb8ba8-eab3b5ec9ca0-li><input type=checkbox id=m-ko-krblog20250722trae-ec82acec9aa9ec9790-eb8c80ed959c-eab084eb8ba8-eab3b5ec9ca0-check>
<label for=m-ko-krblog20250722trae-ec82acec9aa9ec9790-eb8c80ed959c-eab084eb8ba8-eab3b5ec9ca0-check><a href=/ko-kr/blog/2025/07/22/trae-%EC%82%AC%EC%9A%A9%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8-%EA%B3%B5%EC%9C%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250722trae-ec82acec9aa9ec9790-eb8c80ed959c-eab084eb8ba8-eab3b5ec9ca0><span>trae 사용에 대한 간단 공유</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250711ebaaa8eb8db8-eca084ed9998-ec849cebb984ec8aa4ec9790-eb8c80ed959c-eab3b5eab2a9-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20250711ebaaa8eb8db8-eca084ed9998-ec849cebb984ec8aa4ec9790-eb8c80ed959c-eab3b5eab2a9-ebb0a9ebb295-check>
<label for=m-ko-krblog20250711ebaaa8eb8db8-eca084ed9998-ec849cebb984ec8aa4ec9790-eb8c80ed959c-eab3b5eab2a9-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/07/11/%EB%AA%A8%EB%8D%B8-%EC%A0%84%ED%99%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%B5%EA%B2%A9-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250711ebaaa8eb8db8-eca084ed9998-ec849cebb984ec8aa4ec9790-eb8c80ed959c-eab3b5eab2a9-ebb0a9ebb295><span>모델 전환 서비스에 대한 공격 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250710eca491eab384-ebaaa8eb8db8-ec849cebb984ec8aa4ec9d98-ec9c84ed9798-li><input type=checkbox id=m-ko-krblog20250710eca491eab384-ebaaa8eb8db8-ec849cebb984ec8aa4ec9d98-ec9c84ed9798-check>
<label for=m-ko-krblog20250710eca491eab384-ebaaa8eb8db8-ec849cebb984ec8aa4ec9d98-ec9c84ed9798-check><a href=/ko-kr/blog/2025/07/10/%EC%A4%91%EA%B3%84-%EB%AA%A8%EB%8D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%9C%84%ED%97%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250710eca491eab384-ebaaa8eb8db8-ec849cebb984ec8aa4ec9d98-ec9c84ed9798><span>중계 모델 서비스의 위험</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250710adguardhomeec9790-ed8ab8eb9e98ed94bd-ebb684ed95a0-eab8b0eb8aa5-ecb694eab080ed9598eab8b0-li><input type=checkbox id=m-ko-krblog20250710adguardhomeec9790-ed8ab8eb9e98ed94bd-ebb684ed95a0-eab8b0eb8aa5-ecb694eab080ed9598eab8b0-check>
<label for=m-ko-krblog20250710adguardhomeec9790-ed8ab8eb9e98ed94bd-ebb684ed95a0-eab8b0eb8aa5-ecb694eab080ed9598eab8b0-check><a href=/ko-kr/blog/2025/07/10/adguardhome%EC%97%90-%ED%8A%B8%EB%9E%98%ED%94%BD-%EB%B6%84%ED%95%A0-%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250710adguardhomeec9790-ed8ab8eb9e98ed94bd-ebb684ed95a0-eab8b0eb8aa5-ecb694eab080ed9598eab8b0><span>AdguardHome에 트래픽 분할 기능 추가하기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250710ed9484eba19ceca09ded8ab8-eb8ba4eab5adec96b4ec9790-eca081ed95a9ed959c-ec96b8ec96b4-ec84a0eca095-li><input type=checkbox id=m-ko-krblog20250710ed9484eba19ceca09ded8ab8-eb8ba4eab5adec96b4ec9790-eca081ed95a9ed959c-ec96b8ec96b4-ec84a0eca095-check>
<label for=m-ko-krblog20250710ed9484eba19ceca09ded8ab8-eb8ba4eab5adec96b4ec9790-eca081ed95a9ed959c-ec96b8ec96b4-ec84a0eca095-check><a href=/ko-kr/blog/2025/07/10/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%8B%A4%EA%B5%AD%EC%96%B4%EC%97%90-%EC%A0%81%ED%95%A9%ED%95%9C-%EC%96%B8%EC%96%B4-%EC%84%A0%EC%A0%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250710ed9484eba19ceca09ded8ab8-eb8ba4eab5adec96b4ec9790-eca081ed95a9ed959c-ec96b8ec96b4-ec84a0eca095><span>프로젝트 다국어에 적합한 언어 선정</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250709ed9994ec9ba8ec9db4ec9790-eb8c80ed959c-eab09deab480eca081ec9db8-ed8f89eab080-ec8b9ceb8f84-li><input type=checkbox id=m-ko-krblog20250709ed9994ec9ba8ec9db4ec9790-eb8c80ed959c-eab09deab480eca081ec9db8-ed8f89eab080-ec8b9ceb8f84-check>
<label for=m-ko-krblog20250709ed9994ec9ba8ec9db4ec9790-eb8c80ed959c-eab09deab480eca081ec9db8-ed8f89eab080-ec8b9ceb8f84-check><a href=/ko-kr/blog/2025/07/09/%ED%99%94%EC%9B%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%9D%EA%B4%80%EC%A0%81%EC%9D%B8-%ED%8F%89%EA%B0%80-%EC%8B%9C%EB%8F%84/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250709ed9994ec9ba8ec9db4ec9790-eb8c80ed959c-eab09deab480eca081ec9db8-ed8f89eab080-ec8b9ceb8f84><span>화웨이에 대한 객관적인 평가 시도</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250627cursor-ec9e90eb8f99ed9994-eb9494ebb284eab985-li><input type=checkbox id=m-ko-krblog20250627cursor-ec9e90eb8f99ed9994-eb9494ebb284eab985-check>
<label for=m-ko-krblog20250627cursor-ec9e90eb8f99ed9994-eb9494ebb284eab985-check><a href=/ko-kr/blog/2025/06/27/cursor-%EC%9E%90%EB%8F%99%ED%99%94-%EB%94%94%EB%B2%84%EA%B9%85/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250627cursor-ec9e90eb8f99ed9994-eb9494ebb284eab985><span>cursor 자동화 디버깅</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250625wsl-mirrored-eb84a4ed8ab8ec9b8ced81ac-ebaaa8eb939c-eab5acec84b1-eab080ec9db4eb939c-li><input type=checkbox id=m-ko-krblog20250625wsl-mirrored-eb84a4ed8ab8ec9b8ced81ac-ebaaa8eb939c-eab5acec84b1-eab080ec9db4eb939c-check>
<label for=m-ko-krblog20250625wsl-mirrored-eb84a4ed8ab8ec9b8ced81ac-ebaaa8eb939c-eab5acec84b1-eab080ec9db4eb939c-check><a href=/ko-kr/blog/2025/06/25/wsl-mirrored-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%93%9C-%EA%B5%AC%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250625wsl-mirrored-eb84a4ed8ab8ec9b8ced81ac-ebaaa8eb939c-eab5acec84b1-eab080ec9db4eb939c><span>WSL mirrored 네트워크 모드 구성 가이드</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250526windows-ssh-ec9b90eab2a9-eba19ceab7b8ec9db8-li><input type=checkbox id=m-ko-krblog20250526windows-ssh-ec9b90eab2a9-eba19ceab7b8ec9db8-check>
<label for=m-ko-krblog20250526windows-ssh-ec9b90eab2a9-eba19ceab7b8ec9db8-check><a href=/ko-kr/blog/2025/05/26/windows-ssh-%EC%9B%90%EA%B2%A9-%EB%A1%9C%EA%B7%B8%EC%9D%B8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250526windows-ssh-ec9b90eab2a9-eba19ceab7b8ec9db8><span>Windows SSH 원격 로그인</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250524android-eab09cebb09c-li><input type=checkbox id=m-ko-krblog20250524android-eab09cebb09c-check>
<label for=m-ko-krblog20250524android-eab09cebb09c-check><a href=/ko-kr/blog/2025/05/24/android-%EA%B0%9C%EB%B0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250524android-eab09cebb09c><span>Android 개발</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250425cnameeab3bc-txt-ecb6a9eb8f8ceba19c-ec9db8ed959c-ec9db8eca69dec849c-ebb09ceab889-ebacb8eca09c-li><input type=checkbox id=m-ko-krblog20250425cnameeab3bc-txt-ecb6a9eb8f8ceba19c-ec9db8ed959c-ec9db8eca69dec849c-ebb09ceab889-ebacb8eca09c-check>
<label for=m-ko-krblog20250425cnameeab3bc-txt-ecb6a9eb8f8ceba19c-ec9db8ed959c-ec9db8eca69dec849c-ebb09ceab889-ebacb8eca09c-check><a href=/ko-kr/blog/2025/04/25/cname%EA%B3%BC-txt-%EC%B6%A9%EB%8F%8C%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89-%EB%AC%B8%EC%A0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250425cnameeab3bc-txt-ecb6a9eb8f8ceba19c-ec9db8ed959c-ec9db8eca69dec849c-ebb09ceab889-ebacb8eca09c><span>CNAME과 TXT 충돌로 인한 인증서 발급 문제</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250330clineec9790ec849c-ec98a8-ed9484eba1aced9484ed8ab8-eab080ec9db4eb939c-li><input type=checkbox id=m-ko-krblog20250330clineec9790ec849c-ec98a8-ed9484eba1aced9484ed8ab8-eab080ec9db4eb939c-check>
<label for=m-ko-krblog20250330clineec9790ec849c-ec98a8-ed9484eba1aced9484ed8ab8-eab080ec9db4eb939c-check><a href=/ko-kr/blog/2025/03/30/cline%EC%97%90%EC%84%9C-%EC%98%A8-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EA%B0%80%EC%9D%B4%EB%93%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250330clineec9790ec849c-ec98a8-ed9484eba1aced9484ed8ab8-eab080ec9db4eb939c><span>Cline에서 온 프롬프트 가이드</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250327ec82aceab3a0-eb8f84eab5ac-li><input type=checkbox id=m-ko-krblog20250327ec82aceab3a0-eb8f84eab5ac-check>
<label for=m-ko-krblog20250327ec82aceab3a0-eb8f84eab5ac-check><a href=/ko-kr/blog/2025/03/27/%EC%82%AC%EA%B3%A0-%EB%8F%84%EA%B5%AC/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250327ec82aceab3a0-eb8f84eab5ac><span>사고 도구</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250319ec96b4eb96bbeab28c-ed9598eba9b4-eab09cebb489eb9098eca780-ec958aec9d84eab98c-li><input type=checkbox id=m-ko-krblog20250319ec96b4eb96bbeab28c-ed9598eba9b4-eab09cebb489eb9098eca780-ec958aec9d84eab98c-check>
<label for=m-ko-krblog20250319ec96b4eb96bbeab28c-ed9598eba9b4-eab09cebb489eb9098eca780-ec958aec9d84eab98c-check><a href=/ko-kr/blog/2025/03/19/%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%A9%B4-%EA%B0%9C%EB%B4%89%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250319ec96b4eb96bbeab28c-ed9598eba9b4-eab09cebb489eb9098eca780-ec958aec9d84eab98c><span>어떻게 하면 개봉되지 않을까</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250317esaec9790ec849c-cname-ebaaa8eb939ceba19c-ec9980ec9dbceb939cecb9b4eb939c-ec9db8eca69dec849ceba5bc-ebb09beb8a94-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20250317esaec9790ec849c-cname-ebaaa8eb939ceba19c-ec9980ec9dbceb939cecb9b4eb939c-ec9db8eca69dec849ceba5bc-ebb09beb8a94-ebb0a9ebb295-check>
<label for=m-ko-krblog20250317esaec9790ec849c-cname-ebaaa8eb939ceba19c-ec9980ec9dbceb939cecb9b4eb939c-ec9db8eca69dec849ceba5bc-ebb09beb8a94-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/03/17/esa%EC%97%90%EC%84%9C-cname-%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C%EB%A5%BC-%EB%B0%9B%EB%8A%94-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250317esaec9790ec849c-cname-ebaaa8eb939ceba19c-ec9980ec9dbceb939cecb9b4eb939c-ec9db8eca69dec849ceba5bc-ebb09beb8a94-ebb0a9ebb295><span>ESA에서 CNAME 모드로 와일드카드 인증서를 받는 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250317aiebb984ec849ceab080-eb8298ebb3b4eb8ba4-ed9ba8ec94ac-eb9891eb9891ed9598eb8ba4-li><input type=checkbox id=m-ko-krblog20250317aiebb984ec849ceab080-eb8298ebb3b4eb8ba4-ed9ba8ec94ac-eb9891eb9891ed9598eb8ba4-check>
<label for=m-ko-krblog20250317aiebb984ec849ceab080-eb8298ebb3b4eb8ba4-ed9ba8ec94ac-eb9891eb9891ed9598eb8ba4-check><a href=/ko-kr/blog/2025/03/17/ai%EB%B9%84%EC%84%9C%EA%B0%80-%EB%82%98%EB%B3%B4%EB%8B%A4-%ED%9B%A8%EC%94%AC-%EB%98%91%EB%98%91%ED%95%98%EB%8B%A4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250317aiebb984ec849ceab080-eb8298ebb3b4eb8ba4-ed9ba8ec94ac-eb9891eb9891ed9598eb8ba4><span>AI비서가 나보다 훨씬 똑똑하다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250304github-copilot-ec9ca0eba38c-ebaaa8eb8db8-ebb984eab590-li><input type=checkbox id=m-ko-krblog20250304github-copilot-ec9ca0eba38c-ebaaa8eb8db8-ebb984eab590-check>
<label for=m-ko-krblog20250304github-copilot-ec9ca0eba38c-ebaaa8eb8db8-ebb984eab590-check><a href=/ko-kr/blog/2025/03/04/github-copilot-%EC%9C%A0%EB%A3%8C-%EB%AA%A8%EB%8D%B8-%EB%B9%84%EA%B5%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250304github-copilot-ec9ca0eba38c-ebaaa8eb8db8-ebb984eab590><span>Github Copilot 유료 모델 비교</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250228github-copilot-agent-ebaaa8eb939c-ec82acec9aa9-eab2bded9798-eab3b5ec9ca0-li><input type=checkbox id=m-ko-krblog20250228github-copilot-agent-ebaaa8eb939c-ec82acec9aa9-eab2bded9798-eab3b5ec9ca0-check>
<label for=m-ko-krblog20250228github-copilot-agent-ebaaa8eb939c-ec82acec9aa9-eab2bded9798-eab3b5ec9ca0-check><a href=/ko-kr/blog/2025/02/28/github-copilot-agent-%EB%AA%A8%EB%93%9C-%EC%82%AC%EC%9A%A9-%EA%B2%BD%ED%97%98-%EA%B3%B5%EC%9C%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250228github-copilot-agent-ebaaa8eb939c-ec82acec9aa9-eab2bded9798-eab3b5ec9ca0><span>Github Copilot Agent 모드 사용 경험 공유</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250228eab3b5ec9aa9-ipv6eba5bc-eb8d94-ec9588eca084ed9598eab28c-ec82acec9aa9ed9598eb8a94-ebaa87-eab080eca780-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20250228eab3b5ec9aa9-ipv6eba5bc-eb8d94-ec9588eca084ed9598eab28c-ec82acec9aa9ed9598eb8a94-ebaa87-eab080eca780-ebb0a9ebb295-check>
<label for=m-ko-krblog20250228eab3b5ec9aa9-ipv6eba5bc-eb8d94-ec9588eca084ed9598eab28c-ec82acec9aa9ed9598eb8a94-ebaa87-eab080eca780-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/02/28/%EA%B3%B5%EC%9A%A9-ipv6%EB%A5%BC-%EB%8D%94-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%AA%87-%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250228eab3b5ec9aa9-ipv6eba5bc-eb8d94-ec9588eca084ed9598eab28c-ec82acec9aa9ed9598eb8a94-ebaa87-eab080eca780-ebb0a9ebb295><span>공용 IPv6를 더 안전하게 사용하는 몇 가지 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250220eab491eab3a0-ecb0a8eb8ba8ec9d98-ec8388eba19cec9ab4-ec84a0ed839d--adguardprivate-li><input type=checkbox id=m-ko-krblog20250220eab491eab3a0-ecb0a8eb8ba8ec9d98-ec8388eba19cec9ab4-ec84a0ed839d--adguardprivate-check>
<label for=m-ko-krblog20250220eab491eab3a0-ecb0a8eb8ba8ec9d98-ec8388eba19cec9ab4-ec84a0ed839d--adguardprivate-check><a href=/ko-kr/blog/2025/02/20/%EA%B4%91%EA%B3%A0-%EC%B0%A8%EB%8B%A8%EC%9D%98-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%84%A0%ED%83%9D--adguardprivate/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250220eab491eab3a0-ecb0a8eb8ba8ec9d98-ec8388eba19cec9ab4-ec84a0ed839d--adguardprivate><span>광고 차단의 새로운 선택 -- AdGuardPrivate</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250220curlec9d84-ec82acec9aa9ed9598ec97ac-dns-eab2b0eab3bc-eab080eca0b8ec98a4eab8b0-li><input type=checkbox id=m-ko-krblog20250220curlec9d84-ec82acec9aa9ed9598ec97ac-dns-eab2b0eab3bc-eab080eca0b8ec98a4eab8b0-check>
<label for=m-ko-krblog20250220curlec9d84-ec82acec9aa9ed9598ec97ac-dns-eab2b0eab3bc-eab080eca0b8ec98a4eab8b0-check><a href=/ko-kr/blog/2025/02/20/curl%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-dns-%EA%B2%B0%EA%B3%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250220curlec9d84-ec82acec9aa9ed9598ec97ac-dns-eab2b0eab3bc-eab080eca0b8ec98a4eab8b0><span>curl을 사용하여 DNS 결과 가져오기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250220bing-eab5adeca09ced8c90-ec82acec9aa9-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20250220bing-eab5adeca09ced8c90-ec82acec9aa9-ebb0a9ebb295-check>
<label for=m-ko-krblog20250220bing-eab5adeca09ced8c90-ec82acec9aa9-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/02/20/bing-%EA%B5%AD%EC%A0%9C%ED%8C%90-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250220bing-eab5adeca09ced8c90-ec82acec9aa9-ebb0a9ebb295><span>Bing 국제판 사용 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250219ec9dbcebb098eca081ec9db8-ddns-ec849cebb88ceb8f84eba994ec9db8-ec82acec9aa9-ec8b9c-eca084eab8b0ed86b5ec8ba0-eab491eb8c80ec97ad-ec849cebb984ec8aa4-eb93b1eab889-ed9598eb9dbd-ebb09cec839d-eab080eb8aa5-li><input type=checkbox id=m-ko-krblog20250219ec9dbcebb098eca081ec9db8-ddns-ec849cebb88ceb8f84eba994ec9db8-ec82acec9aa9-ec8b9c-eca084eab8b0ed86b5ec8ba0-eab491eb8c80ec97ad-ec849cebb984ec8aa4-eb93b1eab889-ed9598eb9dbd-ebb09cec839d-eab080eb8aa5-check>
<label for=m-ko-krblog20250219ec9dbcebb098eca081ec9db8-ddns-ec849cebb88ceb8f84eba994ec9db8-ec82acec9aa9-ec8b9c-eca084eab8b0ed86b5ec8ba0-eab491eb8c80ec97ad-ec849cebb984ec8aa4-eb93b1eab889-ed9598eb9dbd-ebb09cec839d-eab080eb8aa5-check><a href=/ko-kr/blog/2025/02/19/%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-ddns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A0%84%EA%B8%B0%ED%86%B5%EC%8B%A0-%EA%B4%91%EB%8C%80%EC%97%AD-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%93%B1%EA%B8%89-%ED%95%98%EB%9D%BD-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250219ec9dbcebb098eca081ec9db8-ddns-ec849cebb88ceb8f84eba994ec9db8-ec82acec9aa9-ec8b9c-eca084eab8b0ed86b5ec8ba0-eab491eb8c80ec97ad-ec849cebb984ec8aa4-eb93b1eab889-ed9598eb9dbd-ebb09cec839d-eab080eb8aa5><span>일반적인 DDns 서브도메인 사용 시 전기통신 광대역 서비스 등급 하락 발생 가능</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241231vpsec9d98-ebb3b4eba598-eba994ebaaa8eba6ac-ed95b4eca09c-li><input type=checkbox id=m-ko-krblog20241231vpsec9d98-ebb3b4eba598-eba994ebaaa8eba6ac-ed95b4eca09c-check>
<label for=m-ko-krblog20241231vpsec9d98-ebb3b4eba598-eba994ebaaa8eba6ac-ed95b4eca09c-check><a href=/ko-kr/blog/2024/12/31/vps%EC%9D%98-%EB%B3%B4%EB%A5%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%B4%EC%A0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241231vpsec9d98-ebb3b4eba598-eba994ebaaa8eba6ac-ed95b4eca09c><span>vps의 보류 메모리 해제</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241213ed8ab9eca095-ec9785ecb2b4ec9d98-dns-ecb0a8eb8ba8-ebb0a9eca780-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20241213ed8ab9eca095-ec9785ecb2b4ec9d98-dns-ecb0a8eb8ba8-ebb0a9eca780-ebb0a9ebb295-check>
<label for=m-ko-krblog20241213ed8ab9eca095-ec9785ecb2b4ec9d98-dns-ecb0a8eb8ba8-ebb0a9eca780-ebb0a9ebb295-check><a href=/ko-kr/blog/2024/12/13/%ED%8A%B9%EC%A0%95-%EC%97%85%EC%B2%B4%EC%9D%98-dns-%EC%B0%A8%EB%8B%A8-%EB%B0%A9%EC%A7%80-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241213ed8ab9eca095-ec9785ecb2b4ec9d98-dns-ecb0a8eb8ba8-ebb0a9eca780-ebb0a9ebb295><span>특정 업체의 DNS 차단 방지 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241205ec9c84ecb197-eb8f85ec849c-ec9e90eb8f99-ecb2b4ed81acec9db8-ebb08f-ec8b9ceab084-ec97b0ec9ea5-li><input type=checkbox id=m-ko-krblog20241205ec9c84ecb197-eb8f85ec849c-ec9e90eb8f99-ecb2b4ed81acec9db8-ebb08f-ec8b9ceab084-ec97b0ec9ea5-check>
<label for=m-ko-krblog20241205ec9c84ecb197-eb8f85ec849c-ec9e90eb8f99-ecb2b4ed81acec9db8-ebb08f-ec8b9ceab084-ec97b0ec9ea5-check><a href=/ko-kr/blog/2024/12/05/%EC%9C%84%EC%B1%97-%EB%8F%85%EC%84%9C-%EC%9E%90%EB%8F%99-%EC%B2%B4%ED%81%AC%EC%9D%B8-%EB%B0%8F-%EC%8B%9C%EA%B0%84-%EC%97%B0%EC%9E%A5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241205ec9c84ecb197-eb8f85ec849c-ec9e90eb8f99-ecb2b4ed81acec9db8-ebb08f-ec8b9ceab084-ec97b0ec9ea5><span>위챗 독서 자동 체크인 및 시간 연장</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241203eca080ec9c84ed9798-ed81aceba1a4eb9fac-ed9689eb8f99-ebb684ec849d-ec8898ec9db5eab3bc-eca084eb9eb5-li><input type=checkbox id=m-ko-krblog20241203eca080ec9c84ed9798-ed81aceba1a4eb9fac-ed9689eb8f99-ebb684ec849d-ec8898ec9db5eab3bc-eca084eb9eb5-check>
<label for=m-ko-krblog20241203eca080ec9c84ed9798-ed81aceba1a4eb9fac-ed9689eb8f99-ebb684ec849d-ec8898ec9db5eab3bc-eca084eb9eb5-check><a href=/ko-kr/blog/2024/12/03/%EC%A0%80%EC%9C%84%ED%97%98-%ED%81%AC%EB%A1%A4%EB%9F%AC-%ED%96%89%EB%8F%99-%EB%B6%84%EC%84%9D-%EC%88%98%EC%9D%B5%EA%B3%BC-%EC%A0%84%EB%9E%B5/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241203eca080ec9c84ed9798-ed81aceba1a4eb9fac-ed9689eb8f99-ebb684ec849d-ec8898ec9db5eab3bc-eca084eb9eb5><span>저위험 크롤러 행동 분석: 수익과 전략</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241118eca084eba0a5-eca088ec95bdec9d84-ec9c84ed95b4-eb8f85eba6bded9895-eab7b8eb9e98ed94bd-ecb9b4eb939c-eb8184eab8b0-li><input type=checkbox id=m-ko-krblog20241118eca084eba0a5-eca088ec95bdec9d84-ec9c84ed95b4-eb8f85eba6bded9895-eab7b8eb9e98ed94bd-ecb9b4eb939c-eb8184eab8b0-check>
<label for=m-ko-krblog20241118eca084eba0a5-eca088ec95bdec9d84-ec9c84ed95b4-eb8f85eba6bded9895-eab7b8eb9e98ed94bd-ecb9b4eb939c-eb8184eab8b0-check><a href=/ko-kr/blog/2024/11/18/%EC%A0%84%EB%A0%A5-%EC%A0%88%EC%95%BD%EC%9D%84-%EC%9C%84%ED%95%B4-%EB%8F%85%EB%A6%BD%ED%98%95-%EA%B7%B8%EB%9E%98%ED%94%BD-%EC%B9%B4%EB%93%9C-%EB%81%84%EA%B8%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241118eca084eba0a5-eca088ec95bdec9d84-ec9c84ed95b4-eb8f85eba6bded9895-eab7b8eb9e98ed94bd-ecb9b4eb939c-eb8184eab8b0><span>전력 절약을 위해 독립형 그래픽 카드 끄기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241115google-ebb288ec97ad-api-ec82acec9aa9-ed8a9ced86a0eba6acec96bc-li><input type=checkbox id=m-ko-krblog20241115google-ebb288ec97ad-api-ec82acec9aa9-ed8a9ced86a0eba6acec96bc-check>
<label for=m-ko-krblog20241115google-ebb288ec97ad-api-ec82acec9aa9-ed8a9ced86a0eba6acec96bc-check><a href=/ko-kr/blog/2024/11/15/google-%EB%B2%88%EC%97%AD-api-%EC%82%AC%EC%9A%A9-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241115google-ebb288ec97ad-api-ec82acec9aa9-ed8a9ced86a0eba6acec96bc><span>Google 번역 API 사용 튜토리얼</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241112ebb894eba19ceab7b8-eab09cec9db8-eca095ebb3b4-ec9ca0ecb69c-ebb0a9eca780-li><input type=checkbox id=m-ko-krblog20241112ebb894eba19ceab7b8-eab09cec9db8-eca095ebb3b4-ec9ca0ecb69c-ebb0a9eca780-check>
<label for=m-ko-krblog20241112ebb894eba19ceab7b8-eab09cec9db8-eca095ebb3b4-ec9ca0ecb69c-ebb0a9eca780-check><a href=/ko-kr/blog/2024/11/12/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%9D%B8-%EC%A0%95%EB%B3%B4-%EC%9C%A0%EC%B6%9C-%EB%B0%A9%EC%A7%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241112ebb894eba19ceab7b8-eab09cec9db8-eca095ebb3b4-ec9ca0ecb69c-ebb0a9eca780><span>블로그 개인 정보 유출 방지</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20241106windows-server-2019-ec9ea5ec8b9ceab084-ec8ba4ed9689-ec8b9c-ipv6-ec97b0eab2b0-eb818aeab980-ebacb8eca09c-li><input type=checkbox id=m-ko-krblog20241106windows-server-2019-ec9ea5ec8b9ceab084-ec8ba4ed9689-ec8b9c-ipv6-ec97b0eab2b0-eb818aeab980-ebacb8eca09c-check>
<label for=m-ko-krblog20241106windows-server-2019-ec9ea5ec8b9ceab084-ec8ba4ed9689-ec8b9c-ipv6-ec97b0eab2b0-eb818aeab980-ebacb8eca09c-check><a href=/ko-kr/blog/2024/11/06/windows-server-2019-%EC%9E%A5%EC%8B%9C%EA%B0%84-%EC%8B%A4%ED%96%89-%EC%8B%9C-ipv6-%EC%97%B0%EA%B2%B0-%EB%81%8A%EA%B9%80-%EB%AC%B8%EC%A0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20241106windows-server-2019-ec9ea5ec8b9ceab084-ec8ba4ed9689-ec8b9c-ipv6-ec97b0eab2b0-eb818aeab980-ebacb8eca09c><span>Windows Server 2019 장시간 실행 시 IPv6 연결 끊김 문제</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628snort-li><input type=checkbox id=m-ko-krblog20240628snort-check>
<label for=m-ko-krblog20240628snort-check><a href=/ko-kr/blog/2024/06/28/snort/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628snort><span>snort</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628linux-eab09cec9a94-li><input type=checkbox id=m-ko-krblog20240628linux-eab09cec9a94-check>
<label for=m-ko-krblog20240628linux-eab09cec9a94-check><a href=/ko-kr/blog/2024/06/28/linux-%EA%B0%9C%EC%9A%94/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628linux-eab09cec9a94><span>linux 개요</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ec849ceb939ced8c8ced8bb0-eb9dbcec9db4ebb88ceb9faceba6acec9d98-ed95a8eca095-li><input type=checkbox id=m-ko-krblog20240628ec849ceb939ced8c8ced8bb0-eb9dbcec9db4ebb88ceb9faceba6acec9d98-ed95a8eca095-check>
<label for=m-ko-krblog20240628ec849ceb939ced8c8ced8bb0-eb9dbcec9db4ebb88ceb9faceba6acec9d98-ed95a8eca095-check><a href=/ko-kr/blog/2024/06/28/%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%ED%95%A8%EC%A0%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ec849ceb939ced8c8ced8bb0-eb9dbcec9db4ebb88ceb9faceba6acec9d98-ed95a8eca095><span>서드파티 라이브러리의 함정</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ebaa85eba0b9eca484-eab5acebacb8-eab79cecb999-li><input type=checkbox id=m-ko-krblog20240628ebaa85eba0b9eca484-eab5acebacb8-eab79cecb999-check>
<label for=m-ko-krblog20240628ebaa85eba0b9eca484-eab5acebacb8-eab79cecb999-check><a href=/ko-kr/blog/2024/06/28/%EB%AA%85%EB%A0%B9%EC%A4%84-%EA%B5%AC%EB%AC%B8-%EA%B7%9C%EC%B9%99/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ebaa85eba0b9eca484-eab5acebacb8-eab79cecb999><span>명령줄 구문 규칙</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ebaa85eba0b9eca484-eba7a4eb89b4ec96bcec9790ec849c-eb8c80eab484ed98b8ec9d98-ec9d98ebafb8-li><input type=checkbox id=m-ko-krblog20240628ebaa85eba0b9eca484-eba7a4eb89b4ec96bcec9790ec849c-eb8c80eab484ed98b8ec9d98-ec9d98ebafb8-check>
<label for=m-ko-krblog20240628ebaa85eba0b9eca484-eba7a4eb89b4ec96bcec9790ec849c-eb8c80eab484ed98b8ec9d98-ec9d98ebafb8-check><a href=/ko-kr/blog/2024/06/28/%EB%AA%85%EB%A0%B9%EC%A4%84-%EB%A7%A4%EB%89%B4%EC%96%BC%EC%97%90%EC%84%9C-%EB%8C%80%EA%B4%84%ED%98%B8%EC%9D%98-%EC%9D%98%EB%AF%B8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ebaa85eba0b9eca484-eba7a4eb89b4ec96bcec9790ec849c-eb8c80eab484ed98b8ec9d98-ec9d98ebafb8><span>명령줄 매뉴얼에서 대괄호의 의미</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-ko-krblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-li><input type=checkbox id=m-ko-krblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check checked>
<label for=m-ko-krblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83-check><a href=/ko-kr/blog/2024/06/28/%E5%8D%8E%E4%B8%BAc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628e58d8ee4b8bac-e7bc96e7a88be8a784e88c83><span class=td-sidebar-nav-active-item>华为C++编程规范</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628eca491eab5ad-eca084ec8ba0-ipv6ec9d98-ebaa87-eab080eca780-ed8ab9eca795-li><input type=checkbox id=m-ko-krblog20240628eca491eab5ad-eca084ec8ba0-ipv6ec9d98-ebaa87-eab080eca780-ed8ab9eca795-check>
<label for=m-ko-krblog20240628eca491eab5ad-eca084ec8ba0-ipv6ec9d98-ebaa87-eab080eca780-ed8ab9eca795-check><a href=/ko-kr/blog/2024/06/28/%EC%A4%91%EA%B5%AD-%EC%A0%84%EC%8B%A0-ipv6%EC%9D%98-%EB%AA%87-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628eca491eab5ad-eca084ec8ba0-ipv6ec9d98-ebaa87-eab080eca780-ed8ab9eca795><span>중국 전신 IPv6의 몇 가지 특징</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ec999c-tcp-ec82aceab3a0ebb0a9ec8b9dec9d84-udpec9790-eca081ec9aa9ed95b4ec849ceb8a94-ec9588-eb9098eb8a94eab080-li><input type=checkbox id=m-ko-krblog20240628ec999c-tcp-ec82aceab3a0ebb0a9ec8b9dec9d84-udpec9790-eca081ec9aa9ed95b4ec849ceb8a94-ec9588-eb9098eb8a94eab080-check>
<label for=m-ko-krblog20240628ec999c-tcp-ec82aceab3a0ebb0a9ec8b9dec9d84-udpec9790-eca081ec9aa9ed95b4ec849ceb8a94-ec9588-eb9098eb8a94eab080-check><a href=/ko-kr/blog/2024/06/28/%EC%99%9C-tcp-%EC%82%AC%EA%B3%A0%EB%B0%A9%EC%8B%9D%EC%9D%84-udp%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%B4%EC%84%9C%EB%8A%94-%EC%95%88-%EB%90%98%EB%8A%94%EA%B0%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ec999c-tcp-ec82aceab3a0ebb0a9ec8b9dec9d84-udpec9790-eca081ec9aa9ed95b4ec849ceb8a94-ec9588-eb9098eb8a94eab080><span>왜 TCP 사고방식을 UDP에 적용해서는 안 되는가</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628openvpn-eb84a4ed8ab8ec9b8ced81ac-ec97b0eab2b0-ebb688eab080-li><input type=checkbox id=m-ko-krblog20240628openvpn-eb84a4ed8ab8ec9b8ced81ac-ec97b0eab2b0-ebb688eab080-check>
<label for=m-ko-krblog20240628openvpn-eb84a4ed8ab8ec9b8ced81ac-ec97b0eab2b0-ebb688eab080-check><a href=/ko-kr/blog/2024/06/28/openvpn-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%97%B0%EA%B2%B0-%EB%B6%88%EA%B0%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628openvpn-eb84a4ed8ab8ec9b8ced81ac-ec97b0eab2b0-ebb688eab080><span>openvpn 네트워크 연결 불가</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-eb84a4ed8ab8ec9b8ced81ac-ec9db4ed95b4_wfp-li><input type=checkbox id=m-ko-krblog20240628windows-eb84a4ed8ab8ec9b8ced81ac-ec9db4ed95b4_wfp-check>
<label for=m-ko-krblog20240628windows-eb84a4ed8ab8ec9b8ced81ac-ec9db4ed95b4_wfp-check><a href=/ko-kr/blog/2024/06/28/windows-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B4%ED%95%B4_wfp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-eb84a4ed8ab8ec9b8ced81ac-ec9db4ed95b4_wfp><span>Windows 네트워크 이해_WFP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-ec9db4ebb2a4ed8ab8-ecb694eca081-ec9db4ed95b4ed9598eab8b0_etw-li><input type=checkbox id=m-ko-krblog20240628windows-ec9db4ebb2a4ed8ab8-ecb694eca081-ec9db4ed95b4ed9598eab8b0_etw-check>
<label for=m-ko-krblog20240628windows-ec9db4ebb2a4ed8ab8-ecb694eca081-ec9db4ed95b4ed9598eab8b0_etw-check><a href=/ko-kr/blog/2024/06/28/windows-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0_etw/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-ec9db4ebb2a4ed8ab8-ecb694eca081-ec9db4ed95b4ed9598eab8b0_etw><span>Windows 이벤트 추적 이해하기_ETW</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628wireguard-ec84a4eca095-li><input type=checkbox id=m-ko-krblog20240628wireguard-ec84a4eca095-check>
<label for=m-ko-krblog20240628wireguard-ec84a4eca095-check><a href=/ko-kr/blog/2024/06/28/wireguard-%EC%84%A4%EC%A0%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628wireguard-ec84a4eca095><span>wireguard 설정</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-ecb0a8eb8ba8-eb84a4ed8ab8ec9b8ced81ac-ed8ab8eb9e98ed94bd-eab080eca0b8ec98a4eab8b0-li><input type=checkbox id=m-ko-krblog20240628windows-ecb0a8eb8ba8-eb84a4ed8ab8ec9b8ced81ac-ed8ab8eb9e98ed94bd-eab080eca0b8ec98a4eab8b0-check>
<label for=m-ko-krblog20240628windows-ecb0a8eb8ba8-eb84a4ed8ab8ec9b8ced81ac-ed8ab8eb9e98ed94bd-eab080eca0b8ec98a4eab8b0-check><a href=/ko-kr/blog/2024/06/28/windows-%EC%B0%A8%EB%8B%A8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-ecb0a8eb8ba8-eb84a4ed8ab8ec9b8ced81ac-ed8ab8eb9e98ed94bd-eab080eca0b8ec98a4eab8b0><span>Windows 차단 네트워크 트래픽 가져오기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-ebb0a9ed9994ebb2bd-eab480eba6ac-netsh-li><input type=checkbox id=m-ko-krblog20240628windows-ebb0a9ed9994ebb2bd-eab480eba6ac-netsh-check>
<label for=m-ko-krblog20240628windows-ebb0a9ed9994ebb2bd-eab480eba6ac-netsh-check><a href=/ko-kr/blog/2024/06/28/windows-%EB%B0%A9%ED%99%94%EB%B2%BD-%EA%B4%80%EB%A6%AC-netsh/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-ebb0a9ed9994ebb2bd-eab480eba6ac-netsh><span>Windows 방화벽 관리 - netsh</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-eab480eba0a8-eba6acec868cec8aa4-li><input type=checkbox id=m-ko-krblog20240628windows-eab480eba0a8-eba6acec868cec8aa4-check>
<label for=m-ko-krblog20240628windows-eab480eba0a8-eba6acec868cec8aa4-check><a href=/ko-kr/blog/2024/06/28/windows-%EA%B4%80%EB%A0%A8-%EB%A6%AC%EC%86%8C%EC%8A%A4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-eab480eba0a8-eba6acec868cec8aa4><span>Windows 관련 리소스</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-ed8390ec8389-li><input type=checkbox id=m-ko-krblog20240628windows-ed8390ec8389-check>
<label for=m-ko-krblog20240628windows-ed8390ec8389-check><a href=/ko-kr/blog/2024/06/28/windows-%ED%83%90%EC%83%89/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-ed8390ec8389><span>Windows 탐색</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628windows-ipv6eab480eba6ac-li><input type=checkbox id=m-ko-krblog20240628windows-ipv6eab480eba6ac-check>
<label for=m-ko-krblog20240628windows-ipv6eab480eba6ac-check><a href=/ko-kr/blog/2024/06/28/windows-ipv6%EA%B4%80%EB%A6%AC/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628windows-ipv6eab480eba6ac><span>windows-ipv6관리</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628window-message-li><input type=checkbox id=m-ko-krblog20240628window-message-check>
<label for=m-ko-krblog20240628window-message-check><a href=/ko-kr/blog/2024/06/28/window-message/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628window-message><span>window-message</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628win-to-go-li><input type=checkbox id=m-ko-krblog20240628win-to-go-check>
<label for=m-ko-krblog20240628win-to-go-check><a href=/ko-kr/blog/2024/06/28/win-to-go/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628win-to-go><span>Win-to-go</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628eab080ec8381-eba994ebaaa8eba6ac-eb9494ec8aa4ed81ac-ec84a4eca095-li><input type=checkbox id=m-ko-krblog20240628eab080ec8381-eba994ebaaa8eba6ac-eb9494ec8aa4ed81ac-ec84a4eca095-check>
<label for=m-ko-krblog20240628eab080ec8381-eba994ebaaa8eba6ac-eb9494ec8aa4ed81ac-ec84a4eca095-check><a href=/ko-kr/blog/2024/06/28/%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%84%A4%EC%A0%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628eab080ec8381-eba994ebaaa8eba6ac-eb9494ec8aa4ed81ac-ec84a4eca095><span>가상 메모리 디스크 설정</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628wsl-li><input type=checkbox id=m-ko-krblog20240628wsl-check>
<label for=m-ko-krblog20240628wsl-check><a href=/ko-kr/blog/2024/06/28/wsl/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628wsl><span>wsl</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628letsencryptec9d98-ec9db8eca69dec849c-ebb09ceab889-eca09ced959c-li><input type=checkbox id=m-ko-krblog20240628letsencryptec9d98-ec9db8eca69dec849c-ebb09ceab889-eca09ced959c-check>
<label for=m-ko-krblog20240628letsencryptec9d98-ec9db8eca69dec849c-ebb09ceab889-eca09ced959c-check><a href=/ko-kr/blog/2024/06/28/letsencrypt%EC%9D%98-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89-%EC%A0%9C%ED%95%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628letsencryptec9d98-ec9db8eca69dec849c-ebb09ceab889-eca09ced959c><span>letsencrypt의 인증서 발급 제한</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628eab084eb8ba8ed959c-ec849cebb284-ed81b4eb9dbcec9db4ec96b8ed8ab8-ecbd94eb939c-li><input type=checkbox id=m-ko-krblog20240628eab084eb8ba8ed959c-ec849cebb284-ed81b4eb9dbcec9db4ec96b8ed8ab8-ecbd94eb939c-check>
<label for=m-ko-krblog20240628eab084eb8ba8ed959c-ec849cebb284-ed81b4eb9dbcec9db4ec96b8ed8ab8-ecbd94eb939c-check><a href=/ko-kr/blog/2024/06/28/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BD%94%EB%93%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628eab084eb8ba8ed959c-ec849cebb284-ed81b4eb9dbcec9db4ec96b8ed8ab8-ecbd94eb939c><span>간단한 서버-클라이언트 코드</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628docker-ec868ceab09c-li><input type=checkbox id=m-ko-krblog20240628docker-ec868ceab09c-check>
<label for=m-ko-krblog20240628docker-ec868ceab09c-check><a href=/ko-kr/blog/2024/06/28/docker-%EC%86%8C%EA%B0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628docker-ec868ceab09c><span>docker 소개</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628copilot-ec82acec9aa9-ec9e85ebacb8-li><input type=checkbox id=m-ko-krblog20240628copilot-ec82acec9aa9-ec9e85ebacb8-check>
<label for=m-ko-krblog20240628copilot-ec82acec9aa9-ec9e85ebacb8-check><a href=/ko-kr/blog/2024/06/28/copilot-%EC%82%AC%EC%9A%A9-%EC%9E%85%EB%AC%B8/ title="Copilot 사용 입문" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628copilot-ec82acec9aa9-ec9e85ebacb8><span>Copilot 사용법 공유</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628chatgpt-user-guide-li><input type=checkbox id=m-ko-krblog20240628chatgpt-user-guide-check>
<label for=m-ko-krblog20240628chatgpt-user-guide-check><a href=/ko-kr/blog/2024/06/28/chatgpt-user-guide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628chatgpt-user-guide><span>ChatGPT 사용 가이드</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94-eb9494ec9e90ec9db8-li><input type=checkbox id=m-ko-krblog20240628ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94-eb9494ec9e90ec9db8-check>
<label for=m-ko-krblog20240628ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94-eb9494ec9e90ec9db8-check><a href=/ko-kr/blog/2024/06/28/%EC%8B%A0%EB%A2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%94%94%EC%9E%90%EC%9D%B8/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ec8ba0eba2b0ed95a0-ec8898-ec9e88eb8a94-eb9494ec9e90ec9db8><span>신뢰할 수 있는 디자인</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ed9994ec9ba8ec9db4-ec8ba0eba2b0-eab09ceb8590-li><input type=checkbox id=m-ko-krblog20240628ed9994ec9ba8ec9db4-ec8ba0eba2b0-eab09ceb8590-check>
<label for=m-ko-krblog20240628ed9994ec9ba8ec9db4-ec8ba0eba2b0-eab09ceb8590-check><a href=/ko-kr/blog/2024/06/28/%ED%99%94%EC%9B%A8%EC%9D%B4-%EC%8B%A0%EB%A2%B0-%EA%B0%9C%EB%85%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ed9994ec9ba8ec9db4-ec8ba0eba2b0-eab09ceb8590><span>화웨이 신뢰 개념</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628ed9994ec9ba8ec9db4-eb82b4ebb680-eb84a4ed8ab8ec9b8ced81ac-ebb3b4ec9588-ebb684ec849d-li><input type=checkbox id=m-ko-krblog20240628ed9994ec9ba8ec9db4-eb82b4ebb680-eb84a4ed8ab8ec9b8ced81ac-ebb3b4ec9588-ebb684ec849d-check>
<label for=m-ko-krblog20240628ed9994ec9ba8ec9db4-eb82b4ebb680-eb84a4ed8ab8ec9b8ced81ac-ebb3b4ec9588-ebb684ec849d-check><a href=/ko-kr/blog/2024/06/28/%ED%99%94%EC%9B%A8%EC%9D%B4-%EB%82%B4%EB%B6%80-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B3%B4%EC%95%88-%EB%B6%84%EC%84%9D/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628ed9994ec9ba8ec9db4-eb82b4ebb680-eb84a4ed8ab8ec9b8ced81ac-ebb3b4ec9588-ebb684ec849d><span>화웨이 내부 네트워크 보안 분석</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628about-child-protection-li><input type=checkbox id=m-ko-krblog20240628about-child-protection-check>
<label for=m-ko-krblog20240628about-child-protection-check><a href=/ko-kr/blog/2024/06/28/about-child-protection/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628about-child-protection><span>어린이의 인터넷 보호</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240628dos-ebb0a9ec96b4-li><input type=checkbox id=m-ko-krblog20240628dos-ebb0a9ec96b4-check>
<label for=m-ko-krblog20240628dos-ebb0a9ec96b4-check><a href=/ko-kr/blog/2024/06/28/dos-%EB%B0%A9%EC%96%B4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240628dos-ebb0a9ec96b4><span>DoS 방어</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240618ingress-nginxec9980-nginx-ingresseb8a94-eab099ec9d80-eab283ec9db4-ec9584eb8b99eb8b88eb8ba4-li><input type=checkbox id=m-ko-krblog20240618ingress-nginxec9980-nginx-ingresseb8a94-eab099ec9d80-eab283ec9db4-ec9584eb8b99eb8b88eb8ba4-check>
<label for=m-ko-krblog20240618ingress-nginxec9980-nginx-ingresseb8a94-eab099ec9d80-eab283ec9db4-ec9584eb8b99eb8b88eb8ba4-check><a href=/ko-kr/blog/2024/06/18/ingress-nginx%EC%99%80-nginx-ingress%EB%8A%94-%EA%B0%99%EC%9D%80-%EA%B2%83%EC%9D%B4-%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240618ingress-nginxec9980-nginx-ingresseb8a94-eab099ec9d80-eab283ec9db4-ec9584eb8b99eb8b88eb8ba4><span>ingress-nginx와 nginx ingress는 같은 것이 아닙니다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240614ec9e90ecb2b4-eab5acecb695-k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-alibaba-cloud-ebb684ec82b0-ec8aa4ed86a0eba6aceca780-ec82acec9aa9-li><input type=checkbox id=m-ko-krblog20240614ec9e90ecb2b4-eab5acecb695-k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-alibaba-cloud-ebb684ec82b0-ec8aa4ed86a0eba6aceca780-ec82acec9aa9-check>
<label for=m-ko-krblog20240614ec9e90ecb2b4-eab5acecb695-k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-alibaba-cloud-ebb684ec82b0-ec8aa4ed86a0eba6aceca780-ec82acec9aa9-check><a href=/ko-kr/blog/2024/06/14/%EC%9E%90%EC%B2%B4-%EA%B5%AC%EC%B6%95-k8s-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%97%90%EC%84%9C-alibaba-cloud-%EB%B6%84%EC%82%B0-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%82%AC%EC%9A%A9/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240614ec9e90ecb2b4-eab5acecb695-k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-alibaba-cloud-ebb684ec82b0-ec8aa4ed86a0eba6aceca780-ec82acec9aa9><span>자체 구축 K8S 클러스터에서 Alibaba Cloud 분산 스토리지 사용</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240612dns-ec849cebb984ec8aa4eba5bc-ec9db4ec9aa9ed959c-eb84a4ed8ab8ec9b8ced81ac-ec849cebb984ec8aa4ec9d98-ebb680eb939ceb9facec9ab4-eca084ed9998-li><input type=checkbox id=m-ko-krblog20240612dns-ec849cebb984ec8aa4eba5bc-ec9db4ec9aa9ed959c-eb84a4ed8ab8ec9b8ced81ac-ec849cebb984ec8aa4ec9d98-ebb680eb939ceb9facec9ab4-eca084ed9998-check>
<label for=m-ko-krblog20240612dns-ec849cebb984ec8aa4eba5bc-ec9db4ec9aa9ed959c-eb84a4ed8ab8ec9b8ced81ac-ec849cebb984ec8aa4ec9d98-ebb680eb939ceb9facec9ab4-eca084ed9998-check><a href=/ko-kr/blog/2024/06/12/dns-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EB%B6%80%EB%93%9C%EB%9F%AC%EC%9A%B4-%EC%A0%84%ED%99%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240612dns-ec849cebb984ec8aa4eba5bc-ec9db4ec9aa9ed959c-eb84a4ed8ab8ec9b8ced81ac-ec849cebb984ec8aa4ec9d98-ebb680eb939ceb9facec9ab4-eca084ed9998><span>DNS 서비스를 이용한 네트워크 서비스의 부드러운 전환</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240605ebb3bceba5a8ec9d98-ebb684eba598-ebb08f-ebb0a9ebb295eba1a0-li><input type=checkbox id=m-ko-krblog20240605ebb3bceba5a8ec9d98-ebb684eba598-ebb08f-ebb0a9ebb295eba1a0-check>
<label for=m-ko-krblog20240605ebb3bceba5a8ec9d98-ebb684eba598-ebb08f-ebb0a9ebb295eba1a0-check><a href=/ko-kr/blog/2024/06/05/%EB%B3%BC%EB%A5%A8%EC%9D%98-%EB%B6%84%EB%A5%98-%EB%B0%8F-%EB%B0%A9%EB%B2%95%EB%A1%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240605ebb3bceba5a8ec9d98-ebb684eba598-ebb08f-ebb0a9ebb295eba1a0><span>볼륨의 분류 및 방법론</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20231113ec9584eba788eca1b4-ec8aa4ed86a0ec96b4-ecbba4ebaea4eb8b88ed8bb0-eab79cecb999-li><input type=checkbox id=m-ko-krblog20231113ec9584eba788eca1b4-ec8aa4ed86a0ec96b4-ecbba4ebaea4eb8b88ed8bb0-eab79cecb999-check>
<label for=m-ko-krblog20231113ec9584eba788eca1b4-ec8aa4ed86a0ec96b4-ecbba4ebaea4eb8b88ed8bb0-eab79cecb999-check><a href=/ko-kr/blog/2023/11/13/%EC%95%84%EB%A7%88%EC%A1%B4-%EC%8A%A4%ED%86%A0%EC%96%B4-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EA%B7%9C%EC%B9%99/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20231113ec9584eba788eca1b4-ec8aa4ed86a0ec96b4-ecbba4ebaea4eb8b88ed8bb0-eab79cecb999><span>아마존 스토어 커뮤니티 규칙</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20230627okrec9d98-ed95a8eca095eab3bc-eca780ec9b90-li><input type=checkbox id=m-ko-krblog20230627okrec9d98-ed95a8eca095eab3bc-eca780ec9b90-check>
<label for=m-ko-krblog20230627okrec9d98-ed95a8eca095eab3bc-eca780ec9b90-check><a href=/ko-kr/blog/2023/06/27/okr%EC%9D%98-%ED%95%A8%EC%A0%95%EA%B3%BC-%EC%A7%80%EC%9B%90/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20230627okrec9d98-ed95a8eca095eab3bc-eca780ec9b90><span>OKR의 함정과 지원</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20230506windowsebb88ceba6aceca780-ec97b0eab2b0-ec8b9c-ipv6-ebacb8eca09c-li><input type=checkbox id=m-ko-krblog20230506windowsebb88ceba6aceca780-ec97b0eab2b0-ec8b9c-ipv6-ebacb8eca09c-check>
<label for=m-ko-krblog20230506windowsebb88ceba6aceca780-ec97b0eab2b0-ec8b9c-ipv6-ebacb8eca09c-check><a href=/ko-kr/blog/2023/05/06/windows%EB%B8%8C%EB%A6%AC%EC%A7%80-%EC%97%B0%EA%B2%B0-%EC%8B%9C-ipv6-%EB%AC%B8%EC%A0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20230506windowsebb88ceba6aceca780-ec97b0eab2b0-ec8b9c-ipv6-ebacb8eca09c><span>Windows브리지 연결 시 IPv6 문제</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20221113vs-remote-debug-li><input type=checkbox id=m-ko-krblog20221113vs-remote-debug-check>
<label for=m-ko-krblog20221113vs-remote-debug-check><a href=/ko-kr/blog/2022/11/13/vs-remote-debug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20221113vs-remote-debug><span>vs-remote-debug</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251013dns-impact-on-browsing-li><input type=checkbox id=m-ko-krblog20251013dns-impact-on-browsing-check>
<label for=m-ko-krblog20251013dns-impact-on-browsing-check><a href=/ko-kr/blog/2025/10/13/dns-impact-on-browsing/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251013dns-impact-on-browsing><span>DNS가 인터넷 사용 경험에 미치는 영향</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20251011ec98a4ed9488ec868cec8aa4-ebb894eba19ceab7b8ec9d98-ec9ea0ec9eaceca081-ebb3b4ec9588-ec9c84ed9798-eab09cec9db8eca095ebb3b4-ec9ca0ecb69c-ebb0a9ec96b4-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20251011ec98a4ed9488ec868cec8aa4-ebb894eba19ceab7b8ec9d98-ec9ea0ec9eaceca081-ebb3b4ec9588-ec9c84ed9798-eab09cec9db8eca095ebb3b4-ec9ca0ecb69c-ebb0a9ec96b4-ebb0a9ebb295-check>
<label for=m-ko-krblog20251011ec98a4ed9488ec868cec8aa4-ebb894eba19ceab7b8ec9d98-ec9ea0ec9eaceca081-ebb3b4ec9588-ec9c84ed9798-eab09cec9db8eca095ebb3b4-ec9ca0ecb69c-ebb0a9ec96b4-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/10/11/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%9D%98-%EC%9E%A0%EC%9E%AC%EC%A0%81-%EB%B3%B4%EC%95%88-%EC%9C%84%ED%97%98-%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4-%EC%9C%A0%EC%B6%9C-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20251011ec98a4ed9488ec868cec8aa4-ebb894eba19ceab7b8ec9d98-ec9ea0ec9eaceca081-ebb3b4ec9588-ec9c84ed9798-eab09cec9db8eca095ebb3b4-ec9ca0ecb69c-ebb0a9ec96b4-ebb0a9ebb295><span>오픈소스 블로그의 잠재적 보안 위험: 개인정보 유출 방어 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250820ebacb4eba38ceba19c-ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-ec97a3eca780-ebb3b4ec9588-eab080ec868desa-ec849cebb984ec8aa4-ebb09beab8b0-li><input type=checkbox id=m-ko-krblog20250820ebacb4eba38ceba19c-ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-ec97a3eca780-ebb3b4ec9588-eab080ec868desa-ec849cebb984ec8aa4-ebb09beab8b0-check>
<label for=m-ko-krblog20250820ebacb4eba38ceba19c-ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-ec97a3eca780-ebb3b4ec9588-eab080ec868desa-ec849cebb984ec8aa4-ebb09beab8b0-check><a href=/ko-kr/blog/2025/08/20/%EB%AC%B4%EB%A3%8C%EB%A1%9C-%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%97%A3%EC%A7%80-%EB%B3%B4%EC%95%88-%EA%B0%80%EC%86%8Desa-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B0%9B%EA%B8%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250820ebacb4eba38ceba19c-ec958ceba6acebb094ebb094-ed81b4eb9dbcec9ab0eb939c-ec97a3eca780-ebb3b4ec9588-eab080ec868desa-ec849cebb984ec8aa4-ebb09beab8b0><span>무료로 알리바바 클라우드 엣지 보안 가속(ESA) 서비스 받기</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20250117eab09cec9db8-eb8f84eba994ec9db8-ebb3b4ec9588-ec8ba4ecb29c-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20250117eab09cec9db8-eb8f84eba994ec9db8-ebb3b4ec9588-ec8ba4ecb29c-ebb0a9ebb295-check>
<label for=m-ko-krblog20250117eab09cec9db8-eb8f84eba994ec9db8-ebb3b4ec9588-ec8ba4ecb29c-ebb0a9ebb295-check><a href=/ko-kr/blog/2025/01/17/%EA%B0%9C%EC%9D%B8-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%B3%B4%EC%95%88-%EC%8B%A4%EC%B2%9C-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20250117eab09cec9db8-eb8f84eba994ec9db8-ebb3b4ec9588-ec8ba4ecb29c-ebb0a9ebb295><span>개인 도메인 보안 실천 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240603ebb2a0ec9db4ed84b0-ec9b8ced84b0-eb8f84ecbba4-ec868cec8aa4-eab080ec868d-li><input type=checkbox id=m-ko-krblog20240603ebb2a0ec9db4ed84b0-ec9b8ced84b0-eb8f84ecbba4-ec868cec8aa4-eab080ec868d-check>
<label for=m-ko-krblog20240603ebb2a0ec9db4ed84b0-ec9b8ced84b0-eb8f84ecbba4-ec868cec8aa4-eab080ec868d-check><a href=/ko-kr/blog/2024/06/03/%EB%B2%A0%EC%9D%B4%ED%84%B0-%EC%9B%8C%ED%84%B0-%EB%8F%84%EC%BB%A4-%EC%86%8C%EC%8A%A4-%EA%B0%80%EC%86%8D/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240603ebb2a0ec9db4ed84b0-ec9b8ced84b0-eb8f84ecbba4-ec868cec8aa4-eab080ec868d><span>베이터 워터 도커 소스 가속</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240528eba6aceb8885ec8aa4-eb84a4ed8ab8ec9b8ced81ac-ebacb8eca09c-ed95b4eab2b0-li><input type=checkbox id=m-ko-krblog20240528eba6aceb8885ec8aa4-eb84a4ed8ab8ec9b8ced81ac-ebacb8eca09c-ed95b4eab2b0-check>
<label for=m-ko-krblog20240528eba6aceb8885ec8aa4-eb84a4ed8ab8ec9b8ced81ac-ebacb8eca09c-ed95b4eab2b0-check><a href=/ko-kr/blog/2024/05/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240528eba6aceb8885ec8aa4-eb84a4ed8ab8ec9b8ced81ac-ebacb8eca09c-ed95b4eab2b0><span>리눅스 네트워크 문제 해결</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240527windows-ec8b9cec8aa4ed859c-ec84a4ecb998-ebb08f-ed999cec84b1ed9994-massgravedev-ec8381ec84b8-ec868ceab09c-li><input type=checkbox id=m-ko-krblog20240527windows-ec8b9cec8aa4ed859c-ec84a4ecb998-ebb08f-ed999cec84b1ed9994-massgravedev-ec8381ec84b8-ec868ceab09c-check>
<label for=m-ko-krblog20240527windows-ec8b9cec8aa4ed859c-ec84a4ecb998-ebb08f-ed999cec84b1ed9994-massgravedev-ec8381ec84b8-ec868ceab09c-check><a href=/ko-kr/blog/2024/05/27/windows-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%B9%98-%EB%B0%8F-%ED%99%9C%EC%84%B1%ED%99%94-massgrave.dev-%EC%83%81%EC%84%B8-%EC%86%8C%EA%B0%9C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240527windows-ec8b9cec8aa4ed859c-ec84a4ecb998-ebb08f-ed999cec84b1ed9994-massgravedev-ec8381ec84b8-ec868ceab09c><span>Windows 시스템 설치 및 활성화 - massgrave.dev 상세 소개</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240527k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-eba19ceb939c-ebb0b8eb9fb0ec8bb1-ed9b84-ec9a94ecb2ad-ec9b90ebb3b8-ipeba5bc-ebb3b4eca1b4ed9598eb8a94-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20240527k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-eba19ceb939c-ebb0b8eb9fb0ec8bb1-ed9b84-ec9a94ecb2ad-ec9b90ebb3b8-ipeba5bc-ebb3b4eca1b4ed9598eb8a94-ebb0a9ebb295-check>
<label for=m-ko-krblog20240527k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-eba19ceb939c-ebb0b8eb9fb0ec8bb1-ed9b84-ec9a94ecb2ad-ec9b90ebb3b8-ipeba5bc-ebb3b4eca1b4ed9598eb8a94-ebb0a9ebb295-check><a href=/ko-kr/blog/2024/05/27/k8s-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%97%90%EC%84%9C-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1-%ED%9B%84-%EC%9A%94%EC%B2%AD-%EC%9B%90%EB%B3%B8-ip%EB%A5%BC-%EB%B3%B4%EC%A1%B4%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240527k8s-ed81b4eb9facec8aa4ed84b0ec9790ec849c-eba19ceb939c-ebb0b8eb9fb0ec8bb1-ed9b84-ec9a94ecb2ad-ec9b90ebb3b8-ipeba5bc-ebb3b4eca1b4ed9598eb8a94-ebb0a9ebb295><span>K8s 클러스터에서 로드 밸런싱 후 요청 원본 IP를 보존하는 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240521wireguardeab080-ed86b5ec8ba0ec82ac-udp-qosec9790-eb8c80ed95aded9598eb8a94-ec9984eca084ed959c-ec8694eba3a8ec8598-li><input type=checkbox id=m-ko-krblog20240521wireguardeab080-ed86b5ec8ba0ec82ac-udp-qosec9790-eb8c80ed95aded9598eb8a94-ec9984eca084ed959c-ec8694eba3a8ec8598-check>
<label for=m-ko-krblog20240521wireguardeab080-ed86b5ec8ba0ec82ac-udp-qosec9790-eb8c80ed95aded9598eb8a94-ec9984eca084ed959c-ec8694eba3a8ec8598-check><a href=/ko-kr/blog/2024/05/21/wireguard%EA%B0%80-%ED%86%B5%EC%8B%A0%EC%82%AC-udp-qos%EC%97%90-%EB%8C%80%ED%95%AD%ED%95%98%EB%8A%94-%EC%99%84%EC%A0%84%ED%95%9C-%EC%86%94%EB%A3%A8%EC%85%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240521wireguardeab080-ed86b5ec8ba0ec82ac-udp-qosec9790-eb8c80ed95aded9598eb8a94-ec9984eca084ed959c-ec8694eba3a8ec8598><span>WireGuard가 통신사 UDP QoS에 대항하는 완전한 솔루션</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240520ec868cec8898ed8c8c-ec8ba0ec9e85-ebb3b4eab3a0-li><input type=checkbox id=m-ko-krblog20240520ec868cec8898ed8c8c-ec8ba0ec9e85-ebb3b4eab3a0-check>
<label for=m-ko-krblog20240520ec868cec8898ed8c8c-ec8ba0ec9e85-ebb3b4eab3a0-check><a href=/ko-kr/blog/2024/05/20/%EC%86%8C%EC%88%98%ED%8C%8C-%EC%8B%A0%EC%9E%85-%EB%B3%B4%EA%B3%A0/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240520ec868cec8898ed8c8c-ec8ba0ec9e85-ebb3b4eab3a0><span>소수파 신입 보고</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240518ec9ab0ed959cec9d98-eb8c80ed9598eb8a98ec8388ec9ab0-ec8b9cec9ea5ec9db4-eab080eab3b5-ec849cebb984ec8aa4eba5bc-eca09ceab3b5ed95a9eb8b88eb8ba4-li><input type=checkbox id=m-ko-krblog20240518ec9ab0ed959cec9d98-eb8c80ed9598eb8a98ec8388ec9ab0-ec8b9cec9ea5ec9db4-eab080eab3b5-ec849cebb984ec8aa4eba5bc-eca09ceab3b5ed95a9eb8b88eb8ba4-check>
<label for=m-ko-krblog20240518ec9ab0ed959cec9d98-eb8c80ed9598eb8a98ec8388ec9ab0-ec8b9cec9ea5ec9db4-eab080eab3b5-ec849cebb984ec8aa4eba5bc-eca09ceab3b5ed95a9eb8b88eb8ba4-check><a href=/ko-kr/blog/2024/05/18/%EC%9A%B0%ED%95%9C%EC%9D%98-%EB%8C%80%ED%95%98%EB%8A%98%EC%83%88%EC%9A%B0-%EC%8B%9C%EC%9E%A5%EC%9D%B4-%EA%B0%80%EA%B3%B5-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%A9%EB%8B%88%EB%8B%A4/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240518ec9ab0ed959cec9d98-eb8c80ed9598eb8a98ec8388ec9ab0-ec8b9cec9ea5ec9db4-eab080eab3b5-ec849cebb984ec8aa4eba5bc-eca09ceab3b5ed95a9eb8b88eb8ba4><span>우한의 대하늘새우 시장이 가공 서비스를 제공합니다</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240518ec9e90ecb2b4-eab5acecb695-dns-ec849cebb984ec8aa4ec9790ec849c-eb84a4ed8ab8ec9b8ced81ac-eab2bded9798ec9d84-ed96a5ec8381ec8b9ced82a4eb8a94-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20240518ec9e90ecb2b4-eab5acecb695-dns-ec849cebb984ec8aa4ec9790ec849c-eb84a4ed8ab8ec9b8ced81ac-eab2bded9798ec9d84-ed96a5ec8381ec8b9ced82a4eb8a94-ebb0a9ebb295-check>
<label for=m-ko-krblog20240518ec9e90ecb2b4-eab5acecb695-dns-ec849cebb984ec8aa4ec9790ec849c-eb84a4ed8ab8ec9b8ced81ac-eab2bded9798ec9d84-ed96a5ec8381ec8b9ced82a4eb8a94-ebb0a9ebb295-check><a href=/ko-kr/blog/2024/05/18/%EC%9E%90%EC%B2%B4-%EA%B5%AC%EC%B6%95-dns-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B2%BD%ED%97%98%EC%9D%84-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240518ec9e90ecb2b4-eab5acecb695-dns-ec849cebb984ec8aa4ec9790ec849c-eb84a4ed8ab8ec9b8ced81ac-eab2bded9798ec9d84-ed96a5ec8381ec8b9ced82a4eb8a94-ebb0a9ebb295><span>자체 구축 DNS 서비스에서 네트워크 경험을 향상시키는 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240516eb9494ec9e90ec9db8-ed8ca8ed84b4ec9790eb8a94-eca095ed9995ed9e88-ebaa87-eab080eca780-ec9b90ecb999ec9db4-ec9e88ec9d84eab98c-li><input type=checkbox id=m-ko-krblog20240516eb9494ec9e90ec9db8-ed8ca8ed84b4ec9790eb8a94-eca095ed9995ed9e88-ebaa87-eab080eca780-ec9b90ecb999ec9db4-ec9e88ec9d84eab98c-check>
<label for=m-ko-krblog20240516eb9494ec9e90ec9db8-ed8ca8ed84b4ec9790eb8a94-eca095ed9995ed9e88-ebaa87-eab080eca780-ec9b90ecb999ec9db4-ec9e88ec9d84eab98c-check><a href=/ko-kr/blog/2024/05/16/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%97%90%EB%8A%94-%EC%A0%95%ED%99%95%ED%9E%88-%EB%AA%87-%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240516eb9494ec9e90ec9db8-ed8ca8ed84b4ec9790eb8a94-eca095ed9995ed9e88-ebaa87-eab080eca780-ec9b90ecb999ec9db4-ec9e88ec9d84eab98c><span>디자인 패턴에는 정확히 몇 가지 원칙이 있을까?</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240509eb8ba4eca491-ed948ceb9eabed8fbc-ecbd98ed8590ecb8a0-ebb0b0ed8fac-ed88b4--ec9db4ec83a4ec98a4ec96bc-ecb2b4ed9798-li><input type=checkbox id=m-ko-krblog20240509eb8ba4eca491-ed948ceb9eabed8fbc-ecbd98ed8590ecb8a0-ebb0b0ed8fac-ed88b4--ec9db4ec83a4ec98a4ec96bc-ecb2b4ed9798-check>
<label for=m-ko-krblog20240509eb8ba4eca491-ed948ceb9eabed8fbc-ecbd98ed8590ecb8a0-ebb0b0ed8fac-ed88b4--ec9db4ec83a4ec98a4ec96bc-ecb2b4ed9798-check><a href=/ko-kr/blog/2024/05/09/%EB%8B%A4%EC%A4%91-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%BD%98%ED%85%90%EC%B8%A0-%EB%B0%B0%ED%8F%AC-%ED%88%B4--%EC%9D%B4%EC%83%A4%EC%98%A4%EC%96%BC-%EC%B2%B4%ED%97%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240509eb8ba4eca491-ed948ceb9eabed8fbc-ecbd98ed8590ecb8a0-ebb0b0ed8fac-ed88b4--ec9db4ec83a4ec98a4ec96bc-ecb2b4ed9798><span>다중 플랫폼 콘텐츠 배포 툴--'이샤오얼' 체험</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240509eab09cec9db8ed9994-ecb694ecb29c-ed8eb8eba6aced959c-eb8f84eab5acec9db8eab080-ec9db8eca780-ed95a8eca095ec9db8eab080-li><input type=checkbox id=m-ko-krblog20240509eab09cec9db8ed9994-ecb694ecb29c-ed8eb8eba6aced959c-eb8f84eab5acec9db8eab080-ec9db8eca780-ed95a8eca095ec9db8eab080-check>
<label for=m-ko-krblog20240509eab09cec9db8ed9994-ecb694ecb29c-ed8eb8eba6aced959c-eb8f84eab5acec9db8eab080-ec9db8eca780-ed95a8eca095ec9db8eab080-check><a href=/ko-kr/blog/2024/05/09/%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-%ED%8E%B8%EB%A6%AC%ED%95%9C-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80-%EC%9D%B8%EC%A7%80-%ED%95%A8%EC%A0%95%EC%9D%B8%EA%B0%80/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240509eab09cec9db8ed9994-ecb694ecb29c-ed8eb8eba6aced959c-eb8f84eab5acec9db8eab080-ec9db8eca780-ed95a8eca095ec9db8eab080><span>개인화 추천: 편리한 도구인가, 인지 함정인가?</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240509ed8590ec84bced8ab8-ed81b4eb9dbcec9ab0eb939c-eab09cebb09cec9e90-ecbba4ebaea4eb8b88ed8bb0-ecb0bdec9e91-eab2bded9798-li><input type=checkbox id=m-ko-krblog20240509ed8590ec84bced8ab8-ed81b4eb9dbcec9ab0eb939c-eab09cebb09cec9e90-ecbba4ebaea4eb8b88ed8bb0-ecb0bdec9e91-eab2bded9798-check>
<label for=m-ko-krblog20240509ed8590ec84bced8ab8-ed81b4eb9dbcec9ab0eb939c-eab09cebb09cec9e90-ecbba4ebaea4eb8b88ed8bb0-ecb0bdec9e91-eab2bded9798-check><a href=/ko-kr/blog/2024/05/09/%ED%85%90%EC%84%BC%ED%8A%B8-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EC%B0%BD%EC%9E%91-%EA%B2%BD%ED%97%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240509ed8590ec84bced8ab8-ed81b4eb9dbcec9ab0eb939c-eab09cebb09cec9e90-ecbba4ebaea4eb8b88ed8bb0-ecb0bdec9e91-eab2bded9798><span>텐센트 클라우드 개발자 커뮤니티 창작 경험</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240509eca790ec849cec9d98-ecb0bdec9e91-ecb2b4ed9798-li><input type=checkbox id=m-ko-krblog20240509eca790ec849cec9d98-ecb0bdec9e91-ecb2b4ed9798-check>
<label for=m-ko-krblog20240509eca790ec849cec9d98-ecb0bdec9e91-ecb2b4ed9798-check><a href=/ko-kr/blog/2024/05/09/%EC%A7%90%EC%84%9C%EC%9D%98-%EC%B0%BD%EC%9E%91-%EC%B2%B4%ED%97%98/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240509eca790ec849cec9d98-ecb0bdec9e91-ecb2b4ed9798><span>짐서의 창작 체험</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240509chatgpt-vpn-ecb0a8eb8ba8-ec9ab0ed9a8c-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20240509chatgpt-vpn-ecb0a8eb8ba8-ec9ab0ed9a8c-ebb0a9ebb295-check>
<label for=m-ko-krblog20240509chatgpt-vpn-ecb0a8eb8ba8-ec9ab0ed9a8c-ebb0a9ebb295-check><a href=/ko-kr/blog/2024/05/09/chatgpt-vpn-%EC%B0%A8%EB%8B%A8-%EC%9A%B0%ED%9A%8C-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240509chatgpt-vpn-ecb0a8eb8ba8-ec9ab0ed9a8c-ebb0a9ebb295><span>ChatGPT VPN 차단 우회 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog20240507windows-edge-ebb88ceb9dbcec9ab0eca080-eca780ec97b0-ed9884ec8381-ed95b4eab2b0-ebb0a9ebb295-li><input type=checkbox id=m-ko-krblog20240507windows-edge-ebb88ceb9dbcec9ab0eca080-eca780ec97b0-ed9884ec8381-ed95b4eab2b0-ebb0a9ebb295-check>
<label for=m-ko-krblog20240507windows-edge-ebb88ceb9dbcec9ab0eca080-eca780ec97b0-ed9884ec8381-ed95b4eab2b0-ebb0a9ebb295-check><a href=/ko-kr/blog/2024/05/07/windows-edge-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%97%B0-%ED%98%84%EC%83%81-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog20240507windows-edge-ebb88ceb9dbcec9ab0eca080-eca780ec97b0-ed9884ec8381-ed95b4eab2b0-ebb0a9ebb295><span>Windows Edge 브라우저 지연 현상 해결 방법</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog10101-li><input type=checkbox id=m-ko-krblog10101-check>
<label for=m-ko-krblog10101-check><a href=/ko-kr/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog10101><span></span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-ko-krblog10101-li><input type=checkbox id=m-ko-krblog10101-check>
<label for=m-ko-krblog10101-check><a href=/ko-kr/blog/1/01/01/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-ko-krblog10101><span></span></a></label></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"></div><div class=td-toc data-proofer-ignore><div class=td-toc-title><span class=td-toc-title__text></span>
<a class=td-toc-title__link title href=#></a></div><nav id=TableOfContents><ul><li><a href=#目的>目的</a></li><li><a href=#总体原则>总体原则</a></li><li><a href=#重点关注>重点关注</a></li><li><a href=#约定>约定</a></li><li><a href=#例外>例外</a></li></ul><ul><li><a href=#通用命名>通用命名</a></li><li><a href=#文件命名>文件命名</a><ul><li><a href=#规则221-c文件以cpp结尾头文件以h结尾>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</a></li><li><a href=#规则222-c文件名和类名保持一致>规则2.2.2 C++文件名和类名保持一致</a></li></ul></li><li><a href=#函数命名>函数命名</a></li><li><a href=#类型命名>类型命名</a><ul><li><a href=#建议241-避免滥用-typedef或者define-对基本类型起别名>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</a></li></ul></li><li><a href=#变量命名>变量命名</a><ul><li><a href=#规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀>规则2.5.1 全局变量应增加 ‘g_’ 前缀，静态变量命名不需要加特殊前缀</a></li><li><a href=#规则252-类的成员变量命名以小驼峰加后下划线组成>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</a></li></ul></li><li><a href=#宏常量枚举命名>宏、常量、枚举命名</a></li></ul><ul><li><a href=#行宽>行宽</a><ul><li><a href=#规则311-行宽不超过-120-个字符>规则3.1.1 行宽不超过 120 个字符</a></li></ul></li><li><a href=#缩进>缩进</a><ul><li><a href=#规则321-使用空格进行缩进每次缩进4个空格>规则3.2.1 使用空格进行缩进，每次缩进4个空格</a></li></ul></li><li><a href=#大括号>大括号</a><ul><li><a href=#规则331-使用-kr-缩进风格>规则3.3.1 使用 K&amp;R 缩进风格</a></li></ul></li><li><a href=#函数声明和定义>函数声明和定义</a><ul><li><a href=#规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</a></li></ul></li><li><a href=#函数调用>函数调用</a><ul><li><a href=#规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</a></li></ul></li><li><a href=#if语句>if语句</a><ul><li><a href=#规则361-if语句必须要使用大括号>规则3.6.1 if语句必须要使用大括号</a></li><li><a href=#规则362-禁止-ifelseelse-if-写在同一行>规则3.6.2 禁止 if/else/else if 写在同一行</a></li></ul></li><li><a href=#循环语句>循环语句</a><ul><li><a href=#规则371-循环语句必须使用大括号>规则3.7.1 循环语句必须使用大括号</a></li></ul></li><li><a href=#switch语句>switch语句</a><ul><li><a href=#规则381-switch-语句的-casedefault-要缩进一层>规则3.8.1 switch 语句的 case/default 要缩进一层</a></li></ul></li><li><a href=#表达式>表达式</a><ul><li><a href=#建议391-表达式换行要保持换行的一致性运算符放行末>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</a></li></ul></li><li><a href=#变量赋值>变量赋值</a><ul><li><a href=#规则3101-多个变量定义和赋值语句不允许写在一行>规则3.10.1 多个变量定义和赋值语句不允许写在一行</a></li></ul></li><li><a href=#初始化>初始化</a><ul><li><a href=#规则3111-初始化换行时要有缩进并进行合理对齐>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</a></li></ul></li><li><a href=#指针与引用>指针与引用</a><ul><li><a href=#建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.1 指针类型"<code>*</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li><li><a href=#建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格>建议3.12.2 引用类型"<code>&</code>“跟随变量名或者类型，不要两边都留有或者都没有空格</a></li></ul></li><li><a href=#编译预处理>编译预处理</a><ul><li><a href=#规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进>规则3.13.1 编译预处理的”#“统一放在行首，嵌套编译预处理语句时，”#“可以进行缩进</a></li><li><a href=#规则3132-避免使用宏>规则3.13.2 避免使用宏</a></li><li><a href=#规则3133-禁止使用宏来表示常量>规则3.13.3 禁止使用宏来表示常量</a></li><li><a href=#规则3134-禁止使用函数式宏>规则3.13.4 禁止使用函数式宏</a></li></ul></li><li><a href=#空格和空行>空格和空行</a><ul><li><a href=#规则3141-水平空格应该突出关键字和重要信息避免不必要的留白>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</a></li><li><a href=#建议3141-合理安排空行保持代码紧凑>建议3.14.1 合理安排空行，保持代码紧凑</a></li></ul></li><li><a href=#类>类</a><ul><li><a href=#规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</a></li><li><a href=#规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</a></li></ul></li></ul><ul><li><a href=#注释风格>注释风格</a></li><li><a href=#文件头注释>文件头注释</a><ul><li><a href=#规则31-文件头注释必须包含版权许可>规则3.1 文件头注释必须包含版权许可</a></li></ul></li><li><a href=#函数头注释>函数头注释</a><ul><li><a href=#规则431-公有public函数必须编写函数头注释>规则4.3.1 公有（public）函数必须编写函数头注释</a></li><li><a href=#规则432-禁止空有格式的函数头注释>规则4.3.2 禁止空有格式的函数头注释</a></li></ul></li><li><a href=#代码注释>代码注释</a><ul><li><a href=#规则441-代码注释放于对应代码的上方或右边>规则4.4.1 代码注释放于对应代码的上方或右边</a></li><li><a href=#规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</a></li><li><a href=#规则443-不用的代码段直接删除不要注释掉>规则4.4.3 不用的代码段直接删除，不要注释掉</a></li></ul></li></ul><ul><li><a href=#头文件职责>头文件职责</a><ul><li><a href=#建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</a></li></ul></li><li><a href=#头文件依赖>头文件依赖</a><ul><li><a href=#规则521-禁止头文件循环依赖>规则5.2.1 禁止头文件循环依赖</a></li><li><a href=#规则522-头文件必须编写define保护防止重复包含>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</a></li><li><a href=#规则523-禁止通过声明的方式引用外部函数接口变量>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</a></li><li><a href=#规则524-禁止在extern-c中包含头文件>规则5.2.4 禁止在extern “C"中包含头文件</a></li><li><a href=#建议521尽量避免使用前置声明而是通过include来包含头文件>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</a></li></ul></li></ul><ul><li><a href=#命名空间>命名空间</a><ul><li><a href=#建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</a></li><li><a href=#规则611-不要在头文件中或者include之前使用using导入命名空间>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</a></li></ul></li><li><a href=#全局函数和静态成员函数>全局函数和静态成员函数</a><ul><li><a href=#建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</a></li></ul></li><li><a href=#全局常量和静态成员常量>全局常量和静态成员常量</a><ul><li><a href=#建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</a></li></ul></li><li><a href=#全局变量>全局变量</a><ul><li><a href=#建议641-尽量避免使用全局变量考虑使用单例模式>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</a></li></ul></li></ul><ul><li><a href=#构造拷贝构造赋值和析构函数>构造，拷贝构造，赋值和析构函数</a><ul><li><a href=#规则711-类的成员变量必须显式初始化>规则7.1.1 类的成员变量必须显式初始化</a></li><li><a href=#建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</a></li><li><a href=#规则712-为避免隐式转换将单参数构造函数声明为explicit>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</a></li><li><a href=#规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</a></li><li><a href=#规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则715-移动构造和移动赋值操作符应该是成对出现或者禁止>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</a></li><li><a href=#规则716-禁止在构造函数和析构函数中调用虚函数>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</a></li><li><a href=#规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</a></li></ul></li><li><a href=#继承>继承</a><ul><li><a href=#规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</a></li><li><a href=#규칙-722-가상-함수에서-기본-매개변수-값을-금지합니다>규칙 7.2.2 가상 함수에서 기본 매개변수 값을 금지합니다.</a></li><li><a href=#규칙-723-상속받은-비가상-함수를-재정의하는-것을-금지합니다>규칙 7.2.3 상속받은 비가상 함수를 재정의하는 것을 금지합니다.</a></li></ul></li><li><a href=#다중-상속>다중 상속</a><ul><li><a href=#권고-731-인터페이스-분리와-다중-역할-조합을-위해-다중-상속을-사용합니다>권고 7.3.1 인터페이스 분리와 다중 역할 조합을 위해 다중 상속을 사용합니다.</a></li></ul></li><li><a href=#오버로딩>오버로딩</a></li></ul><ul><li><a href=#함수-설계>함수 설계</a><ul><li><a href=#규칙-811-함수가-너무-길어지지-않도록-하며-함수는-50행을-초과하지-않아야-합니다공백-및-주석-제외>규칙 8.1.1 함수가 너무 길어지지 않도록 하며, 함수는 50행을 초과하지 않아야 합니다(공백 및 주석 제외)</a></li></ul></li><li><a href=#인라인-함수>인라인 함수</a><ul><li><a href=#권고-821-인라인-함수는-10행을-초과하지-않아야-합니다공백-및-주석-제외>권고 8.2.1 인라인 함수는 10행을 초과하지 않아야 합니다(공백 및 주석 제외)</a></li></ul></li><li><a href=#함수-매개변수>함수 매개변수</a><ul><li><a href=#권고-831-참조를-사용하여-포인터를-대체합니다>권고 8.3.1 참조를 사용하여 포인터를 대체합니다.</a></li><li><a href=#권고-832-강력한-타입-매개변수를-사용하고-void-사용을-피하십시오>권고 8.3.2 강력한 타입 매개변수를 사용하고 void* 사용을 피하십시오.</a></li><li><a href=#권고-833-함수의-매개변수-개수는-5개를-초과하지-않아야-합니다>권고 8.3.3 함수의 매개변수 개수는 5개를 초과하지 않아야 합니다.</a></li></ul></li></ul><ul><li><a href=#상수와-초기화>상수와 초기화</a><ul><li><a href=#규칙-911-매크로를-상수를-나타내는-데-사용하는-것을-금지합니다>규칙 9.1.1 매크로를 상수를 나타내는 데 사용하는 것을 금지합니다.</a></li><li><a href=#권고-911-관련된-정수-상수-그룹은-열거형으로-정의합니다>권고 9.1.1 관련된 정수 상수 그룹은 열거형으로 정의합니다.</a></li><li><a href=#규칙-912-악마의-숫자를-사용하지-마십시오>규칙 9.1.2 악마의 숫자를 사용하지 마십시오.</a></li><li><a href=#규칙-913-상수는-단일-책임을-보장해야-합니다>규칙 9.1.3 상수는 단일 책임을 보장해야 합니다.</a></li><li><a href=#규칙-914-memcpy_s-memset_s를-사용하여-pod-객체를-초기화하는-것을-금지합니다>규칙 9.1.4 memcpy_s, memset_s를 사용하여 POD 객체를 초기화하는 것을 금지합니다.</a></li><li><a href=#권고-912-변수는-사용할-때-선언하고-초기화합니다>권고 9.1.2 변수는 사용할 때 선언하고 초기화합니다.</a></li></ul></li><li><a href=#표현식>표현식</a><ul><li><a href=#규칙-921-변수의-증가-또는-감소-연산을-포함한-표현식에서-해당-변수를-다시-참조하는-것은-금지합니다>규칙 9.2.1 변수의 증가 또는 감소 연산을 포함한 표현식에서 해당 변수를 다시 참조하는 것은 금지합니다.</a></li><li><a href=#규칙-922-switch-문에는-default-분기를-포함해야-합니다>규칙 9.2.2 switch 문에는 default 분기를 포함해야 합니다.</a></li><li><a href=#권고-921-표현식-비교-시-왼쪽은-변화를-오른쪽은-불변을-따르는-원칙을-따르십시오>권고 9.2.1 표현식 비교 시 왼쪽은 변화를, 오른쪽은 불변을 따르는 원칙을 따르십시오.</a></li><li><a href=#권고-922-괄호를-사용하여-연산자의-우선순위를-명확히-하십시오>권고 9.2.2 괄호를 사용하여 연산자의 우선순위를 명확히 하십시오.</a></li></ul></li><li><a href=#타입-변환>타입 변환</a><ul><li><a href=#규칙-931-타입-변환을-사용해야-한다면-c가-제공하는-타입-변환을-사용하고-c-스타일-타입-변환을-사용하지-마십시오>규칙 9.3.1 타입 변환을 사용해야 한다면 C++가 제공하는 타입 변환을 사용하고 C 스타일 타입 변환을 사용하지 마십시오.</a></li><li><a href=#권고-931-dynamic_cast-사용을-피하십시오>권고 9.3.1 <code>dynamic_cast</code> 사용을 피하십시오.</a></li><li><a href=#권고-932-reinterpret_cast-사용을-피하십시오>권고 9.3.2 <code>reinterpret_cast</code> 사용을 피하십시오.</a></li><li><a href=#권고-933-const_cast-사용을-피하십시오>권고 9.3.3 <code>const_cast</code> 사용을 피하십시오.</a></li></ul></li><li><a href=#자원-할당과-해제>자원 할당과 해제</a><ul><li><a href=#규칙-941-단일-객체-해제는-delete를-배열-객체-해제는-delete-를-사용합니다>규칙 9.4.1 단일 객체 해제는 delete를, 배열 객체 해제는 delete []를 사용합니다.</a></li><li><a href=#권고-941-raii-특성을-사용하여-동적-할당을-추적하는-데-도움을-주십시오>권고 9.4.1 RAII 특성을 사용하여 동적 할당을 추적하는 데 도움을 주십시오.</a></li></ul></li><li><a href=#표준-라이브러리>표준 라이브러리</a><ul><li><a href=#규칙-951-stdstring의-c_str이-반환하는-포인터를-저장하지-마십시오>규칙 9.5.1 std::string의 c_str()이 반환하는 포인터를 저장하지 마십시오.</a></li><li><a href=#권고-951-stdstring을-char-대신-사용하십시오>권고 9.5.1 std::string을 char* 대신 사용하십시오.</a></li><li><a href=#규칙-952-auto_ptr-사용을-금지합니다>규칙 9.5.2 auto_ptr 사용을 금지합니다.</a></li><li><a href=#권고-952-새로운-표준-헤더-파일을-사용합니다>권고 9.5.2 새로운 표준 헤더 파일을 사용합니다.</a></li></ul></li><li><a href=#const의-사용법>const의 사용법</a><ul><li><a href=#규칙-961-포인터와-참조-타입의-매개변수가-수정되지-않는-경우-const를-사용합니다>규칙 9.6.1 포인터와 참조 타입의 매개변수가 수정되지 않는 경우 const를 사용합니다.</a></li><li><a href=#규칙-962-멤버-변수를-수정하지-않는-멤버-함수에는-const로-수정합니다>규칙 9.6.2 멤버 변수를 수정하지 않는 멤버 함수에는 const로 수정합니다.</a></li><li><a href=#권고-961-초기화-후-수정되지-않는-멤버-변수를-const로-정의합니다>권고 9.6.1 초기화 후 수정되지 않는 멤버 변수를 const로 정의합니다.</a></li></ul></li><li><a href=#예외>예외</a><ul><li><a href=#권고-971-c11에서-함수가-예외를-발생시키지-않는-경우-noexcept로-선언합니다>권고 9.7.1 C++11에서 함수가 예외를 발생시키지 않는 경우 noexcept로 선언합니다.</a></li></ul></li><li><a href=#템플릿과-제네릭-프로그래밍>템플릿과 제네릭 프로그래밍</a><ul><li><a href=#규칙-981-openharmony-프로젝트에서-제네릭-프로그래밍을-금지합니다>규칙 9.8.1 OpenHarmony 프로젝트에서 제네릭 프로그래밍을 금지합니다.</a></li></ul></li><li><a href=#매크로>매크로</a></li></ul><ul><li><a href=#코드-간결성과-안전성-향상>코드 간결성과 안전성 향상</a><ul><li><a href=#권고-1011-적절히auto를-사용합니다>권고 10.1.1 적절히<code>auto</code>를 사용합니다.</a></li><li><a href=#규칙-1011-가상-함수를-재정의할-때는override또는final키워드를-사용합니다>규칙 10.1.1 가상 함수를 재정의할 때는<code>override</code>또는<code>final</code>키워드를 사용합니다.</a></li><li><a href=#규칙-1012-delete키워드를-사용하여-함수-삭제합니다>규칙 10.1.2 <code>delete</code>키워드를 사용하여 함수 삭제합니다.</a></li><li><a href=#규칙-1013-nullptr을-사용하고null또는0을-사용하지-마십시오>규칙 10.1.3 <code>nullptr</code>을 사용하고<code>NULL</code>또는<code>0</code>을 사용하지 마십시오.</a></li><li><a href=#규칙-1014-using을-사용하고typedef를-사용하지-마십시오>규칙 10.1.4 <code>using</code>을 사용하고<code>typedef</code>를 사용하지 마십시오.</a></li><li><a href=#규칙-1015-const-객체에stdmove를-금지합니다>규칙 10.1.5 const 객체에<code>std::move</code>를 금지합니다.</a></li></ul></li><li><a href=#스마트-포인터>스마트 포인터</a><ul><li><a href=#규칙-1021-소유권이-다방면에서-보유되지-않는-단일-인스턴스-클래스-멤버-등은-스마트-포인터보다-원시-포인터를-우선-사용합니다>규칙 10.2.1 소유권이 다방면에서 보유되지 않는 단일 인스턴스, 클래스 멤버 등은 스마트 포인터보다 원시 포인터를 우선 사용합니다.</a></li><li><a href=#규칙-1022-stdmake_unique를-사용하고new를-사용하지-마십시오>규칙 10.2.2 <code>std::make_unique</code>를 사용하고<code>new</code>를 사용하지 마십시오.</a></li><li><a href=#규칙-1024-stdmake_shared를-사용하고new를-사용하지-마십시오>규칙 10.2.4 <code>std::make_shared</code>를 사용하고<code>new</code>를 사용하지 마십시오.</a></li></ul></li><li><a href=#lambda>Lambda</a><ul><li><a href=#권고-1031-함수가-작동하지-않을-때lambda지역-변수-캡처-또는-지역-함수-작성를-선택합니다>권고 10.3.1 함수가 작동하지 않을 때<code>lambda</code>(지역 변수 캡처 또는 지역 함수 작성)를 선택합니다.</a></li><li><a href=#규칙-1031-비지역-범위에서lambdas를-사용할-때는-참조로-캡처를-피합니다>규칙 10.3.1 비지역 범위에서<code>lambdas</code>를 사용할 때는 참조로 캡처를 피합니다.</a></li><li><a href=#권고-1032-this를-캡처하는-경우-모든-변수를-명시적으로-캡처합니다>권고 10.3.2 <code>this</code>를 캡처하는 경우 모든 변수를 명시적으로 캡처합니다.</a></li><li><a href=#권고-1033-기본-캡처-모드-사용을-피합니다>권고 10.3.3 기본 캡처 모드 사용을 피합니다.</a></li></ul></li><li><a href=#인터페이스>인터페이스</a><ul><li><a href=#권고-1041-소유권과-무관한-시나리오에서는-스마트-포인터-대신t또는t를-매개변수로-사용합니다>권고 10.4.1 소유권과 무관한 시나리오에서는 스마트 포인터 대신<code>T*</code>또는<code>T&</code>를 매개변수로 사용합니다.</a></li></ul></li></ul></nav></div><div class="taxonomy taxonomy-terms-cloud taxo-tags"><h5 class=taxonomy-title>Taxonomy Cloud</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/2025/ data-taxonomy-term=2025><span class=taxonomy-label>2025</span><span class=taxonomy-count>9</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/adguard-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=adguard-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>Adguard 시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>12</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/ai%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%A7%80%EC%9B%90/ data-taxonomy-term=ai%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%A7%80%EC%9B%90><span class=taxonomy-label>AI프로그래밍지원</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/api/ data-taxonomy-term=api><span class=taxonomy-label>API</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/blog/ data-taxonomy-term=blog><span class=taxonomy-label>Blog</span><span class=taxonomy-count>8</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/cdn/ data-taxonomy-term=cdn><span class=taxonomy-label>CDN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/cdp/ data-taxonomy-term=cdp><span class=taxonomy-label>CDP</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/chrome/ data-taxonomy-term=chrome><span class=taxonomy-label>Chrome</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/claude-code/ data-taxonomy-term=claude-code><span class=taxonomy-label>Claude Code</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/cline/ data-taxonomy-term=cline><span class=taxonomy-label>Cline</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/codex/ data-taxonomy-term=codex><span class=taxonomy-label>Codex</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/copilot-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=copilot-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>Copilot 시리즈</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/cursor/ data-taxonomy-term=cursor><span class=taxonomy-label>Cursor</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/deepseek/ data-taxonomy-term=deepseek><span class=taxonomy-label>DeepSeek</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/dns/ data-taxonomy-term=dns><span class=taxonomy-label>DNS</span><span class=taxonomy-count>8</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/docker/ data-taxonomy-term=docker><span class=taxonomy-label>Docker</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/doh/ data-taxonomy-term=doh><span class=taxonomy-label>DoH</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/dot/ data-taxonomy-term=dot><span class=taxonomy-label>DoT</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/environment/ data-taxonomy-term=environment><span class=taxonomy-label>Environment</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/esa/ data-taxonomy-term=esa><span class=taxonomy-label>ESA</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/gemini/ data-taxonomy-term=gemini><span class=taxonomy-label>Gemini</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/github/ data-taxonomy-term=github><span class=taxonomy-label>GitHub</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/github-pages/ data-taxonomy-term=github-pages><span class=taxonomy-label>GitHub Pages</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/google/ data-taxonomy-term=google><span class=taxonomy-label>Google</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/kubenetes-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=kubenetes-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>Kubenetes 시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/kubenetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=kubenetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>Kubenetes 클러스터 시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/kubenetes%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=kubenetes%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>Kubenetes클러스터시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/linux/ data-taxonomy-term=linux><span class=taxonomy-label>Linux</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/llm/ data-taxonomy-term=llm><span class=taxonomy-label>Llm</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/massgrave/ data-taxonomy-term=massgrave><span class=taxonomy-label>Massgrave</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/moonshot/ data-taxonomy-term=moonshot><span class=taxonomy-label>Moonshot</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/quic/ data-taxonomy-term=quic><span class=taxonomy-label>QUIC</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/spec-driven-development/ data-taxonomy-term=spec-driven-development><span class=taxonomy-label>Spec-Driven Development</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/udp-qos/ data-taxonomy-term=udp-qos><span class=taxonomy-label>UDP QoS</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/vpn/ data-taxonomy-term=vpn><span class=taxonomy-label>VPN</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/vs-code-%ED%99%95%EC%9E%A5/ data-taxonomy-term=vs-code-%ED%99%95%EC%9E%A5><span class=taxonomy-label>VS Code 확장</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>13</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/windows-%EB%AC%B8%EC%A0%9C-%EC%9E%A1%EC%A6%9D/ data-taxonomy-term=windows-%EB%AC%B8%EC%A0%9C-%EC%9E%A1%EC%A6%9D><span class=taxonomy-label>Windows 문제 잡증</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/wireguard/ data-taxonomy-term=wireguard><span class=taxonomy-label>WireGuard</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/wsl/ data-taxonomy-term=wsl><span class=taxonomy-label>Wsl</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/z-ai/ data-taxonomy-term=z-ai><span class=taxonomy-label>Z-AI</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/ data-taxonomy-term=%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87><span class=taxonomy-label>疑难杂症</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B0%9C%EB%B0%9C-%EB%8F%84%EA%B5%AC/ data-taxonomy-term=%EA%B0%9C%EB%B0%9C-%EB%8F%84%EA%B5%AC><span class=taxonomy-label>개발 도구</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4-%EB%B3%B4%ED%98%B8/ data-taxonomy-term=%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4-%EB%B3%B4%ED%98%B8><span class=taxonomy-label>개인정보 보호</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B2%8C%EC%9E%84-%EC%9D%B4%EB%A1%A0/ data-taxonomy-term=%EA%B2%8C%EC%9E%84-%EC%9D%B4%EB%A1%A0><span class=taxonomy-label>게임 이론</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B3%B5%EA%B2%A9%EA%B3%BC-%EB%B0%A9%EC%96%B4/ data-taxonomy-term=%EA%B3%B5%EA%B2%A9%EA%B3%BC-%EB%B0%A9%EC%96%B4><span class=taxonomy-label>공격과 방어</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B5%90%EC%9C%A1/ data-taxonomy-term=%EA%B5%90%EC%9C%A1><span class=taxonomy-label>교육</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B5%90%EC%A0%95/ data-taxonomy-term=%EA%B5%90%EC%A0%95><span class=taxonomy-label>교정</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EA%B8%B0%EC%88%A0/ data-taxonomy-term=%EA%B8%B0%EC%88%A0><span class=taxonomy-label>기술</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%82%9C%ED%95%B4%ED%95%9C-%EB%AC%B8%EC%A0%9C/ data-taxonomy-term=%EB%82%9C%ED%95%B4%ED%95%9C-%EB%AC%B8%EC%A0%9C><span class=taxonomy-label>난해한 문제</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/ data-taxonomy-term=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC><span class=taxonomy-label>네트워크</span><span class=taxonomy-count>19</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%88%A0/ data-taxonomy-term=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%88%A0><span class=taxonomy-label>네트워크 기술</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%B5%9C%EC%A0%81%ED%99%94/ data-taxonomy-term=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%B5%9C%EC%A0%81%ED%99%94><span class=taxonomy-label>네트워크 최적화</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%8F%84%EA%B5%AC/ data-taxonomy-term=%EB%8F%84%EA%B5%AC><span class=taxonomy-label>도구</span><span class=taxonomy-count>16</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%B3%B4%EC%95%88/ data-taxonomy-term=%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%B3%B4%EC%95%88><span class=taxonomy-label>도메인 보안</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%94%94%EC%9E%90%EC%9D%B8/ data-taxonomy-term=%EB%94%94%EC%9E%90%EC%9D%B8><span class=taxonomy-label>디자인</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%94%94%EC%A7%80%ED%84%B8-%EB%A6%AC%ED%84%B0%EB%9F%AC%EC%8B%9C/ data-taxonomy-term=%EB%94%94%EC%A7%80%ED%84%B8-%EB%A6%AC%ED%84%B0%EB%9F%AC%EC%8B%9C><span class=taxonomy-label>디지털 리터러시</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%A6%AC%EB%B7%B0/ data-taxonomy-term=%EB%A6%AC%EB%B7%B0><span class=taxonomy-label>리뷰</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%AC%B4%EB%A3%8C-%EC%B2%B4%ED%97%98/ data-taxonomy-term=%EB%AC%B4%EB%A3%8C-%EC%B2%B4%ED%97%98><span class=taxonomy-label>무료 체험</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/ data-taxonomy-term=%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0><span class=taxonomy-label>문제 해결</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%AF%B8%EB%B6%84%EB%A5%98/ data-taxonomy-term=%EB%AF%B8%EB%B6%84%EB%A5%98><span class=taxonomy-label>미분류</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B2%95%EB%A5%A0/ data-taxonomy-term=%EB%B2%95%EB%A5%A0><span class=taxonomy-label>법률</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B2%A0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=%EB%B2%A0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>베이터 시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B3%B4%EC%95%88/ data-taxonomy-term=%EB%B3%B4%EC%95%88><span class=taxonomy-label>보안</span><span class=taxonomy-count>12</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B6%80%EB%AA%A8-%ED%86%B5%EC%A0%9C/ data-taxonomy-term=%EB%B6%80%EB%AA%A8-%ED%86%B5%EC%A0%9C><span class=taxonomy-label>부모 통제</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/ data-taxonomy-term=%EB%B8%94%EB%A1%9C%EA%B7%B8><span class=taxonomy-label>블로그</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EB%B9%84%EC%9A%A9/ data-taxonomy-term=%EB%B9%84%EC%9A%A9><span class=taxonomy-label>비용</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%ED%95%84/ data-taxonomy-term=%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%ED%95%84><span class=taxonomy-label>사용자 프로필</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%82%AC%EC%9D%B4%EB%B2%84-%EB%B3%B4%EC%95%88/ data-taxonomy-term=%EC%82%AC%EC%9D%B4%EB%B2%84-%EB%B3%B4%EC%95%88><span class=taxonomy-label>사이버 보안</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0-%EA%B3%B5%EA%B8%89%EC%97%85%EC%B2%B4/ data-taxonomy-term=%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0-%EA%B3%B5%EA%B8%89%EC%97%85%EC%B2%B4><span class=taxonomy-label>서드파티 공급업체</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/ data-taxonomy-term=%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94><span class=taxonomy-label>성능 최적화</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%88%98%ED%95%84/ data-taxonomy-term=%EC%88%98%ED%95%84><span class=taxonomy-label>수필</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C/ data-taxonomy-term=%EC%8B%9C%EC%8A%A4%ED%85%9C><span class=taxonomy-label>시스템</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98/ data-taxonomy-term=%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98><span class=taxonomy-label>시스템 유지보수</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%95%84%EB%8F%99-%EB%B3%B4%ED%98%B8/ data-taxonomy-term=%EC%95%84%EB%8F%99-%EB%B3%B4%ED%98%B8><span class=taxonomy-label>아동 보호</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/ data-taxonomy-term=%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C><span class=taxonomy-label>알리바바 클라우드</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%8B%9C%EB%A6%AC%EC%A6%88/ data-taxonomy-term=%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%8B%9C%EB%A6%AC%EC%A6%88><span class=taxonomy-label>알리바바 클라우드 시리즈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%97%90%EC%84%B8%EC%9D%B4/ data-taxonomy-term=%EC%97%90%EC%84%B8%EC%9D%B4><span class=taxonomy-label>에세이</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EB%B8%94%EB%A1%9C%EA%B7%B8/ data-taxonomy-term=%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EB%B8%94%EB%A1%9C%EA%B7%B8><span class=taxonomy-label>오픈소스 블로그</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9A%B4%EC%98%81/ data-taxonomy-term=%EC%9A%B4%EC%98%81><span class=taxonomy-label>운영</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9B%90%EA%B2%A9-%EB%94%94%EB%B2%84%EA%B9%85/ data-taxonomy-term=%EC%9B%90%EA%B2%A9-%EB%94%94%EB%B2%84%EA%B9%85><span class=taxonomy-label>원격 디버깅</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/ data-taxonomy-term=%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D><span class=taxonomy-label>인공지능 프로그래밍</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/ data-taxonomy-term=%EC%9D%B8%EB%8D%B1%EC%8A%A4><span class=taxonomy-label>인덱스</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9D%BC%EB%B0%98-%EC%83%81%EC%8B%9D/ data-taxonomy-term=%EC%9D%BC%EB%B0%98-%EC%83%81%EC%8B%9D><span class=taxonomy-label>일반 상식</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%9E%A1%EB%8B%B4/ data-taxonomy-term=%EC%9E%A1%EB%8B%B4><span class=taxonomy-label>잡담</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/ data-taxonomy-term=%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88><span class=taxonomy-label>정보보안</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%A1%B0%EC%82%AC/ data-taxonomy-term=%EC%A1%B0%EC%82%AC><span class=taxonomy-label>조사</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%B0%BD%EC%9E%91%EC%9E%90-%ED%94%8C%EB%9E%AB%ED%8F%BC/ data-taxonomy-term=%EC%B0%BD%EC%9E%91%EC%9E%90-%ED%94%8C%EB%9E%AB%ED%8F%BC><span class=taxonomy-label>창작자 플랫폼</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EA%B7%9C%EC%B9%99-%EB%B6%84%EC%84%9D/ data-taxonomy-term=%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EA%B7%9C%EC%B9%99-%EB%B6%84%EC%84%9D><span class=taxonomy-label>커뮤니티 규칙 분석</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%81%AC%EB%A1%A4%EB%9F%AC/ data-taxonomy-term=%ED%81%AC%EB%A1%A4%EB%9F%AC><span class=taxonomy-label>크롤러</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%81%AC%EB%A6%AC%EC%97%90%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%9E%AB%ED%8F%BC/ data-taxonomy-term=%ED%81%AC%EB%A6%AC%EC%97%90%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%9E%AB%ED%8F%BC><span class=taxonomy-label>크리에이터 플랫폼</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4/ data-taxonomy-term=%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4><span class=taxonomy-label>클라우드 서비스</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0/ data-taxonomy-term=%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0><span class=taxonomy-label>클러스터</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC/ data-taxonomy-term=%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC><span class=taxonomy-label>테스트 도구</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%86%A0%ED%81%B0/ data-taxonomy-term=%ED%86%A0%ED%81%B0><span class=taxonomy-label>토큰</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/ data-taxonomy-term=%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC><span class=taxonomy-label>튜토리얼</span><span class=taxonomy-count>15</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%8F%89%EA%B0%80/ data-taxonomy-term=%ED%8F%89%EA%B0%80><span class=taxonomy-label>평가</span><span class=taxonomy-count>6</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C/ data-taxonomy-term=%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C><span class=taxonomy-label>프라이버시</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C-%EB%B3%B4%ED%98%B8/ data-taxonomy-term=%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C-%EB%B3%B4%ED%98%B8><span class=taxonomy-label>프라이버시 보호</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/ data-taxonomy-term=%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8><span class=taxonomy-label>프로그래머</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/ data-taxonomy-term=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8><span class=taxonomy-label>프롬프트</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%EB%A5%BC-%EB%94%B0%EB%9D%BC-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/ data-taxonomy-term=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%EB%A5%BC-%EB%94%B0%EB%9D%BC-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98><span class=taxonomy-label>프롬프트를 따라 배우는 아키텍처</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/ data-taxonomy-term=%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95><span class=taxonomy-label>환경설정</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%99%9C%EC%84%B1%ED%99%94-%EB%8F%84%EA%B5%AC/ data-taxonomy-term=%ED%99%9C%EC%84%B1%ED%99%94-%EB%8F%84%EA%B5%AC><span class=taxonomy-label>활성화 도구</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%ED%9D%A5%EB%AF%B8%EB%A1%9C%EC%9A%B4-%EC%9D%BC/ data-taxonomy-term=%ED%9D%A5%EB%AF%B8%EB%A1%9C%EC%9A%B4-%EC%9D%BC><span class=taxonomy-label>흥미로운 일</span><span class=taxonomy-count>1</span></a></li></ul></div><div class="taxonomy taxonomy-terms-cloud taxo-categories"><h5 class=taxonomy-title>Categories</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/ai/ data-taxonomy-term=ai><span class=taxonomy-label>AI</span><span class=taxonomy-count>4</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/windows/ data-taxonomy-term=windows><span class=taxonomy-label>Windows</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/windows-%EB%AC%B8%EC%A0%9C-%EC%9E%A1%EC%A6%9D/ data-taxonomy-term=windows-%EB%AC%B8%EC%A0%9C-%EC%9E%A1%EC%A6%9D><span class=taxonomy-label>Windows 문제 잡증</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%E5%8D%9A%E5%BC%88/ data-taxonomy-term=%E5%8D%9A%E5%BC%88><span class=taxonomy-label>博弈</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EA%B2%8C%EC%9E%84-%EC%9D%B4%EB%A1%A0/ data-taxonomy-term=%EA%B2%8C%EC%9E%84-%EC%9D%B4%EB%A1%A0><span class=taxonomy-label>게임 이론</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EA%B2%8C%EC%9E%84%EC%9D%B4%EB%A1%A0/ data-taxonomy-term=%EA%B2%8C%EC%9E%84%EC%9D%B4%EB%A1%A0><span class=taxonomy-label>게임이론</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EA%B4%80%EC%A0%90/ data-taxonomy-term=%EA%B4%80%EC%A0%90><span class=taxonomy-label>관점</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EA%B5%90%EC%9C%A1/ data-taxonomy-term=%EA%B5%90%EC%9C%A1><span class=taxonomy-label>교육</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EA%B5%90%EC%A0%95/ data-taxonomy-term=%EA%B5%90%EC%A0%95><span class=taxonomy-label>교정</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/ data-taxonomy-term=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC><span class=taxonomy-label>네트워크</span><span class=taxonomy-count>20</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%88%A0/ data-taxonomy-term=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%88%A0><span class=taxonomy-label>네트워크 기술</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%8F%84%EA%B5%AC/ data-taxonomy-term=%EB%8F%84%EA%B5%AC><span class=taxonomy-label>도구</span><span class=taxonomy-count>16</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%8F%84%EA%B5%AC-%EC%B6%94%EC%B2%9C/ data-taxonomy-term=%EB%8F%84%EA%B5%AC-%EC%B6%94%EC%B2%9C><span class=taxonomy-label>도구 추천</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%94%94%EC%9E%90%EC%9D%B8/ data-taxonomy-term=%EB%94%94%EC%9E%90%EC%9D%B8><span class=taxonomy-label>디자인</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%A6%AC%EB%B7%B0/ data-taxonomy-term=%EB%A6%AC%EB%B7%B0><span class=taxonomy-label>리뷰</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/ data-taxonomy-term=%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0><span class=taxonomy-label>문제 해결</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%AF%B8%EB%B6%84%EB%A5%98/ data-taxonomy-term=%EB%AF%B8%EB%B6%84%EB%A5%98><span class=taxonomy-label>미분류</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EB%B3%B4%EC%95%88/ data-taxonomy-term=%EB%B3%B4%EC%95%88><span class=taxonomy-label>보안</span><span class=taxonomy-count>8</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%88%98%ED%95%84/ data-taxonomy-term=%EC%88%98%ED%95%84><span class=taxonomy-label>수필</span><span class=taxonomy-count>2</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C/ data-taxonomy-term=%EC%8B%9C%EC%8A%A4%ED%85%9C><span class=taxonomy-label>시스템</span><span class=taxonomy-count>7</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%9C%EC%84%B1%ED%99%94/ data-taxonomy-term=%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%9C%EC%84%B1%ED%99%94><span class=taxonomy-label>시스템 활성화</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/ data-taxonomy-term=%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8><span class=taxonomy-label>오픈소스 프로젝트</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%9A%B4%EC%98%81/ data-taxonomy-term=%EC%9A%B4%EC%98%81><span class=taxonomy-label>운영</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%9D%B8%EB%8D%B1%EC%8A%A4/ data-taxonomy-term=%EC%9D%B8%EB%8D%B1%EC%8A%A4><span class=taxonomy-label>인덱스</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%9D%BC%EB%B0%98-%EC%83%81%EC%8B%9D/ data-taxonomy-term=%EC%9D%BC%EB%B0%98-%EC%83%81%EC%8B%9D><span class=taxonomy-label>일반 상식</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%EC%A1%B0%EC%82%AC/ data-taxonomy-term=%EC%A1%B0%EC%82%AC><span class=taxonomy-label>조사</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4/ data-taxonomy-term=%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4><span class=taxonomy-label>클라우드 서비스</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0/ data-taxonomy-term=%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0><span class=taxonomy-label>클러스터</span><span class=taxonomy-count>3</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/ data-taxonomy-term=%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC><span class=taxonomy-label>튜토리얼</span><span class=taxonomy-count>16</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%8F%89%EA%B0%80/ data-taxonomy-term=%ED%8F%89%EA%B0%80><span class=taxonomy-label>평가</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/ data-taxonomy-term=%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8><span class=taxonomy-label>프로그래머</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%ED%95%A0%EC%9D%B8-%ED%96%89%EC%82%AC/ data-taxonomy-term=%ED%95%A0%EC%9D%B8-%ED%96%89%EC%82%AC><span class=taxonomy-label>할인 행사</span><span class=taxonomy-count>1</span></a></li></ul></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><a class=td-rss-button title=RSS href=/ko-kr/blog/index.xml target=_blank rel=noopener><i class="fa-solid fa-rss" aria-hidden=true></i></a><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/ko-kr/blog/>Blogs</a></li><li class="breadcrumb-item active" aria-current=page>华为C++编程规范</li></ol></nav><div class=td-content><h1>华为C++编程规范</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><header class=article-meta><div class="taxonomy taxonomy-terms-article taxo-tags"><h5 class=taxonomy-title>Tags:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/ data-taxonomy-term=%E7%A8%8B%E5%BA%8F%E5%91%98><span class=taxonomy-label>程序员</span></a></li></ul></div><div class="taxonomy taxonomy-terms-article taxo-categories"><h5 class=taxonomy-title>Categories:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://blog.jqknono.com/ko-kr/categories/%E6%95%99%E7%A8%8B/ data-taxonomy-term=%E6%95%99%E7%A8%8B><span class=taxonomy-label>教程</span></a></li></ul></div></header><ul><li><input disabled type=checkbox> 华为C++编程规范</li></ul><h1 id=c语言编程规范>C++语言编程规范</h1><h2 id=目的><a name=c0-1></a>目的</h2><p>规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。
参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。</p><ol><li>了解C++语言的ISO标准；</li><li>熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性；</li><li>了解C++语言的标准库；</li></ol><h2 id=总体原则><a name=c0-2></a>总体原则</h2><p>代码需要在保证功能正确的前提下，满足<strong>可读、可维护、安全、可靠、可测试、高效、可移植</strong>的特征要求。</p><h2 id=重点关注><a name=c0-2></a>重点关注</h2><ol><li>约定C++语言的编程风格，比如命名，排版等。</li><li>C++语言的模块化设计，如何设计头文件，类，接口和函数。</li><li>C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。</li><li>现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。</li><li>本规范优先适于用C++17版本。</li></ol><h2 id=约定><a name=c0-3></a>约定</h2><p><strong>规则</strong>：编程时必须遵守的约定(must)</p><p><strong>建议</strong>：编程时应该遵守的约定(should)</p><p>本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。</p><h2 id=例外><a name=c0-4></a>例外</h2><p>无论是&rsquo;规则&rsquo;还是&rsquo;建议&rsquo;，都必须理解该条目这么规定的原因，并努力遵守。
但是，有些规则和建议可能会有例外。</p><p>在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。
例外破坏了代码的一致性，请尽量避免。&lsquo;规则&rsquo;的例外应该是极少的。</p><p>下列情况，应风格一致性原则优先：
<strong>修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。</strong></p><h1 id=2-命名><a name=c2></a>2 命名</h1><h2 id=通用命名><a name=c2-1></a>通用命名</h2><p><strong>驼峰风格(CamelCase)</strong>
大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。
按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)</p><table><thead><tr><th>类型</th><th>命名风格</th></tr></thead><tbody><tr><td>类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称</td><td>大驼峰</td></tr><tr><td>函数(包括全局函数，作用域函数，成员函数)</td><td>大驼峰</td></tr><tr><td>全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量</td><td>小驼峰</td></tr><tr><td>宏，常量(const)，枚举值，goto 标签</td><td>全大写，下划线分割</td></tr></tbody></table><p>注意：
上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。
上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。</p><h2 id=文件命名><a name=c2-2></a>文件命名</h2><h3 id=规则221-c文件以cpp结尾头文件以h结尾><a name=r2-2-1></a>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</h3><p>我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。
我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。</p><p>目前业界还有一些其他的后缀的表示方法：</p><ul><li>头文件： .hh, .hpp, .hxx</li><li>cpp文件：.cc, .cxx, .c</li></ul><p>如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。
但是对于本文档，我们默认使用.h和.cpp作为后缀。</p><h3 id=规则222-c文件名和类名保持一致><a name=r2-2-2></a>规则2.2.2 C++文件名和类名保持一致</h3><p>C++的头文件和cpp文件名和类名保持一致，使用下划线小写风格。</p><p>如果有一个类叫DatabaseConnection，那么对应的文件名：</p><ul><li>database_connection.h</li><li>database_connection.cpp</li></ul><p>结构体，命名空间，枚举等定义的文件名类似。</p><h2 id=函数命名><a name=c2-3></a>函数命名</h2><p>函数命名统一使用大驼峰风格，一般采用动词或者动宾结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>AddElement</span><span class=p>(</span><span class=k>const</span> <span class=n>Element</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Element</span> <span class=nf>GetElement</span><span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteUser</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类型命名><a name=c2-4></a>类型命名</h2><p>类型命名采用大驼峰命名风格。
所有类型命名——类、结构体、联合体、类型定义（typedef）、枚举——使用相同约定，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// classes, structs and unions
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTable</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTableTester</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UrlTableProperties</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>Packet</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedefs
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>UrlTableProperties</span><span class=o>*&gt;</span> <span class=n>PropertiesMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// enums
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>UrlTableErrors</span> <span class=p>{</span> <span class=p>...</span>
</span></span></code></pre></div><p>对于命名空间的命名，建议使用大驼峰：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// namespace
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>OsUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FileUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=建议241-避免滥用-typedef或者define-对基本类型起别名><a name=a2-4-1></a>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</h3><p>除有明确的必要性，否则不要用 typedef/#define 对基本数据类型进行重定义。
优先使用<code>&lt;cstdint></code>头文件中的基本类型：</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有/无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有/无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有/无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有/无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有/无符号整数类型</td></tr></tbody></table><h2 id=变量命名><a name=c2-5></a>变量命名</h2><p>通用变量命名采用小驼峰，包括全局变量，函数形参，局部变量，成员变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tableName</span><span class=p>;</span>  <span class=c1>// Good: 推荐此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tablename</span><span class=p>;</span>  <span class=c1>// Bad: 禁止此风格
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span>       <span class=c1>// Good: 只有一个单词时，小驼峰为全小写
</span></span></span></code></pre></div><h3 id=规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀><a name=r2-5-1></a>规则2.5.1 全局变量应增加 &lsquo;g_&rsquo; 前缀，静态变量命名不需要加特殊前缀</h3><p>全局变量是应当尽量少使用的，使用时应特别注意，所以加上前缀用于视觉上的突出，促使开发人员对这些变量的使用更加小心。</p><ul><li>全局静态变量命名与全局变量相同。</li><li>函数内的静态变量命名与普通局部变量相同。</li><li>类的静态成员变量和普通成员变量相同。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_activeConnectCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>packetCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则252-类的成员变量命名以小驼峰加后下划线组成><a name=r2-5-2></a>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileName_</span><span class=p>;</span>   <span class=c1>// 添加_后缀，类似于K&amp;R命名风格
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>对于struct/union的成员变量，仍采用小驼峰不加后缀的命名方式，与局部变量命名风格一致。</p><h2 id=宏常量枚举命名><a name=c2-6></a>宏、常量、枚举命名</h2><p>宏、枚举值采用全大写，下划线连接的格式。
全局作用域内，有名和匿名namespace内的 const 常量，类的静态成员常量，全大写，下划线连接；函数局部 const 常量和类的普通const成员变量，使用小驼峰命名风格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX(a, b)   (((a) &lt; (b)) ? (b) : (a)) </span><span class=c1>// 仅对宏命名举例，并不推荐用宏实现此类功能
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TintColor</span> <span class=p>{</span>    <span class=c1>// 注意，枚举类型名用大驼峰，其下面的取值是全大写，下划线相连
</span></span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DARK_RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>GREEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LIGHT_GREEN</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>    <span class=c1>// 函数局部常量
</span></span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>DEFAULT_FILE_SIZE_KB</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>        <span class=c1>// 全局常量
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=3-格式><a name=c3></a>3 格式</h1><h2 id=行宽><a name=c3-1></a>行宽</h2><h3 id=规则311-行宽不超过-120-个字符><a name=r3-1-1></a>规则3.1.1 行宽不超过 120 个字符</h3><p>建议每行字符数不要超过 120 个。如果超过120个字符，请选择合理的方式进行换行。</p><p>例外:</p><ul><li>如果一行注释包含了超过120 个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；</li><li>包含长路径的 #include 语句可以超出120 个字符，但是也需要尽量避免；</li><li>编译预处理中的error信息可以超出一行。
预处理的 error 信息在一行便于阅读和理解，即使超过 120 个字符。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef XXX_YYY_ZZZ
</span></span></span><span class=line><span class=cl><span class=cp>#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 id=缩进><a name=c3-2></a>缩进</h2><h3 id=规则321-使用空格进行缩进每次缩进4个空格><a name=r3-2-1></a>规则3.2.1 使用空格进行缩进，每次缩进4个空格</h3><p>只允许使用空格(space)进行缩进，每次缩进为 4 个空格。不允许使用Tab符进行缩进。
当前几乎所有的集成开发环境（IDE）都支持配置将Tab符自动扩展为4空格输入；请配置你的IDE支持使用空格进行缩进。</p><h2 id=大括号><a name=c3-3></a>大括号</h2><h3 id=规则331-使用-kr-缩进风格><a name=r3-3-1></a>规则3.3.1 使用 K&amp;R 缩进风格</h3><p><strong>K&amp;R风格</strong>
换行时，函数（不包括lambda表达式）左大括号另起一行放行首，并独占一行；其他左大括号跟随语句放行末。
右大括号独占一行，除非后面跟着同一语句的剩余部分，如 do 语句中的 while，或者 if 语句的 else/else if，或者逗号、分号。</p><p>如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span> <span class=p>{</span>     <span class=c1>// 跟随语句放行末，前置1空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                   <span class=c1>// 函数左大括号独占一行，放行首
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>推荐这种风格的理由：</p><ul><li>代码更紧凑；</li><li>相比另起一行，放行末使代码阅读节奏感上更连续；</li><li>符合后来语言的习惯，符合业界主流习惯；</li><li>现代集成开发环境（IDE）都具有代码缩进对齐显示的辅助功能，大括号放在行尾并不会对缩进和范围产生理解上的影响。</li></ul><p>对于空函数体，可以将大括号放在同一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=函数声明和定义><a name=c3-4></a>函数声明和定义</h2><h3 id=规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐><a name=r3-4-1></a>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</h3><p>在声明和定义函数的时候，函数的返回值类型应该和函数名在同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。
参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>FunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>)</span>   <span class=c1>// Good：全在同一行
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>VeryVeryVeryLongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span>     <span class=c1>// 行宽不满足所有参数，进行换行
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span>     <span class=c1>// Good：和上一行参数对齐
</span></span></span><span class=line><span class=cl>                                        <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>LongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=c1>// 行宽限制，进行换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName5</span><span class=p>)</span>     <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>ReallyReallyReallyReallyLongFunctionName</span><span class=p>(</span>            <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span> <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=函数调用><a name=c3-5></a>函数调用</h2><h3 id=规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐><a name=r3-5-1></a>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</h3><p>函数调用时，函数参数列表放在一行。参数列表如果超过行宽，需要换行并进行合理的参数对齐。
左圆括号总是跟函数名，右圆括号总是跟最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>);</span>   <span class=c1>// Good：函数参数放在一行
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>paramName2</span><span class=p>,</span>                <span class=c1>// Good：保持与上方参数对齐
</span></span></span><span class=line><span class=cl>                                 <span class=n>paramName3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>paramName3</span><span class=p>,</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>paramName5</span><span class=p>);</span>                    <span class=c1>// Good：参数换行，4 空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>VeryVeryVeryLongFunctionName</span><span class=p>(</span>           <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl>    <span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>paramName3</span><span class=p>);</span>                    <span class=c1>// 换行后，4 空格缩进
</span></span></span></code></pre></div><p>如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Good：每行的参数代表一组相关性较强的数据结构，放在一行便于理解
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DealWithStructureLikeParams</span><span class=p>(</span><span class=n>left</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>left</span><span class=p>.</span><span class=n>y</span><span class=p>,</span>     <span class=c1>// 表示一组相关参数
</span></span></span><span class=line><span class=cl>                                         <span class=n>right</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>right</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>  <span class=c1>// 表示另外一组相关参数
</span></span></span></code></pre></div><h2 id=if语句><a name=c3-6></a>if语句</h2><h3 id=规则361-if语句必须要使用大括号><a name=r3-6-1></a>规则3.6.1 if语句必须要使用大括号</h3><p>我们要求if语句都需要使用大括号，即便只有一条语句。</p><p>理由：</p><ul><li>代码逻辑直观，易读；</li><li>在已有条件语句代码上增加新代码时不容易出错；</li><li>对于在if语句中使用函数式宏时，有大括号保护不易出错（如果宏定义时遗漏了大括号）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>objectIsNotExist</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Good：单行条件语句也加大括号
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>CreateNewObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则362-禁止-ifelseelse-if-写在同一行><a name=r3-6-2></a>规则3.6.2 禁止 if/else/else if 写在同一行</h3><p>条件语句中，若有多个分支，应该写在不同行。</p><p>如下是正确的写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// Good: else 与 if 在不同行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是不符合规范的案例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=c1>// Bad: else 与 if 在同一行
</span></span></span></code></pre></div><h2 id=循环语句><a name=c3-7></a>循环语句</h2><h3 id=规则371-循环语句必须使用大括号><a name=r3-7-1></a>规则3.7.1 循环语句必须使用大括号</h3><p>和条件表达式类似，我们要求for/while循环语句必须加上大括号，即便循环体是空的，或循环语句只有一条。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// Good: 使用了大括号
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>   <span class=c1>// Good：循环体是空，使用大括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>continue</span><span class=p>;</span>           <span class=c1>// Good：continue 表示空逻辑，使用大括号
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>      <span class=c1>// Bad: 应该加上括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>);</span>      <span class=c1>// Bad：使用分号容易让人误解是while语句中的一部分
</span></span></span></code></pre></div><h2 id=switch语句><a name=c3-8></a>switch语句</h2><h3 id=规则381-switch-语句的-casedefault-要缩进一层><a name=r3-8-1></a>规则3.8.1 switch 语句的 case/default 要缩进一层</h3><p>switch 语句的缩进风格如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>             <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething1</span><span class=p>();</span> <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span>           <span class=c1>// Good: 带大括号格式
</span></span></span><span class=line><span class=cl>        <span class=n>DoSomething2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=o>:</span>                 <span class=c1>// Bad: case 未缩进
</span></span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span>                <span class=c1>// Bad: default 未缩进
</span></span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=表达式><a name=c3-9></a>表达式</h2><h3 id=建议391-表达式换行要保持换行的一致性运算符放行末><a name=a3-9-1></a>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><p>较长的表达式，不满足行宽要求的时候，需要在适当的地方换行。一般在较低优先级运算符或连接符后面截断，运算符或连接符放在行末。
运算符、连接符放在行末，表示“未结束，后续还有”。
例：</p><p>// 假设下面第一行已经不满足行宽要求</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>currentValue</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span>  <span class=c1>// Good：换行后，逻辑操作符放在行尾
</span></span></span><span class=line><span class=cl>    <span class=n>someCondition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>reallyReallyLongVariableName1</span> <span class=o>+</span>    <span class=c1>// Good
</span></span></span><span class=line><span class=cl>             <span class=n>reallyReallyLongVariableName2</span><span class=p>;</span>
</span></span></code></pre></div><p>表达式换行后，注意保持合理对齐，或者4空格缩进。参考下面例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>         <span class=c1>// Good: 4空格缩进
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>          <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>   <span class=c1>// Good: 保持对齐
</span></span></span></code></pre></div><h2 id=变量赋值><a name=c3-10></a>变量赋值</h2><h3 id=规则3101-多个变量定义和赋值语句不允许写在一行><a name=r3-10-1></a>规则3.10.1 多个变量定义和赋值语句不允许写在一行</h3><p>每行只有一个变量初始化的语句，更容易阅读和理解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span></code></pre></div><p>下面是不符合规范的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Bad：多个变量初始化需要分开放在多行，每行一个变量初始化
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Bad：多个变量定义需要分行，每行一个
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>pointX</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>pointY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Bad：多个变量赋值语句放同一行
</span></span></span></code></pre></div><p>例外：for 循环头、if 初始化语句（C++17）、结构化绑定语句（C++17）中可以声明和初始化多个变量。这些语句中的多个变量声明有较强关联，如果强行分成多行会带来作用域不一致，声明和初始化割裂等问题。</p><h2 id=初始化><a name=c3-11></a>初始化</h2><p>初始化包括结构体、联合体、及数组的初始化</p><h3 id=规则3111-初始化换行时要有缩进并进行合理对齐><a name=r3-11-1></a>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</h3><p>结构体或数组初始化时，如果换行应保持4空格缩进。
从可读性角度出发，选择换行点和对齐位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=指针与引用><a name=c3-12></a>指针与引用</h2><h3 id=建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-1></a>建议3.12.1 指针类型"<code>*</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>指针命名: <code>*</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Bad
</span></span></span></code></pre></div><p>例外：当变量被 const 修饰时，"<code>*</code>&rdquo; 无法跟随变量，此时也不要跟随类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>VERSION</span> <span class=o>=</span> <span class=s>&#34;V100&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-2></a>建议3.12.2 引用类型"<code>&</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>引用命名：<code>&</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*&amp;</span> <span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随类型
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随变量名
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，* 跟随类型，&amp; 跟随变量名
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>      <span class=c1>// Bad
</span></span></span></code></pre></div><h2 id=编译预处理><a name=c3-13></a>编译预处理</h2><h3 id=规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进><a name=r3-13-1></a>规则3.13.1 编译预处理的&rdquo;#&ldquo;统一放在行首，嵌套编译预处理语句时，&rdquo;#&ldquo;可以进行缩进</h3><p>编译预处理的&rdquo;#&ldquo;统一放在行首，即使编译预处理的代码是嵌入在函数体中的，&rdquo;#&ldquo;也应该放在行首。</p><h3 id=规则3132-避免使用宏><a name=r3-13-2></a>规则3.13.2 避免使用宏</h3><p>宏会忽略作用域，类型系统以及各种规则，容易引发问题。应尽量避免使用宏定义，如果必须使用宏，要保证证宏名的唯一性。
在C++中，有许多方式来避免使用宏：</p><ul><li>用const或enum定义易于理解的常量</li><li>用namespace避免名字冲突</li><li>用inline函数避免函数调用的开销</li><li>用template函数来处理多种类型</li></ul><p>在文件头保护宏、条件编译、日志记录等必要场景中可以使用宏。</p><h3 id=规则3133-禁止使用宏来表示常量><a name=r3-13-3></a>规则3.13.3 禁止使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名； 宏没有类型检查，不安全； 宏没有作用域。</p><h3 id=规则3134-禁止使用函数式宏><a name=r3-13-4></a>规则3.13.4 禁止使用函数式宏</h3><p>宏义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。
函数式宏的缺点如下：</p><ul><li>函数式宏缺乏类型检查，不如函数调用检查严格</li><li>宏展开时宏参数不求值，可能会产生非预期结果</li><li>宏没有独立的作用域</li><li>宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性</li><li>在特定场景中必须用编译器对宏的扩展语法，如GCC的statement expression，影响可移植性</li><li>宏在预编译阶段展开后，在期后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题</li><li>对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀</li></ul><p>函数没有宏的上述缺点。但是，函数相比宏，最大的劣势是执行效率不高（增加函数调用的开销和编译器优化的难度）。
为此，可以在必要时使用内联函数。内联函数跟宏类似，也是在调用点展开。不同之处在于内联函数是在编译时展开。</p><p>内联函数兼具函数和宏的优点：</p><ul><li>内联函数执行严格的类型检查</li><li>内联函数的参数求值只会进行一次</li><li>内联函数就地展开，没有函数调用的开销</li><li>内联函数比函数优化得更好</li></ul><p>对于性能要求高的产品代码，可以考虑用内联函数代替函数。</p><p>例外：
在日志记录场景中，需要通过函数式宏保持调用点的文件名（<strong>FILE</strong>）、行号（<strong>LINE</strong>）等信息。</p><h2 id=空格和空行><a name=c3-14></a>空格和空行</h2><h3 id=规则3141-水平空格应该突出关键字和重要信息避免不必要的留白><a name=r3-14-1></a>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</h3><p>水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。总体规则如下：</p><ul><li>if, switch, case, do, while, for等关键字之后加空格；</li><li>小括号内部的两侧，不要加空格；</li><li>大括号内部两侧有无空格，左右必须保持一致；</li><li>一元操作符（& * + ‐ ~ !）之后不要加空格；</li><li>二元操作符（= + ‐ &lt; > * / % | & ^ &lt;= >= == != ）左右两侧加空格</li><li>三目运算符（? :）符号两侧均需要空格</li><li>前置和后置的自增、自减（++ &ndash;）和变量之间不加空格</li><li>结构体成员操作符（. ->）前后不加空格</li><li>逗号(,)前面不加空格，后面增加空格</li><li>对于模板和类型转换(&lt;>)和类型之间不要添加空格</li><li>域操作符(::)前后不要添加空格</li><li>冒号(:)前后根据情况来判断是否要添加空格</li></ul><p>常规情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：大括号前应该留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Good：变量初始化时，=前后应该有空格，分号前面不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>    <span class=c1>// Good：大括号内两侧都无空格
</span></span></span></code></pre></div><p>函数定义和函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>^</span>    <span class=c1>// Bad: 逗号后面需要增加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                 <span class=o>^</span>          <span class=o>^</span>  <span class=c1>// Bad: 函数参数列表的左括号后面不应该有空格，右括号前面不应该有空格
</span></span></span></code></pre></div><p>指针和取地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>     <span class=c1>// Good：*操作符和指针p之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：&amp;操作符和变量x之间不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>    <span class=c1>// Good：通过.访问成员变量时不加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>   <span class=c1>// Good：通过-&gt;访问成员变量时不加空格
</span></span></span></code></pre></div><p>操作符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// Good：赋值操作的=前后都要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5</span><span class=p>;</span>  <span class=c1>// Good：负数的符号和数值之前不要加空格
</span></span></span><span class=line><span class=cl><span class=o>++</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：前置和后置的++/--和变量之间不要加空格
</span></span></span><span class=line><span class=cl><span class=n>x</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>y</span><span class=p>)</span>  <span class=c1>// Good：布尔操作符前后要加上空格，！操作和变量之间不要空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>/</span> <span class=n>z</span><span class=p>;</span>  <span class=c1>// Good：二元操作符前后要加空格
</span></span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>z</span><span class=p>);</span>    <span class=c1>// Good：括号内的表达式前后不需要加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>  <span class=c1>// Good: 三目运算符， ？和：前后需要添加空格
</span></span></span></code></pre></div><p>循环和条件语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：if关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>           <span class=c1>// Good：else关键字和大括号之间加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{}</span>   <span class=c1>// Good：while关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：for关键字和括号之间加空格，分号之后加空格
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: switch 关键字后面有1空格
</span></span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>     <span class=c1>// Good：case语句条件和冒号之间不加空格
</span></span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>模板和转换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在类型与指针操作符之间留空格也可以, 但要保持一致.
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>域操作符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>    <span class=c1>// Good: 命名空间访问，不要留空格
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>GetValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{}</span>  <span class=c1>// Good: 对于成员函数定义，不要留空格
</span></span></span></code></pre></div><p>冒号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 类的派生需要留有空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 构造函数初始化列表需要留有空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 位域表示也留有空格
</span></span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>XX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不添加空格的场景
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Good: 对于public:, private:这种类访问权限的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对于switch-case的case和default后面的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意：当前的集成开发环境（IDE）可以设置删除行尾的空格，请正确配置。</p><h3 id=建议3141-合理安排空行保持代码紧凑><a name=a3-14-1></a>建议3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：</p><ul><li>根据上下内容的相关程度，合理安排空行；</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不使用连续 <strong>3</strong> 个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但namespace的大括号内不作要求。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Bar</span><span class=p>()</span>  <span class=c1>// Bad：最多使用连续2个空行。
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行首不要加入空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行尾不要加入空行
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：函数体内行首不要加空行
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=类><a name=c3-15></a>类</h2><h3 id=规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐><a name=r3-15-1></a>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>      <span class=c1>// 注意没有缩进
</span></span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>();</span>  <span class=c1>// 标准的4空格缩进
</span></span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunctionThatDoesNothing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetVar</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=p>{</span> <span class=n>someVar_</span> <span class=o>=</span> <span class=n>var</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVar</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>someVar_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>SomeInternalFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someOtherVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在各个部分中，建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它成员函数, 数据成员。</p><h3 id=规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行><a name=r3-15-2></a>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 如果所有变量能放在同一行:
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果不能放在同一行,
</span></span></span><span class=line><span class=cl><span class=c1>// 必须置于冒号后, 并缩进4个空格
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span> <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Good: 逗号后面留有空格
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果初始化列表需要置于多行, 需要逐行对齐
</span></span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span>             <span class=c1>// 缩进4个空格
</span></span></span><span class=line><span class=cl>      <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=4-注释><a name=c4></a>4 注释</h1><p>一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明。
注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，<strong>按需注释</strong>。</p><p>注释内容要简洁、明了、无二义性，信息全面且不冗余。</p><p><strong>注释跟代码一样重要。</strong>
写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释，即注释解释代码难以表达的意图，不要重复代码信息。
修改代码时，也要保证其相关注释的一致性。只改代码，不改注释是一种不文明行为，破坏了代码与注释的一致性，让阅读者迷惑、费解，甚至误解。</p><p>使用英文进行注释。</p><h2 id=注释风格><a name=c3-1></a>注释风格</h2><p>在 C++ 代码中，使用 <code>/*</code> <code>*/</code>和 <code>//</code> 都是可以的。
按注释的目的和位置，注释可分为不同的类型，如文件头注释、函数头注释、代码注释等等；
同一类型的注释应该保持统一的风格。</p><p>注意：本文示例代码中，大量使用 &lsquo;//&rsquo; 后置注释只是为了更精确的描述问题，并不代表这种注释风格更好。</p><h2 id=文件头注释><a name=c4-2></a>文件头注释</h2><h3 id=规则31-文件头注释必须包含版权许可><a name=r3-1></a>规则3.1 文件头注释必须包含版权许可</h3><p>/*</p><ul><li>Copyright (c) 2020 XXX</li><li>Licensed under the Apache License, Version 2.0 (the &ldquo;License&rdquo;);</li><li>you may not use this file except in compliance with the License.</li><li>You may obtain a copy of the License at
*</li><li><pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre></li></ul><p>*</p><ul><li>Unless required by applicable law or agreed to in writing, software</li><li>distributed under the License is distributed on an &ldquo;AS IS&rdquo; BASIS,</li><li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li><li>See the License for the specific language governing permissions and</li><li>limitations under the License.
*/</li></ul><h2 id=函数头注释><a name=c4-3></a>函数头注释</h2><h3 id=规则431-公有public函数必须编写函数头注释><a name=r4-3-1></a>规则4.3.1 公有（public）函数必须编写函数头注释</h3><p>公有函数属于类对外提供的接口，调用者需要了解函数的功能、参数的取值范围、返回的结果、注意事项等信息才能正常使用。
特别是参数的取值范围、返回的结果、注意事项等都无法做到自注示，需要编写函数头注释辅助说明。</p><h3 id=规则432-禁止空有格式的函数头注释><a name=r4-3-2></a>规则4.3.2 禁止空有格式的函数头注释</h3><p>并不是所有的函数都需要函数头注释；
函数签名无法表达的信息，加函数头注释辅助说明;</p><p>函数头注释统一放在函数声明或定义上方，使用如下风格之一：
使用<code>//</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 单行函数头
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 多行函数头
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>使用<code>/* */</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 单行函数头 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种单行函数头
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 多行函数头
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func3</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>函数尽量通过函数名自注释，按需写函数头注释。
不要写无用、信息冗余的函数头；不要写空有格式的函数头。</p><p>函数头注释内容可选，但不限于：功能说明、返回值，性能约束、用法、内存约定、算法实现、可重入的要求等等。
模块对外头文件中的函数接口声明，其函数头注释，应当将重要、有用的信息表达清楚。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 返回实际写入的字节数，-1表示写入失败
</span></span></span><span class=line><span class=cl><span class=cm> * 注意，内存 buf 由调用者负责释放
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 函数名：WriteString
</span></span></span><span class=line><span class=cl><span class=cm> * 功能：写入字符串
</span></span></span><span class=line><span class=cl><span class=cm> * 参数：
</span></span></span><span class=line><span class=cl><span class=cm> * 返回值：
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>上面例子中的问题：</p><ul><li>参数、返回值，空有格式没内容</li><li>函数名信息冗余</li><li>关键的 buf 由谁释放没有说清楚</li></ul><h2 id=代码注释><a name=c4-4></a>代码注释</h2><h3 id=规则441-代码注释放于对应代码的上方或右边><a name=r4-4-1></a>规则4.4.1 代码注释放于对应代码的上方或右边</h3><h3 id=规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格><a name=r4-4-2></a>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</h3><p>代码上方的注释，应该保持对应代码一样的缩进。
选择并统一使用如下风格之一：
使用<code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是单行注释
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是多行注释
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>使用<code>/*' '*/</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 这是单行注释 */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种方式的多行注释
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>代码右边的注释，与代码之间，至少留1空格，建议不超过4空格。
通常使用扩展后的 TAB 键即可实现 1-4 空格的缩进。</p><p>选择并统一使用如下风格之一：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>  <span class=c1>// 放右边的注释
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>bar</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>  <span class=cm>/* 放右边的注释 */</span>
</span></span></code></pre></div><p>右置格式在适当的时候，上下对齐会更美观。
对齐后的注释，离左边代码最近的那一行，保证1-4空格的间隔。
例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>A_CONST</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>         <span class=cm>/* 相关的同类注释，可以考虑上下对齐 */</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>ANOTHER_CONST</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>   <span class=cm>/* 上下对齐时，与左侧代码保持间隔 */</span>
</span></span></code></pre></div><p>当右置的注释超过行宽时，请考虑将注释置于代码上方。</p><h3 id=规则443-不用的代码段直接删除不要注释掉><a name=r4-4-3></a>规则4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。
正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 /* */ 和 //，还包括 #if 0， #ifdef NEVER_DEFINED 等等。</p><h1 id=5-头文件><a name=c5></a>5 头文件</h1><h2 id=头文件职责><a name=c5-1></a>头文件职责</h2><p>头文件是模块或文件的对外接口，头文件的设计体现了大部分的系统设计。
头文件中适合放置接口的声明，不适合放置实现（内联函数除外）。对于cpp文件中内部才需要使用的函数、宏、枚举、结构定义等不要放在头文件中。
头文件应当职责单一。头文件过于复杂，依赖过于复杂还是导致编译时间过长的主要原因。</p><h3 id=建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口><a name=a5-1-1></a>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</h3><p>通常情况下，每个.cpp文件都有一个相应的.h，用于放置对外提供的函数声明、宏定义、类型定义等。
如果一个.cpp文件不需要对外公布任何接口，则其就不应当存在。
例外：<strong>程序的入口（如main函数所在的文件），单元测试代码，动态库代码。</strong></p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifndef FOO_H
</span></span></span><span class=line><span class=cl><span class=cp>#define FOO_H
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Foo.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span> <span class=c1>// Good: 对内函数的声明放在.cpp文件的头部，并声明为匿名namespace或者static限制其作用域
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=头文件依赖><a name=c5-2></a>头文件依赖</h2><h3 id=规则521-禁止头文件循环依赖><a name=r5-2-1></a>规则5.2.1 禁止头文件循环依赖</h3><p>头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。</p><p>头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。</p><h3 id=规则522-头文件必须编写define保护防止重复包含><a name=r5-2-4></a>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</h3><p>为防止头文件被重复包含，所有头文件都应当使用 #define 保护；不要使用 #pragma once</p><p>定义包含保护符时，应该遵守如下规则：
1）保护符使用唯一名称；
2）不要在受保护部分的前后放置代码或者注释，文件头注释除外。</p><p>示例：假定timer模块的timer.h，其目录为timer/include/timer.h,应按如下方式保护：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp>#define TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h3 id=规则523-禁止通过声明的方式引用外部函数接口变量><a name=r5-2-5></a>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。
通过 extern 声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。
同时这种隐式依赖，容易导致架构腐化。</p><p>不符合规范的案例：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>   <span class=c1>// Bad: 通过extern的方式使用外部函数
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>应该改为：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>   </span><span class=c1>// Good: 通过包含头文件的方式使用其他.cpp提供的接口
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例外，有些场景需要引用其内部函数，但并不想侵入代码时，可以 extern 声明方式引用。
如：
针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数；
当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数。</p><h3 id=规则524-禁止在extern-c中包含头文件><a name=r5-2-6></a>规则5.2.4 禁止在extern &ldquo;C"中包含头文件</h3><p>在 extern &ldquo;C&rdquo; 中包含头文件，有可能会导致 extern &ldquo;C&rdquo; 嵌套，部分编译器对 extern &ldquo;C&rdquo; 嵌套层次有限制，嵌套层次太多会编译错误。</p><p>在C，C++混合编程的情况下，在extern &ldquo;C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。</p><p>示例，存在a.h和b.h两个头文件：</p><p>// a.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define A(value) Foo(value)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>使用C++预处理器展开b.h，将会得到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按照 a.h 作者的本意，函数 Foo 是一个 C++ 自由函数，其链接规范为 &ldquo;C++"。
但在 b.h 中，由于 <code>#include "a.h"</code> 被放到了 <code>extern "C"</code> 的内部，函数 Foo 的链接规范被不正确地更改了。</p><p>例外：
如果在 C++ 编译环境中，想引用纯C的头文件，这些C头文件并没有<code> extern "C"</code> 修饰。非侵入式的做法是，在 <code>extern "C"</code> 中去包含C头文件。</p><h3 id=建议521尽量避免使用前置声明而是通过include来包含头文件><a name=a5-2-1></a>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</h3><p>前置声明（forward declaration）通常指类、模板的纯粹声明，没伴随着其定义。</p><ul><li>优点：<ol><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li></ol></li><li>缺点：<ol><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li><li>前置声明可能会被库的后续更改所破坏。前置声明模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间<code> std::</code> 的 symbol 时，其行为未定义（在C++11标准规范中明确说明）。</li><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</li><li>很难判断什么时候该用前置声明，什么时候该用<code>#include</code>，某些场景下面前置声明和<code>#include</code>互换以后会导致意想不到的结果。</li></ol></li></ul><p>所以我们尽可能避免使用前置声明，而是使用#include头文件来保证依赖关系。</p><h1 id=6-作用域><a name=c6></a>6 作用域</h1><h2 id=命名空间><a name=c6-1></a>命名空间</h2><h3 id=建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰><a name=a6-1-1></a>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</h3><p>在C++ 2003标准规范中，使用static修饰文件作用域的变量，函数等被标记为deprecated特性，所以更推荐使用匿名namespace。</p><p>主要原因如下：</p><ol><li>static在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数，静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li>static只能保证变量，常量和函数的文件作用域，但是namespace还可以封装类型等。</li><li>统一namespace来处理C++的作用域，而不需要同时使用static和namespace来管理。</li><li>static修饰的函数不能用来实例化模板，而匿名namespace可以。</li></ol><p>但是不要在 .h 中使用中使用匿名namespace或者static。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_COUNT</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InternalFun</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>MAX_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=规则611-不要在头文件中或者include之前使用using导入命名空间><a name=r6-1-1></a>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</h3><p>说明：使用using导入命名空间会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using导入命名空间。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件a.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件b.h
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>NamespaceB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Fun</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 源代码a.cpp
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>G</span><span class=p>();</span> <span class=c1>// using namespace NamespaceA在#include “b.h”之前，引发歧义：NamespaceA::Fun，NamespaceB::Fun调用不明确
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于在头文件中使用using导入单个符号或定义别名，允许在模块自定义名字空间中使用，但禁止在全局名字空间中使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// foo.h
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fancy/string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Bad，禁止向全局名字空间导入符号
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Good，可以在模块自定义名字空间中导入符号
</span></span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>MyVector</span> <span class=o>=</span> <span class=n>fancy</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>  <span class=c1>// Good，C++11可在自定义名字空间中定义别名
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=全局函数和静态成员函数><a name=c6-2></a>全局函数和静态成员函数</h2><h3 id=建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数><a name=a6-2-1></a>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</h3><p>说明：非成员函数放在名字空间内可避免污染全局作用域， 也不要用类+静态成员方法来简单管理全局函数。 如果某个全局函数和某个类有紧密联系， 那么可以作为类的静态成员函数。</p><p>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>File</span> <span class=n>CreateTempFile</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局常量和静态成员常量><a name=c6-3></a>全局常量和静态成员常量</h2><h3 id=建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量><a name=a6-3-1></a>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</h3><p>说明：全局常量放在命名空间内可避免污染全局作用域， 也不要用类+静态成员常量来简单管理全局常量。 如果某个全局常量和某个类有紧密联系， 那么可以作为类的静态成员常量。</p><p>如果你需要定义一些全局常量，只给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>SEPARATOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=全局变量><a name=c6-4></a>全局变量</h2><h3 id=建议641-尽量避免使用全局变量考虑使用单例模式><a name=a6-4-1></a>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>说明：全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_counter</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>使用单实例模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Counter</span><span class=o>&amp;</span> <span class=n>GetInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Counter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  <span class=c1>// 单实例实现简单举例
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Increase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Print</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Counter</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Print</span><span class=p>();</span>
</span></span></code></pre></div><p>实现单例模式以后，实现了全局唯一一个实例，和全局变量同样的效果，并且单实例提供了更好的封装性。</p><p>例外：有的时候全局变量的作用域仅仅是模块内部，这样进程空间里面就会有多个全局变量实例，每个模块持有一份，这种场景下是无法使用单例模式解决的。</p><h1 id=7-类><a name=c7></a>7 类</h1><h2 id=构造拷贝构造赋值和析构函数><a name=c7-1></a>构造，拷贝构造，赋值和析构函数</h2><p>构造，拷贝，移动和析构函数提供了对象的生命周期管理方法：</p><ul><li>构造函数（constructor）： <code>X()</code></li><li>拷贝构造函数（copy constructor）：<code>X(const X&)</code></li><li>拷贝赋值操作符（copy assignment）：<code>operator=(const X&)</code></li><li>移动构造函数（move constructor）：<code>X(X&&)</code> <em>C++11以后提供</em></li><li>移动赋值操作符（move assignment）：<code>operator=(X&&)</code> <em>C++11以后提供</em></li><li>析构函数（destructor）：<code>~X()</code></li></ul><h3 id=规则711-类的成员变量必须显式初始化><a name=r7-1-1></a>规则7.1.1 类的成员变量必须显式初始化</h3><p>说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。</p><p>例外：</p><ul><li>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化。</li></ul><p>示例：如下代码没有构造函数，私有数据成员无法初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//…
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Message</span> <span class=n>message</span><span class=p>;</span>   <span class=c1>// message成员变量没有初始化
</span></span></span><span class=line><span class=cl><span class=n>message</span><span class=p>.</span><span class=n>ProcessOutMsg</span><span class=p>();</span>   <span class=c1>// 后续使用存在隐患
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因此，有必要定义默认构造函数，如下：
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgID_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgBuffer_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// …
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span> <span class=c1>// 具有默认构造函数，不需要显式初始化
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化><a name=a7-1-1></a>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</h3><p>说明：C++11的声明时初始化可以一目了然的看出成员初始值，应当优先使用。如果成员初始化值和构造函数相关，或者不支持C++11，则应当优先使用构造函数初始化列表来初始化成员。相比起在构造函数体中对成员赋值，初始化列表的代码更简洁，执行性能更好，而且可以对const成员和引用成员初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1>// Good，优先使用初始化列表
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>msgBuffer_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Bad，不推荐在构造函数中赋值
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>  <span class=c1>// Good，C++11中使用
</span></span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则712-为避免隐式转换将单参数构造函数声明为explicit><a name=r7-1-2></a>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</h3><p>说明：单参数构造函数如果没有用explicit声明，则会成为隐式转换函数。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span><span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ProcessFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFoo</span><span class=p>(</span><span class=n>test</span><span class=p>);</span>  <span class=c1>// 编译不通过
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码编译不通过，因为<code>ProcessFoo</code>需要的参数是Foo类型，传入的string类型不匹配。</p><p>如果将Foo构造函数的explicit关键字移除，那么调用<code>ProcessFoo</code>传入的string就会触发隐式转换，生成一个临时的Foo对象。往往这种隐式转换是让人迷惑的，并且容易隐藏Bug，得到了一个不期望的类型转换。所以对于单参数的构造函数是要求explicit声明。</p><h3 id=规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止><a name=r7-1-3></a>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</h3><p>说明：如果用户不定义，编译器默认会生成拷贝构造函数和拷贝赋值操作符， 移动构造和移动赋值操作符（移动语义的函数C++11以后才有）。
如果我们不要使用拷贝构造函数，或者赋值操作符，请明确拒绝：</p><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li><p>使用C++11提供的delete, 请参见后面现代C++的相关章节。</p></li><li><p>推荐继承NoCopyable、NoMovable，禁止使用DISALLOW_COPY_AND_MOVE，DISALLOW_COPY，DISALLOW_MOVE等宏。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NoCopyable</span><span class=p>,</span> <span class=k>public</span> <span class=n>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>NoCopyable和NoMovable的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoCopyable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止><a name=r7-1-4></a>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><p>拷贝构造函数和拷贝赋值操作符都是具有拷贝语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, C++11可以使用delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则715-移动构造和移动赋值操作符应该是成对出现或者禁止><a name=r7-1-5></a>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</h3><p>在C++11中增加了move操作，如果需要某个类支持移动操作，那么需要实现移动构造和移动赋值操作符。</p><p>移动构造函数和移动赋值操作符都是具有移动语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, 使用C++11的delete
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=规则716-禁止在构造函数和析构函数中调用虚函数><a name=r7-1-6></a>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>说明：在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。
在C++中，一个基类一次只构造一个完整的对象。</p><p>示例：类Base是基类，Sub是派生类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Log</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// 不同的派生类调用不同的日志文件
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>()</span>         <span class=c1>// 基类构造函数
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Log</span><span class=p>();</span>           <span class=c1>// 调用虚函数Log
</span></span></span><span class=line><span class=cl><span class=p>}</span>                                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Log</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当执行如下语句：
<code>Sub sub;</code>
会先执行Sub的构造函数，但首先调用Base的构造函数，由于Base的构造函数调用虚函数Log，此时Log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为。
同样的道理也适用于析构函数。</p><h3 id=规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数><a name=r7-1-7></a>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</h3><p>如果报一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。
【反例】
如下代码中，基类没有定义拷贝构造函数或拷贝赋值操作符，编译器会自动生成这两个特殊成员函数，
如果派生类对象赋值给基类对象时就发生切片。可以将此例中的拷贝构造函数和拷贝赋值操作符声明为delete，编译器可检查出此类赋值行为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=o>&amp;</span><span class=n>base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>other</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span> <span class=c1>// 不符合：发生切片
</span></span></span><span class=line><span class=cl>    <span class=n>other</span><span class=p>.</span><span class=n>Fun</span><span class=p>();</span> <span class=c1>// 调用的时Base类的Fun函数
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// 传入的是派生类对象
</span></span></span></code></pre></div><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><h2 id=继承><a name=c7-2></a>继承</h2><h3 id=规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final><a name=r7-2-1></a>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</h3><p>说明：只有基类析构函数是virtual，通过多态调用的时候才能保证派生类的析构函数被调用。</p><p>示例：基类的析构函数没有声明为virtual导致了内存泄漏。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=n>cpp</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=p>()</span> <span class=o>:</span> <span class=n>numbers_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Sub&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>size_t</span> <span class=n>numberCount</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers_</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=n>numberCount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>numbers_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>args</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>기반 클래스 Base의 소멸자가 virtual로 선언되지 않았기 때문에 객체가 삭제될 때 파생 클래스 Sub의 소멸자는 호출되지 않고 기반 클래스의 소멸자만 호출되어 메모리 누수가 발생합니다.
예외:
NoCopyable, NoMovable처럼 아무런 동작도 하지 않고 단순히 식별자 역할만 하는 클래스는 가상 소멸자를 정의하지 않아도 되며 final을 정의하지 않아도 됩니다.</p><h3 id=규칙-722-가상-함수에서-기본-매개변수-값을-금지합니다><a name=r7-2-2></a>규칙 7.2.2 가상 함수에서 기본 매개변수 값을 금지합니다.</h3><p>설명: C++에서 가상 함수는 동적 바인딩되지만 함수의 기본 매개변수는 컴파일 타임에 정적 바인딩됩니다. 즉, 결국 실행되는 함수는 파생 클래스에서 정의되었지만 기반 클래스의 기본 매개변수 값을 사용하는 가상 함수가 됩니다. 가상 함수를 재정의할 때 매개변수 선언이 일치하지 않아 사용자를 혼란스럽게 하고 문제를 야기하는 것을 피하기 위해 모든 가상 함수는 기본 매개변수 값을 선언할 수 없습니다.
예시: 가상 함수 display의 기본 매개변수 값 text는 컴파일 타임에 결정되며 런타임에 결정되는 것이 아닙니다. 다형성을 달성하지 못했습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Base!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span>  <span class=o>=</span> <span class=s>&#34;Sub!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Sub</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>  <span class=c1>// 프로그램 출력 결과: Base! 원하는 출력: Sub!
</span></span></span><span class=line><span class=cl>    <span class=n>sub</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>   <span class=c1>// 프로그램 출력 결과: Sub!
</span></span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=규칙-723-상속받은-비가상-함수를-재정의하는-것을-금지합니다><a name=r7-2-3></a>규칙 7.2.3 상속받은 비가상 함수를 재정의하는 것을 금지합니다.</h3><p>설명: 비가상 함수는 동적 바인딩이 불가능하기 때문에 가상 함수만이 동적 바인딩을 구현할 수 있습니다. 즉, 기반 클래스의 포인터를 조작하기만 하면 올바른 결과를 얻을 수 있습니다.</p><p>예시:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>                    
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sub</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>    <span class=c1>// 서브 클래스의 Fun 호출                 
</span></span></span><span class=line><span class=cl><span class=n>base</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>   <span class=c1>// 부모 클래스의 Fun 호출
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><h2 id=다중-상속><a name=c7-3></a>다중 상속</h2><p>실제 개발 과정에서 다중 상속을 사용하는 경우는 비교적 적습니다. 왜냐하면 다중 상속을 사용하는 과정에서 다음과 같은 전형적인 문제가 있기 때문입니다:</p><ol><li>다이아몬드 상속으로 인한 데이터 중복과 이름의 모호성. 따라서 C++은 virtual 상속을 도입하여 이러한 문제를 해결했습니다.</li><li>다이아몬드 상속이 아니더라도 여러 부모 클래스 사이의 이름이 충돌하여 모호성이 발생할 수 있습니다.</li><li>서브 클래스가 여러 부모 클래스의 메서드를 확장하거나 재작성해야 할 때, 서브 클래스의 책임이 명확하지 않아 의미가 혼란스러워집니다.</li><li>위임에 비해 상속은 화이트박스 재사용로, 서브 클래스가 부모 클래스의 protected 멤버에 접근할 수 있어 더 강한 결합을 유발합니다. 그리고 다중 상속은 여러 부모 클래스를 결합하기 때문에 단일 루트 상속에 비해 더 강한 결합 관계를 생성합니다.</li></ol><p>다중 상속은 다음과 같은 장점이 있습니다:
다중 상속은 여러 개의 분리된 인터페이스를 조합하는 더 간단한 방법을 제공하여 여러 인터페이스 또는 클래스의 조립과 재사용을 가능하게 합니다.</p><p>따라서 다중 상속은 아래와 같은 경우에만 허용됩니다.</p><h3 id=권고-731-인터페이스-분리와-다중-역할-조합을-위해-다중-상속을-사용합니다><a name=a7-3-1></a>권고 7.3.1 인터페이스 분리와 다중 역할 조합을 위해 다중 상속을 사용합니다.</h3><p>특정 클래스가 다중 인터페이스를 구현해야 하는 경우, 여러 개의 분리된 인터페이스를 조합하기 위해 다중 상속을 사용할 수 있습니다. 이는 scala 언어의 traits 혼합과 유사합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role1</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role2</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role3</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object1</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role1</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role2</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>C++ 표준 라이브러리에서도 유사한 구현 예시가 있습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_istream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_ostream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_iostream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>basic_istream</span><span class=p>,</span> <span class=k>public</span> <span class=n>basic_ostream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=오버로딩><a name=c7-4></a>오버로딩</h2><p>연산자 오버로딩은 충분한 이유가 있어야 하며, 연산자의 원래 의미를 바꾸지 않아야 합니다. 예를 들어 &lsquo;+&rsquo; 연산자를 빼기 연산에 사용하지 마십시오.
연산자 오버로딩은 코드를 더 직관적으로 만들지만 다음과 같은 단점이 있습니다:</p><ul><li>직관을 혼동시켜 내장 타입과 같이 고성능이라고 착각하게 만들고, 성능 저하 가능성을 간과하게 됩니다.</li><li>문제를 찾을 때 직관적이지 않으며, 함수명으로 찾는 것이 연산자로 찾는 것보다 분명히 더 편리합니다.</li><li>직관적이지 않은 동작을 정의한 연산자 오버로딩(예: &lsquo;+&rsquo; 연산자를 빼기 연산에 사용)은 코드를 혼동시킬 수 있습니다.</li><li>할당 연산자 오버로딩이 암시적 변환을 도입하면 깊숙이 숨은 버그가 생길 수 있습니다. =, == 연산자를 대신하여 Equals(), CopyFrom() 등의 함수를 정의할 수 있습니다.</li></ul><h1 id=8-함수><a name=c8></a>8 함수</h1><h2 id=함수-설계><a name=c8-1></a>함수 설계</h2><h3 id=규칙-811-함수가-너무-길어지지-않도록-하며-함수는-50행을-초과하지-않아야-합니다공백-및-주석-제외><a name=r8-1-1></a>규칙 8.1.1 함수가 너무 길어지지 않도록 하며, 함수는 50행을 초과하지 않아야 합니다(공백 및 주석 제외)</h3><p>함수는 한 화면에 모두 표시될 수 있어야 하며(50행 이하), 하나의 일만 수행하고 그 일을 잘 해야 합니다.</p><p>길이가 너무 긴 함수는 종종 함수 기능이 단일하지 않거나 지나치게 복잡하거나 세부 사항을 과도하게 드러내어 추가적인 추상화가 이루어지지 않은 것을 의미합니다.</p><p>예외: 알고리즘을 구현하는 함수 중에는 알고리즘의 집합성과 기능의 포괄성으로 인해 50행을 초과할 수 있습니다.</p><p>길이가 긴 함수가 현재 매우 잘 작동하고 있더라도 누군가가 수정할 경우 새로운 문제를 야기할 수 있으며, 발견하기 어려운 버그로 이어질 수 있습니다.
함수를 더 간단하고 관리하기 쉬운 여러 개의 함수로 분할하여 다른 사람이 코드를 읽고 수정할 수 있도록 하는 것이 좋습니다.</p><h2 id=인라인-함수><a name=c8-2></a>인라인 함수</h2><h3 id=권고-821-인라인-함수는-10행을-초과하지-않아야-합니다공백-및-주석-제외><a name=a8-2-1></a>권고 8.2.1 인라인 함수는 10행을 초과하지 않아야 합니다(공백 및 주석 제외)</h3><p><strong>설명</strong>: 인라인 함수는 일반 함수의 특성을 가지고 있으며, 일반 함수와 다른 점은 함수 호출 처리 방식에 있습니다. 일반 함수를 호출할 때는 프로그램 실행 권한을 호출된 함수로 이동한 후 다시 호출 함수로 돌아옵니다. 반면에 인라인 함수는 호출 시 호출 표현식을 인라인 함수 본문으로 대체합니다.</p><p>인라인 함수는 1~10개의 작은 함수에 적합합니다. 많은 문장을 포함하는 큰 함수의 경우 함수 호출과 반환의 오버헤드가 상대적으로 미미하기 때문에 인라인 함수로 구현할 필요가 없습니다. 일반적으로 컴파일러는 인라인 방식을 포기하고 일반 함수 방식을 채택합니다.</p><p>인라인 함수가 복잡한 제어 구조(예: 루프, 분기(switch), try-catch 등)를 포함하는 경우 일반적으로 컴파일러는 해당 함수를 일반 함수로 간주합니다.</p><p><strong>가상 함수, 재귀 함수는 인라인 함수로 사용할 수 없습니다</strong>.</p><h2 id=함수-매개변수><a name=c8-3></a>함수 매개변수</h2><h3 id=권고-831-참조를-사용하여-포인터를-대체합니다><a name=a8-3-1></a>권고 8.3.1 참조를 사용하여 포인터를 대체합니다.</h3><p><strong>설명</strong>: 참조는 NULL이 아니므로 더 안전하며, 다른 대상을 가리키지 않으며, NULL 포인터를 확인할 필요가 없습니다. 참조는 NULL 포인터를 확인할 필요가 없습니다.</p><p>원래 플랫폼에서 개발하는 제품의 경우 기존 플랫폼의 처리 방식을 우선적으로 따르는 것이 좋습니다.
const를 사용하여 매개변수가 수정되지 않도록 하고, 코드 리더가 해당 매개변수가 수정되지 않는다는 것을 명확히 알 수 있도록 하면 코드 가독성을 크게 향상시킬 수 있습니다.</p><p>예외: 컴파일 타임에 길이가 알려지지 않은 배열을 전달할 때는 참조 대신 포인터를 사용할 수 있습니다.</p><h3 id=권고-832-강력한-타입-매개변수를-사용하고-void-사용을-피하십시오><a name=a8-3-2></a>권고 8.3.2 강력한 타입 매개변수를 사용하고 void* 사용을 피하십시오.</h3><p>다른 언어가 강력한 타입과 약한 타입에 대해 각자의 관점을 가지고 있지만, 일반적으로 c/c++은 강력한 타입 언어라고 여겨집니다. 우리가 사용하는 언어가 강력한 타입이라면 그런 스타일을 유지해야 합니다.
장점은 가능한 한 컴파일러가 컴파일 단계에서 타입 불일치 문제를 찾아내도록 하는 것입니다.</p><p>강력한 타입을 사용하면 컴파일러가 오류를 발견하는 데 도움이 됩니다. 다음 코드에서 함수 FooListAddNode의 사용에 주의하십시오:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FooNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BarNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FooListAddNode</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span> <span class=c1>// Bad: 여기서 void * 타입을 매개변수로 전달합니다.
</span></span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=p>(</span><span class=n>FooNode</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAppend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_FooList</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>foo</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MakeTheList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BarNode</span> <span class=o>*</span><span class=n>bar</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FooListAddNode</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span>        <span class=c1>// Wrong: 여기서는 foo를 전달하려고 했지만 실수로 bar를 전달했고, 오류가 발생하지 않았습니다.
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>템플릿 함수를 사용하여 매개변수 타입의 변화를 구현할 수 있습니다.</li><li>다형성을 구현하기 위해 기본 클래스 포인터를 사용할 수 있습니다.</li></ol><h3 id=권고-833-함수의-매개변수-개수는-5개를-초과하지-않아야-합니다><a name=a8-3-3></a>권고 8.3.3 함수의 매개변수 개수는 5개를 초과하지 않아야 합니다.</h3><p>함수의 매개변수가 많으면 외부 변화에 의해 함수가 영향을 받기 쉬워지고 유지 관리 작업에 영향을 미칩니다. 함수의 매개변수가 많으면 테스트 작업량도 늘어납니다.</p><p>초과하는 경우 다음을 고려할 수 있습니다:</p><ul><li>함수를 분할할 수 있는지 확인</li><li>관련 매개변수를 구조체로 정의하여 함께 그룹화할 수 있는지 확인</li></ul><h1 id=9-c-기타-특성><a name=c9></a>9 C++ 기타 특성</h1><h2 id=상수와-초기화><a name=c9-1></a>상수와 초기화</h2><p>변하지 않는 값은 이해하고 추적하며 분석하기가 더 쉬우므로 변수 대신 가능한 한 상수를 사용해야 합니다. 값을 정의할 때 const를 기본 옵션으로 사용해야 합니다.</p><h3 id=규칙-911-매크로를-상수를-나타내는-데-사용하는-것을-금지합니다><a name=r9-1-1></a>규칙 9.1.1 매크로를 상수를 나타내는 데 사용하는 것을 금지합니다.</h3><p><strong>설명</strong>: 매크로는 간단한 텍스트 대체이며, 전처리 단계에서 완료되어 실행 중 오류가 발생할 때 직접 해당 값이 표시됩니다. 디버깅 중에는 매크로 이름이 아닌 값만 표시됩니다. 매크로는 타입 검사가 없으며 안전하지 않습니다. 매크로는 스코프가 없습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_MSISDN_LEN 20    </span><span class=c1>// 좋지 않음
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++에서는 const 상수를 사용하십시오.
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 좋음
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++11 이상 버전의 경우 constexpr을 사용할 수 있습니다.
</span></span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=권고-911-관련된-정수-상수-그룹은-열거형으로-정의합니다><a name=a9-1-1></a>권고 9.1.1 관련된 정수 상수 그룹은 열거형으로 정의합니다.</h3><p><strong>설명</strong>: 열거형은 <code>#define</code>이나 <code>const int</code>보다 더 안전합니다. 컴파일러는 매개변수가 열거형 값의 범위 내에 있는지 확인하여 오류를 방지합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋은 예:
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Week</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUNDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MONDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TUESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WEDNESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>THURSDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FRIDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SATURDAY</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLACK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=n>Week</span> <span class=n>today</span><span class=p>,</span> <span class=n>Color</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 컴파일 오류, 매개변수 타입 오류
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 좋지 않은 예:
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SUNDAY</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MONDAY</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLACK</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLUE</span>   <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=kt>int</span> <span class=n>today</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 오류가 발생하지 않음
</span></span></span></code></pre></div><p>열거형 값이 특정 숫자에 대응해야 하는 경우 선언 시 명시적으로 값을 할당해야 합니다. 그렇지 않은 경우 명시적 할당을 피해야 하며, 중복 할당을 방지하고 유지 관리(멤버 추가, 삭제) 작업량을 줄여야 합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋은 예: S 프로토콜에서 정의한 장치 ID 값으로 장치 유형을 식별합니다.
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>DeviceType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_UNKNOWN</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_DSMP</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_ISMG</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_WAPPORTAL</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>프로그램 내부에서 사용되며 분류만을 위한 경우 명시적 할당을 피해야 합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋은 예: 세션 상태를 나타내는 열거형 정의
</span></span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>SessionState</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INIT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WAITING_FOR_RESPONSE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>가능하면 열거형 값의 중복을 피해야 하며, 중복이 필요할 경우 이미 정의된 열거형을 사용하여 수정해야 합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RTCPType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SR</span> <span class=o>=</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MIN_TYPE</span> <span class=o>=</span> <span class=n>RTCP_SR</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RR</span>    <span class=o>=</span> <span class=mi>201</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SDES</span>  <span class=o>=</span> <span class=mi>202</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_BYE</span>   <span class=o>=</span> <span class=mi>203</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_APP</span>   <span class=o>=</span> <span class=mi>204</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RTPFB</span> <span class=o>=</span> <span class=mi>205</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PSFB</span>  <span class=o>=</span> <span class=mi>206</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_XR</span>  <span class=o>=</span> <span class=mi>207</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RSI</span> <span class=o>=</span> <span class=mi>208</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PUBPORTS</span> <span class=o>=</span> <span class=mi>209</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MAX_TYPE</span> <span class=o>=</span> <span class=n>RTCP_PUBPORTS</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=규칙-912-악마의-숫자를-사용하지-마십시오><a name=r9-1-2></a>규칙 9.1.2 악마의 숫자를 사용하지 마십시오.</h3><p>악마의 숫자란 이해할 수 없고, 이해하기 어려운 숫자를 말합니다.</p><p>악마의 숫자는 흑백 논리가 아니며, 이해하기 어려운 정도도 다양하며, 직접 판단해야 합니다.
예를 들어 숫자 12는 다른 맥락에서 상황이 다릅니다:
type = 12; 는 이해할 수 없지만, <code>monthsCount = yearsCount * 12</code>; 은 이해할 수 있습니다.
숫자 0도 때때로 악마의 숫자이며, 예를 들어 <code>status = 0</code>; 은 어떤 상태인지 나타내지 않습니다.</p><p>해결 방법:</p><ul><li>지역적으로 사용되는 숫자의 경우 주석을 추가하여 설명합니다.</li><li>여러 곳에서 사용되는 숫자의 경우 const 상수를 정의하고, 심벌 네임으로 자동 주석을 제공해야 합니다.</li></ul><p>다음과 같은 상황은 금지됩니다:</p><ul><li>숫자의 의미를 설명하기 위해 심벌을 사용하지 않는 경우, 예: <code>const int ZERO = 0</code></li><li>심벌 네임이 그 값에 제한을 두는 경우, 예: <code>const int XX_TIMER_INTERVAL_300MS = 300</code>, 대신 <code>XX_TIMER_INTERVAL_MS</code>를 사용하여 해당 상수가 타이머의 시간 간격을 나타내는 것으로 표시합니다.</li></ul><h3 id=규칙-913-상수는-단일-책임을-보장해야-합니다><a name=r9-1-3></a>규칙 9.1.3 상수는 단일 책임을 보장해야 합니다.</h3><p><strong>설명</strong>: 하나의 상수는 특정 기능만을 나타내야 하며, 즉 하나의 상수는 여러 용도로 사용될 수 없습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋은 예: 프로토콜 A와 B에서 휴대폰 번호(MSISDN) 길이는 모두 20입니다.
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>A_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>B_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 또는 다른 이름공간을 사용:
</span></span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=규칙-914-memcpy_s-memset_s를-사용하여-pod-객체를-초기화하는-것을-금지합니다><a name=r9-1-4></a>규칙 9.1.4 memcpy_s, memset_s를 사용하여 POD 객체를 초기화하는 것을 금지합니다.</h3><p><strong>설명</strong>: <code>POD</code>는 <code>Plain Old Data</code>의 약자로, C++ 98 표준(ISO/IEC 14882, first edition, 1998-09-01)에서 도입된 개념으로, <code>POD</code> 타입은 주로 <code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>enumeration</code>, <code>void</code>, 포인터 등의 원시 타입과 집합 타입을 포함하며, 캡슐화와 객체 지향 특성(예: 사용자 정의 생성/할당/소멸자, 기본 클래스, 가상 함수 등)을 사용할 수 없습니다.</p><p>비POD 타입의 경우, 예를 들어 비집합 타입의 class 객체는 가상 함수를 포함할 수 있으며, 메모리 레이아웃이 불확실하고 컴파일러에 따라 달라질 수 있습니다. 남용된 메모리 복사는 심각한 문제를 야기할 수 있습니다.</p><p>집합 타입의 class라도 직접 메모리 복사와 비교를 사용하는 것은 정보 은폐와 데이터 보호 기능을 파괴하므로 <code>memcpy_s</code>, <code>memset_s</code> 연산을 권장하지 않습니다.</p><p>POD 타입에 대한 자세한 설명은 부록을 참조하십시오.</p><h3 id=권고-912-변수는-사용할-때-선언하고-초기화합니다><a name=a9-1-2></a>권고 9.1.2 변수는 사용할 때 선언하고 초기화합니다.</h3><p><strong>설명</strong>: 변수가 사용 전에 초기값이 없이 사용되는 것은 일반적인 초보 프로그래밍 오류입니다. 사용 전에 변수를 선언하고 동시에 초기화하면 이러한 초보 오류를 쉽게 피할 수 있습니다.</p><p>함수 시작 위치에서 모든 변수를 선언하고 나중에 사용하는 것은 변수의 범위가 전체 함수 구현을 포함하게 되어 코드를 이해하고 유지하기 어렵게 만들 수 있습니다. 특히 함수 시작 시점에 충분한 정보가 없어 종종 기본값(예: 0)으로 초기화하게 되는데, 이는 일반적으로 낭비이며 변수가 유효한 값으로 할당되기 전에 사용되면 오류를 야기할 수 있습니다.</p><p>변수 범위 최소화 원칙과 근처 선언 원칙을 따르면 코드를 더 쉽게 읽을 수 있고 변수의 타입과 초기값을 이해하기 쉬워집니다. 특히 초기화를 사용하여 선언과 할당을 대체하는 것이 좋습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋지 않은 예: 선언과 초기화가 분리됨
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>        <span class=c1>// 선언 시 초기화되지 않음: 기본 생성자를 호출
</span></span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>;</span>  <span class=c1>// 다시 할당 연산자를 호출; 선언과 정의가 다른 위치에 있음, 이해하기 어려움
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 좋은 예: 선언과 초기화가 함께 이루어짐, 이해하기 쉬움
</span></span></span><span class=line><span class=cl><span class=n>string</span> <span class=nf>name</span><span class=p>(</span><span class=s>&#34;zhangsan&#34;</span><span class=p>);</span>  <span class=c1>// 생성자를 호출
</span></span></span></code></pre></div><h2 id=표현식><a name=c9-2></a>표현식</h2><h3 id=규칙-921-변수의-증가-또는-감소-연산을-포함한-표현식에서-해당-변수를-다시-참조하는-것은-금지합니다><a name=r9-2-1></a>규칙 9.2.1 변수의 증가 또는 감소 연산을 포함한 표현식에서 해당 변수를 다시 참조하는 것은 금지합니다.</h3><p>변수의 증가 또는 감소 연산을 포함한 표현식에서 해당 변수를 다시 참조하는 경우, 그 결과는 C++ 표준에서 명확히 정의되지 않았습니다. 각 컴파일러 또는 동일 컴파일러의 다른 버전에서 구현이 다를 수 있습니다.
보다 높은 이식성을 위해 표준에서 정의되지 않은 연산 순서에 대한 어떠한 가정도 하지 않아야 합니다.</p><p>주의, 연산 순서의 문제는 괄호를 사용하여 해결할 수 없습니다. 왜냐하면 이것이 우선순위의 문제가 아니기 때문입니다.</p><p>예시:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Bad: b[i] 연산과 i++ 연산의 순서가 명확하지 않음.
</span></span></span></code></pre></div><p>올바른 작성 방법은 증가 또는 감소 연산을 별도의 줄로 분리하는 것입니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 별도의 줄
</span></span></span></code></pre></div><p>함수 매개변수</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   <span class=c1>// Bad: 두 번째 매개변수를 전달할 때, 증가 연산이 발생했는지 여부가 불확실합니다.
</span></span></span></code></pre></div><p>올바른 작성 방법</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 별도의 줄
</span></span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=규칙-922-switch-문에는-default-분기를-포함해야-합니다><a name=r9-2-2></a>규칙 9.2.2 switch 문에는 default 분기를 포함해야 합니다.</h3><p>대부분의 경우 switch 문에는 default 분기가 있어야 하며, 이는 누락된 case 라벨 처리 시 기본 처리 행위를 제공합니다.</p><p>예외:
switch 조건 변수가 열거형 타입이고 case 분기가 모든 값을 포함하는 경우 default 분기를 추가하는 것은 다소 불필요합니다.
현대 컴파일러는 switch 문에서 열거형 값의 누락된 case 분기를 검사하는 기능을 가지고 있으며, 이에 대한 경고 메시지를 제공합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// switch 조건 변수가 열거형이므로 default 처리 분기를 추가하지 않을 수 있습니다.
</span></span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>RED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoRedThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>BLUE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoBlueThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=권고-921-표현식-비교-시-왼쪽은-변화를-오른쪽은-불변을-따르는-원칙을-따르십시오><a name=a9-2-1></a>권고 9.2.1 표현식 비교 시 왼쪽은 변화를, 오른쪽은 불변을 따르는 원칙을 따르십시오.</h3><p>상수가 포함된 변수 비교 시 상수를 왼쪽에 두면 if (MAX == v)와 같이 읽기 불편하고, if (MAX > v)와 같이 사용하면 이해하기 어렵습니다.
사람의 정상적인 읽기 및 표현 습관에 따라 상수를 오른쪽에 두어야 합니다. 다음과 같이 작성합니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>특수한 경우로, 구간을 설명할 때 <code>if (MIN &lt; value && value &lt; MAX)</code> 와 같이 전반부는 왼쪽에 상수가 올 수 있습니다.</p><p>상수를 왼쪽에 두는 것에 대해 &lsquo;==&lsquo;를 &lsquo;=&lsquo;로 실수로 쓰는 것을 걱정할 필요는 없습니다. 왜냐하면 <code>if (value = MAX)</code>는 컴파일 경고가 발생하고, 다른 정적 검사 도구도 오류를 보고할 것이기 때문입니다. 실수를 방지하는 것은 도구의 역할이며, 코드는 가독성이 최우선이어야 합니다.</p><h3 id=권고-922-괄호를-사용하여-연산자의-우선순위를-명확히-하십시오><a name=a9-2-2></a>권고 9.2.2 괄호를 사용하여 연산자의 우선순위를 명확히 하십시오.</h3><p>괄호를 사용하여 연산자의 우선순위를 명확히 하면 기본 우선순위가 설계 의도와 맞지 않아 발생하는 오류를 방지할 수 있습니다. 또한 코드를 더 명확하고 읽기 쉽게 만들 수 있습니다. 그러나 괄호가 너무 많으면 코드의 가독성을 떨어뜨릴 수 있습니다. 다음은 괄호 사용에 대한 권고 사항입니다.</p><ul><li>이원 이상 연산자의 경우, 여러 연산자가 포함되어 있으면 괄호를 사용해야 합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>         <span class=cm>/* 연산자가 동일하므로 괄호가 필요하지 않음 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>     <span class=cm>/* 쉼표 양쪽의 표현식은 괄호가 필요하지 않음 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>      <span class=cm>/* 연산자가 다르므로 괄호가 필요함 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=p>(</span><span class=n>b</span> <span class=o>/</span> <span class=mi>5</span><span class=p>);</span>       <span class=cm>/* 연산자가 다르므로 괄호가 필요함 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=p>(</span><span class=n>a</span> <span class=err>–</span> <span class=n>b</span><span class=p>);</span>    <span class=cm>/* 연산자가 다르므로 괄호가 필요함 */</span>
</span></span></code></pre></div><h2 id=타입-변환><a name=c9-3></a>타입 변환</h2><p>타입 분기를 사용하여 행동을 맞춤화하는 것을 피하십시오: 타입 분기를 사용한 행동 맞춤화는 실수를 하기 쉬우며, C++로 C 코드를 작성하려는 명백한 징표입니다. 이는 매우 유연하지 않은 기술이며, 새로운 타입을 추가할 때 모든 분기를 수정하지 않으면 컴파일러가 알려주지 않을 것입니다. 템플릿과 가상 함수를 사용하여 호출 코드가 아닌 타입 자체가 행동을 결정하도록 하십시오.</p><p>타입 변환을 과도하게 사용하는 것을 피하십시오. 우리는 코드의 타입 설계에서 각 데이터의 타입이 무엇인지 고려해야 하며, 타입 변환을 과도하게 사용하여 문제를 해결하려는 것은 바람직하지 않습니다. 기본 타입을 설계할 때 다음을 고려하십시오:</p><ul><li>부호가 있는지 없는지</li><li>float이 적합한지 double이 적합한지</li><li>int8, int16, int32, int64 중 어떤 것을 사용할지 정수의 길이를 결정하십시오.</li></ul><p>그러나 타입 변환을 금지할 수는 없습니다. 왜냐하면 C++ 언어는 기계 프로그래밍을 위한 언어이며 포인터 주소와 관련이 있고, 다양한 제3자 또는 저수준 API와 상호작용하게 됩니다. 이러한 API의 타입 설계가 합리적이지 않을 수 있으며, 이 적응 과정에서 타입 변환이 쉽게 발생할 수 있습니다.</p><p>예외: 특정 함수를 호출할 때 함수 결과를 처리하고 싶지 않은 경우, 이것이 최선의 선택인지 먼저 고려해야 합니다. 함수의 반환값을 처리하고 싶지 않다면 (void) 변환을 사용하여 해결할 수 있습니다.</p><h3 id=규칙-931-타입-변환을-사용해야-한다면-c가-제공하는-타입-변환을-사용하고-c-스타일-타입-변환을-사용하지-마십시오><a name=r9-3-1></a>규칙 9.3.1 타입 변환을 사용해야 한다면 C++가 제공하는 타입 변환을 사용하고 C 스타일 타입 변환을 사용하지 마십시오.</h3><p><strong>설명</strong>:</p><p>C++가 제공하는 타입 변환은 C 스타일 변환보다 더 구체적이고 읽기 쉬우며, 더 안전합니다. C++가 제공하는 변환은 다음과 같습니다:</p><ul><li>타입 변환:</li></ul><ol><li><code>dynamic_cast</code>: 주로 상속 체계 하위 변환에 사용되며, <code>dynamic_cast</code>는 타입 검사 기능을 가지고 있습니다. 기반 클래스와 파생 클래스 설계를 잘 해야 하며, <code>dynamic_cast</code>를 사용하여 변환하는 것은 피해야 합니다.</li><li><code>static_cast</code>: C 스타일 변환과 유사하며 값의 강제 변환이나 상위 변환(파생 클래스의 포인터 또는 참조를 기반 클래스의 포인터 또는 참조로 변환)에 사용할 수 있습니다. 이 변환은 다중 상속으로 인한 타입 모호성을 제거하는 데 자주 사용되며, 비교적 안전합니다. 순수한 산술 변환이라면 뒤에 나오는 중괄호 변환 방식을 사용하는 것이 좋습니다.</li><li><code>reinterpret_cast</code>: 관련이 없는 타입 간 변환에 사용됩니다. <code>reinterpret_cast</code>는 컴파일러에게 특정 타입 객체의 메모리를 다른 타입으로 다시 해석하도록 강제하며, 이는 안전하지 않은 변환으로尽可能少用<code>reinterpret_cast</code>.</li><li><code>const_cast</code>: 객체의<code>const</code>속성을 제거하여 객체를 수정 가능하게 만듭니다. 이는 데이터의 불변성을 파괴하므로尽可能少用.</li></ol><ul><li>산술 변환: （C++11부터 지원）
산술 변환 및 타입 정보가 손실되지 않는 변환의 경우, 예를 들어 float에서 double, int32에서 int64로의 변환의 경우, 대괄호 초기화 방식을 권장합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=n>someFloat</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>i</span><span class=p>{</span> <span class=n>someInt32</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=권고-931-dynamic_cast-사용을-피하십시오><a name=a9-3-1></a>권고 9.3.1 <code>dynamic_cast</code> 사용을 피하십시오.</h3><ol><li><code>dynamic_cast</code>는 C++의 RTTI에 의존하여 런타임에 C++ 클래스 객체의 타입을 식별합니다.</li><li><code>dynamic_cast</code>가 나타나는 것은 일반적으로 기반 클래스와 파생 클래스 설계에 문제가 있다는 것을 의미합니다. 파생 클래스가 기반 클래스의 계약을 파괴하여 <code>dynamic_cast</code>로 변환하여 특별 처리를 해야 하는 경우가 있습니다. 이때는 <code>dynamic_cast</code>를 사용하여 문제를 해결하는 것보다 클래스 설계를 개선하는 것이 더 낫습니다.</li></ol><h3 id=권고-932-reinterpret_cast-사용을-피하십시오><a name=a9-3-2></a>권고 9.3.2 <code>reinterpret_cast</code> 사용을 피하십시오.</h3><p><strong>설명</strong>: <code>reinterpret_cast</code>는 관련이 없는 타입 간 변환에 사용됩니다.</p><p><code>reinterpret_cast</code>를 사용하여 한 타입을 다른 타입으로 강제 변환하려고 시도하는 것은 타입의 안전성과 신뢰성을 파괴하는 것으로, 안전하지 않은 변환이며 다른 타입 간 변환을 가능한 한 피해야 합니다.</p><h3 id=권고-933-const_cast-사용을-피하십시오><a name=a9-3-3></a>권고 9.3.3 <code>const_cast</code> 사용을 피하십시오.</h3><p><strong>설명</strong>: <code>const_cast</code>는 객체의<code>const</code>및<code>volatile</code>속성을 제거하는 데 사용됩니다.</p><p>const_cast 변환 후 포인터 또는 참조를 사용하여 const 객체를 수정하는 것은 정의되지 않은 동작입니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋지 않은 예
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>2048</span><span class=p>;</span>      <span class=c1>// 정의되지 않은 동작
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 좋지 않은 예
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>  <span class=c1>// 정의되지 않은 동작
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=자원-할당과-해제><a name=c9-4></a>자원 할당과 해제</h2><h3 id=규칙-941-단일-객체-해제는-delete를-배열-객체-해제는-delete-를-사용합니다><a name=r9-4-1></a>규칙 9.4.1 단일 객체 해제는 delete를, 배열 객체 해제는 delete []를 사용합니다.</h3><p>설명: 단일 객체 삭제는 delete를, 배열 객체 삭제는 delete []를 사용합니다. 이유는 다음과 같습니다:</p><ul><li>new 호출 시 포함된 동작: 시스템에서 메모리를 요청하고, 해당 타입의 생성자를 호출합니다.</li><li>new[n] 호출 시 포함된 동작: n개 객체를 수용할 수 있는 메모리를 요청하고, 각 객체에 대해 생성자를 호출합니다.</li><li>delete 호출 시 포함된 동작: 먼저 해당 소멸자를 호출한 후 메모리를 시스템에 반환합니다.</li><li>delete[] 호출 시 포함된 동작: 각 객체에 대해 소멸자를 호출한 후 모든 메모리를 해제합니다.</li></ul><p>new와 delete의 형식이 맞지 않으면 결과는 알려지지 않습니다. 비클래스 타입의 경우, new와 delete는 생성자와 소멸자를 호출하지 않습니다.</p><p>잘못된 예:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>올바른 예:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=권고-941-raii-특성을-사용하여-동적-할당을-추적하는-데-도움을-주십시오><a name=a9-4-1></a>권고 9.4.1 RAII 특성을 사용하여 동적 할당을 추적하는 데 도움을 주십시오.</h3><p>설명: RAII는 &ldquo;자원 획득은 초기화이다"라는 의미의 약어로(Resource Acquisition Is Initialization), 객체의 수명 주기를 이용하여 프로그램 자원(예: 메모리, 파일 핸들, 네트워크 연결, 뮤텍스 등)을 제어하는 간단한 기술입니다.</p><p>RAII의 일반적인 방법은 다음과 같습니다: 객체 생성 시 자원을 획득하고, 객체의 수명 주기 내에서 자원에 대한 접근을 제어하여 항상 유효하게 유지한 후, 마지막으로 객체 소멸 시 자원을 해제합니다. 이러한 방법에는 두 가지 큰 장점이 있습니다:</p><ul><li>명시적으로 자원을 해제할 필요가 없습니다.</li><li>객체가 필요한 자원은 객체의 수명 주기 내내 항상 유효하게 유지됩니다. 이렇게 하면 자원 유효성 검사를 할 필요가 없어지므로 논리를 단순화하고 효율성을 높일 수 있습니다.</li></ul><p>예시: RAII를 사용하면 뮤텍스 자원을 명시적으로 해제할 필요가 없습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockGuard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span><span class=p>(</span><span class=k>const</span> <span class=n>LockType</span><span class=o>&amp;</span> <span class=n>lockType</span><span class=p>)</span><span class=o>:</span> <span class=n>lock_</span><span class=p>(</span><span class=n>lockType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Acquire</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>LockGuard</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockType</span> <span class=n>lock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span> <span class=n>lockGuard</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 데이터 조작
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=표준-라이브러리><a name=c9-5></a>표준 라이브러리</h2><p>STL 표준 템플릿 라이브러리는 다른 제품에서 사용 정도가 다르며, 여기서는 기본 규칙과 권고 사항을 제시합니다.</p><h3 id=규칙-951-stdstring의-c_str이-반환하는-포인터를-저장하지-마십시오><a name=r9-5-1></a>규칙 9.5.1 std::string의 c_str()이 반환하는 포인터를 저장하지 마십시오.</h3><p>설명: C++ 표준에서 string::c_str() 포인터가 지속적으로 유효하다고 명시하지 않았기 때문에 특정 STL 구현이 string::c_str()을 호출할 때 임시 저장소를 반환하고 빠르게 해제할 수 있습니다. 따라서 프로그램의 이식성을 보장하기 위해 string::c_str()의 결과를 저장하지 말고 필요할 때마다 직접 호출해야 합니다.</p><p>예시:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>  <span class=c1>// 표현식이 끝난 후, name의 수명이 계속되므로 포인터는 유효합니다.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 중간에 string의 비상수 멤버 함수를 호출하여 string이 수정되면 operator[], begin() 등이 포함될 수 있습니다.
</span></span></span><span class=line><span class=cl>    <span class=c1>// string이 수정되면 text의 내용을 사용할 수 없거나 원래 문자열이 아닐 수 있습니다.
</span></span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;2&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 이후 text 포인터를 사용하면 문자열 내용이 더 이상 &#34;demo&#34;가 아닙니다.
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=p>(</span><span class=n>name</span> <span class=o>+</span> <span class=n>test</span><span class=p>).</span><span class=n>c_str</span><span class=p>();</span> <span class=c1>// 표현식이 끝난 후, + 연산으로 생성된 임시 객체가 파괴되어 포인터가 유효하지 않습니다.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 이후 text 포인터를 사용하면 더 이상 유효한 메모리 공간을 가리키지 않습니다.
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>예외: 성능 요구가 매우 높은少数 코드에서 기존의 const char* 타입 매개변수만 받는 함수에 적응하기 위해 일시적으로 string::c_str()이 반환하는 포인터를 저장할 수 있습니다. 그러나 string 객체의 수명이 저장된 포인터의 수명보다 길어야 하며, 저장된 포인터의 수명 내에서 string 객체가 수정되지 않도록 엄격히 보장해야 합니다.</p><h3 id=권고-951-stdstring을-char-대신-사용하십시오><a name=a9-5-1></a>권고 9.5.1 std::string을 char* 대신 사용하십시오.</h3><p>설명: string을<code>char*</code>대신 사용하는 것은 많은 장점이 있습니다:</p><ol><li>끝에 있는 &lsquo;\0&rsquo;을 고려할 필요가 없습니다.</li><li>+, =, == 등의 연산자와 다른 문자열 조작 함수를 직접 사용할 수 있습니다.</li><li>명시적인 new/delete를 고려할 필요가 없으며, 이로 인한 오류를 피할 수 있습니다.</li></ol><p>주의할 점은 일부 stl 구현에서 string이 쓰기 시 복사 전략을 기반으로 한다는 것입니다. 이는 두 가지 문제를 야기합니다. 하나는 일부 버전의 쓰기 시 복사 전략이 스레드 안전을 구현하지 않아 멀티 스레드 환경에서 프로그램 충돌을 야기할 수 있다는 것입니다. 두 번째는 동적 라이브러리와 상호 전달되는 쓰기 시 복사 전략 기반의 string이 언로드될 때 참조 횟수가 감소하지 않아 잘못된 포인터가 생길 수 있다는 것입니다. 따라서 프로그램 안정성을 보장하기 위해 신뢰할 수 있는 stl 구현을 선택하는 것은 매우 중요합니다.</p><p>예외:
시스템이나 다른 제3자 라이브러리 API를 호출할 때는 이미 정의된 인터페이스에 따라<code>char*</code>를 사용해야 합니다. 그러나 인터페이스를 호출하기 전까지는 string을 사용할 수 있으며, 인터페이스를 호출할 때는 string::c_str()을 사용하여 문자 포인터를 얻을 수 있습니다.
스택에서 버퍼로 사용할 문자 배열을 직접 할당하는 경우 string을 사용할 필요가 없습니다. 또한<code>vector&lt;char></code>등의 컨테이너를 사용할 필요도 없습니다.</p><h3 id=규칙-952-auto_ptr-사용을-금지합니다><a name=r9-5-2></a>규칙 9.5.2 auto_ptr 사용을 금지합니다.</h3><p>설명: stl 라이브러리의 std::auto_ptr은 암시적 소유권 이전 동작을 가지고 있습니다. 다음 코드를 참조하십시오:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span>
</span></span></code></pre></div><p>2번째 문장이 실행된 후 p1은 1번째 문장에서 할당된 객체를 가리키지 않게 되고 nullptr이 됩니다. 이것이 바로 auto_ptr이 다양한 표준 컨테이너에 넣을 수 없는 이유입니다.
소유권 이전 동작은 일반적으로 원하는 결과가 아닙니다. 소유권을 반드시 이전해야 하는 시나리오의 경우에도 암시적 이전 방식을 사용하는 것은 바람직하지 않습니다. 이는 auto_ptr을 사용하는 코드에 대해 프로그래머가 추가적인 주의를 기울이도록 요구하며, 그렇지 않으면 잘못된 포인터에 대한 액세스가 발생할 수 있습니다.
auto_ptr을 사용하는 일반적인 두 가지 시나리오는 다음과 같습니다. 첫째는 auto_ptr을 생성하는 함수 외부로 전달하는 것입니다. 둘째는 auto_ptr을 RAII 관리 클래스로 사용하여 auto_ptr의 수명이 초과되면 자동으로 자원을 해제하는 것입니다.
첫 번째 시나리오의 경우 std::shared_ptr로 대체할 수 있습니다.
두 번째 시나리오의 경우 C++11 표준의 std::unique_ptr로 대체할 수 있습니다. std::unique_ptr은 std::auto_ptr의 대체품으로 명시적 소유권 이전을 지원합니다.</p><p>예외:
C++11 표준이 보편화되기 전까지는 반드시 소유권을 이전해야 하는 시나리오에서 std::auto_ptr을 사용할 수 있지만, auto_ptr을 래핑하고 복사 생성자와 할당 연산자를 금지하여 해당 래핑 클래스가 표준 컨테이너에서 사용되지 않도록 하는 것이 좋습니다.</p><h3 id=권고-952-새로운-표준-헤더-파일을-사용합니다><a name=a9-5-2></a>권고 9.5.2 새로운 표준 헤더 파일을 사용합니다.</h3><p>설명:
C++ 표준 헤더 파일을 사용할 때는<code>&lt;cstdlib></code>와 같은 것을 사용하고<code>&lt;stdlib.h></code>와 같은 것은 사용하지 마십시오.</p><h2 id=const의-사용법><a name=c9-6></a>const의 사용법</h2><p>변수나 매개변수 앞에 키워드 const를 추가하여 변수 값이 변조될 수 없음을 나타냅니다(예: <code>const int foo</code>). 클래스의 함수에 const 한정자를 추가하여 해당 함수가 클래스 멤버 변수의 상태를 수정하지 않음을 나타냅니다(예: <code>class Foo { int Bar(char c) const; };</code>). const 변수, 데이터 멤버, 함수 및 매개변수는 컴파일 타임 타입 검사에 추가 보장을 제공하여 오류를 조기에 발견할 수 있습니다. 따라서 가능한 경우 const를 사용하는 것을 강력히 권고합니다.
때때로 C++11의 constexpr을 사용하여 진정한 상수를 정의하는 것이 더 나을 수 있습니다.</p><h3 id=규칙-961-포인터와-참조-타입의-매개변수가-수정되지-않는-경우-const를-사용합니다><a name=r9-6-1></a>규칙 9.6.1 포인터와 참조 타입의 매개변수가 수정되지 않는 경우 const를 사용합니다.</h3><p>변하지 않는 값은 이해/추적/분석하기가 더 쉽습니다. 가능한 경우 const를 기본 옵션으로 사용하면 컴파일 타임에 검사하여 코드를 더 견고하고 안전하게 만듭니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PrintFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=규칙-962-멤버-변수를-수정하지-않는-멤버-함수에는-const로-수정합니다><a name=r9-6-2></a>규칙 9.6.2 멤버 변수를 수정하지 않는 멤버 함수에는 const로 수정합니다.</h3><p>가능한 경우 멤버 함수를 const로 선언합니다. 액세스 함수는 항상 const로 선언해야 합니다. 멤버 변수를 수정하지 않는 멤버 함수는 모두 const로 선언합니다.
가상 함수의 경우 단일 클래스의 구현만 고려하는 것이 아니라 설계 의도에 따라 상속 체인의 모든 클래스가 해당 가상 함수에서 멤버 변수를 수정해야 하는지 고려해야 합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>PrintValue</span><span class=p>()</span> <span class=k>const</span> <span class=c1>// const로 멤버 함수를 수정하면 멤버 변수를 수정하지 않습니다.
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetValue</span><span class=p>()</span> <span class=k>const</span>  <span class=c1>// const로 멤버 함수를 수정하면 멤버 변수를 수정하지 않습니다.
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=권고-961-초기화-후-수정되지-않는-멤버-변수를-const로-정의합니다><a name=a9-6-1></a>권고 9.6.1 초기화 후 수정되지 않는 멤버 변수를 const로 정의합니다.</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span> <span class=n>dataLength_</span><span class=p>(</span><span class=n>length</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>dataLength_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=예외><a name=c9-7></a>예외</h2><h3 id=권고-971-c11에서-함수가-예외를-발생시키지-않는-경우-noexcept로-선언합니다><a name=a9-7-1></a>권고 9.7.1 C++11에서 함수가 예외를 발생시키지 않는 경우 noexcept로 선언합니다.</h3><p><strong>이유</strong></p><ol><li>함수가 예외를 발생시키지 않는 경우 noexcept로 선언하면 컴파일러가 함수를 최대한 최적화할 수 있으며, 실행 경로를 줄이고 오류 종료 효율을 높일 수 있습니다.</li><li><code>vector</code> 등 STL 컨테이너는 인터페이스의 견고성을 보장하기 위해 저장 요소의 <code>move 연산자</code>가 <code>noexcept</code>로 선언되지 않은 경우 컨테이너 확장 시 요소 이동에 <code>move 메커니즘</code>을 사용하지 않고 <code>copy 메커니즘</code>을 사용하여 성능 손실 위험을 야기합니다. 함수가 예외를 발생시키지 않거나 프로그램이 특정 함수가 발생시킨 예외를 잡아 처리하지 않는 경우, 새로운 <code>noexcept</code> 키워드를 사용하여 함수를 수정하여 함수가 예외를 발생시키지 않거나 발생시킨 예외가 잡히지 않고 처리되지 않음을 나타낼 수 있습니다. 예를 들어:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>double</span> <span class=n>sqrt</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>  <span class=c1>// 영원히 예외를 발생시키지 않음
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 예외를 발생시킬 수 있더라도 noexcept를 사용할 수 있습니다.
</span></span></span><span class=line><span class=cl><span class=c1>// 여기서는 메모리 고갈 예외를 처리하지 않으려고 하며, 간단히 함수를 noexcept로 선언합니다.
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>MyComputation</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>noexcept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>    <span class=c1>// 예외가 발생할 수 있음
</span></span></span><span class=line><span class=cl>    <span class=c1>// 무언가를 수행
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>   <span class=c1>// 최대 최적화
</span></span></span><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>);</span>            <span class=c1>// 적은 최적화
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// std::vector의 move 연산은 noexcept로 선언되어야 합니다.
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo1</span><span class=p>(</span><span class=n>Foo1</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>);</span>  <span class=c1>// noexcept 없음
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo1</span><span class=o>&gt;</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>  <span class=c1>// 컨테이너 확장 시 기존 요소 이동에 copy constructor 사용
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo2</span><span class=p>(</span><span class=n>Foo2</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo2</span><span class=o>&gt;</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>  <span class=c1>// 컨테이너 확장 시 기존 요소 이동에 move constructor 사용
</span></span></span></code></pre></div><p><strong>주의</strong>
기본 생성자, 소멸자, <code>swap</code> 함수, <code>move 연산자</code>는 예외를 발생시켜서는 안 됩니다.</p><h2 id=템플릿과-제네릭-프로그래밍><a name=c9-8></a>템플릿과 제네릭 프로그래밍</h2><h3 id=규칙-981-openharmony-프로젝트에서-제네릭-프로그래밍을-금지합니다><a name=a9-8-1></a>규칙 9.8.1 OpenHarmony 프로젝트에서 제네릭 프로그래밍을 금지합니다.</h3><p>제네릭 프로그래밍과 객체 지향 프로그래밍의 사상, 철학 및 기교는 완전히 다릅니다. OpenHarmony 프로젝트는 객체 지향 사상을 주류로 사용합니다.</p><p>C++은 매우 유연하고 간결한 타입 안전 인터페이스를 구현할 수 있는 강력한 제네릭 프로그래밍 메커니즘을 제공하며, 타입은 다르지만 동작이 동일한 코드 재사용을 구현할 수 있습니다.</p><p>그러나 C++ 제네릭 프로그래밍에는 다음과 같은 단점이 있습니다:</p><ol><li>제네릭 프로그래밍에 능숙하지 않은 사람들은 종종 객체 지향 로직을 템플릿으로 작성하거나 템플릿 매개변수와 무관한 멤버를 템플릿에 작성하여 논리 혼란과 코드 팽창을 야기합니다.</li><li>템플릿 프로그래밍은 C++에 능숙하지 않은 사람들에게는 종종 모호하고 이해하기 어려운 기교를 사용합니다. 복잡한 곳에서 템플릿을 사용한 코드는 더 이해하기 어려우며, 디버그와 유지 보수가 매우 번거롭습니다.</li><li>템플릿을 사용하면 종종 컴파일 오류 메시지가 매우 친절하지 않습니다: 코드에 오류가 있을 때, 인터페이스가 매우 간단하더라도 템플릿 내부의 복잡한 구현 세부 사항이 오류 메시지에 표시됩니다. 이로 인해 컴파일 오류 메시지가 매우 이해하기 어려워집니다.</li><li>템플릿이 부적절하게 사용되면 런타임 코드 과다 팽창을 야기할 수 있습니다.</li><li>템플릿 코드는 수정과 리팩토링이 어렵습니다. 템플릿 코드는 많은 컨텍스트에서 확장되므로 리팩토링이 모든 확장된 코드에 유용한지 확인하기가 어렵습니다.</li></ol><p>따라서 OpenHarmony 대부분의 부품은 템플릿 프로그래밍을 금지하며, __少数 부품__만이 제네릭 프로그래밍을 사용할 수 있으며, 개발된 템플릿에는 상세한 주석이 있어야 합니다.
예외:</p><ol><li>stl 적층층은 템플릿을 사용할 수 있습니다.</li></ol><h2 id=매크로><a name=c9-9></a>매크로</h2><p>C++ 언어에서 가능한 한 적게 복잡한 매크로를 사용하는 것을 강력히 권고합니다.</p><ul><li>상수 정의의 경우 앞서 언급한 장에 따라 const 또는 열거형을 사용해야 합니다.</li><li>매크로 함수의 경우 가능한 한 간단하게 작성하고 아래 규칙을 따르며, 내부 함수, 템플릿 함수 등을 대체하는 것을 우선시해야 합니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 매크로 함수 사용을 권장하지 않음
</span></span></span><span class=line><span class=cl><span class=cp>#define SQUARE(a, b) ((a) * (b))
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 템플릿 함수, 내부 함수 등을 대체하기 위해 사용하십시오.
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=n>Square</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><p>매크로를 사용해야 하는 경우 C 언어 규칙의 관련 장을 참조하십시오.
<strong>예외</strong>: new, delete의 래핑 처리와 같이 일반적이고 성숙한 애플리케이션의 경우 매크로 사용을 보존할 수 있습니다.</p><h1 id=10-현대-c-특성><a name=c10></a>10 현대 C++ 특성</h1><p>ISO가 2011년 C++11 언어 표준을 발표한 이후, 그리고 2017년 3월 C++17을 발표함에 따라 현대 C++(C++11/14/17 등)은 프로그래밍 효율과 코드 품질을 크게 향상시키는 새로운 언어 특성과 표준 라이브러리를 대량으로 추가했습니다.
이 장에서는 팀이 현대 C++을 보다 효율적으로 사용하고 언어 함정을 피할 수 있도록 돕는 지침을 설명합니다.</p><h2 id=코드-간결성과-안전성-향상><a name=c10-1></a>코드 간결성과 안전성 향상</h2><h3 id=권고-1011-적절히auto를-사용합니다><a name=a10-1-1></a>권고 10.1.1 적절히<code>auto</code>를 사용합니다.</h3><p><strong>이유</strong></p><ul><li><code>auto</code>는 길고 반복적인 타입명을 피하고 정의 변수 시 초기화를 보장할 수 있습니다.</li><li><code>auto</code>의 타입 추론 규칙이 복잡하여 신중히 이해해야 합니다.</li><li>코드를 더 명확하게 만든다면 명시적인 타입을 계속 사용하고 지역 변수에서만<code>auto</code>를 사용하십시오.</li></ul><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 길고 반복적인 타입명 피하기
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 반복적인 타입명 피하기
</span></span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 초기화 보장하기
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// 컴파일 성공, 초기화되지 않음
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>x</span><span class=p>;</span>   <span class=c1>// 컴파일 실패, 초기화 필요
</span></span></span></code></pre></div><p>auto의 타입 추론은 혼동을 야기할 수 있습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>           <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>ca</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>    <span class=c1>// const int
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>   <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>aa</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>         <span class=c1>// int, const와 reference 무시
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila1</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>   <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ila2</span><span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>      <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura1</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>      <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura2</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>     <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura3</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>// int&amp;&amp;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>arr1</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>        <span class=c1>// const int*
</span></span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;</span> <span class=n>arr2</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>       <span class=c1>// const int(&amp;)[10]
</span></span></span></code></pre></div><p><code>auto</code> 타입 추론 시 참조를 무시한다는 점에 주의하지 않으면 성능 문제를 야기할 수 있는 어려운 버그를 도입할 수 있습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>  <span class=c1>// auto는 std::string으로 추론, v[0] 복사
</span></span></span></code></pre></div><p><code>auto</code>를 인터페이스에 사용하는 경우, 예를 들어 헤더 파일의 상수 정의에서 개발자가 값을 수정함에 따라 타입이 변할 수 있습니다.</p><h3 id=규칙-1011-가상-함수를-재정의할-때는override또는final키워드를-사용합니다><a name=r10-1-1></a>규칙 10.1.1 가상 함수를 재정의할 때는<code>override</code>또는<code>final</code>키워드를 사용합니다.</h3><p><strong>이유</strong>
<code>override</code>와<code>final</code>키워드는 함수가 가상 함수이며 기본 클래스의 가상 함수를 재정의함을 보장합니다. 서브 클래스 함수와 기본 클래스 함수 프로토타입이 일치하지 않으면 컴파일 경고가 발생합니다.<code>final</code>은 가상 함수가 서브 클래스에서 다시 재정의되지 않도록 보장합니다.</p><p><code>override</code>또는<code>final</code>키워드를 사용하면 기본 클래스 가상 함수 프로토타입을 수정하고 서브 클래스 재정의 가상 함수를 잊어버린 경우 컴파일 타임에 발견할 수 있습니다. 여러 서브 클래스가 있을 때 가상 함수 재정의 수정 누락을 피할 수 있습니다.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// 컴파일 실패: Derived::Foo와 Base::Foo 프로토타입 불일치, 재정의 아님
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 올바름: Derived::Foo가 Base::Foo 재정의
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=k>final</span><span class=p>;</span>   <span class=c1>// 올바름: Derived::Foo(int)가 Base::Foo(int) 재정의, Derived의 파생 클래스는 이 함수를 다시 재정의할 수 없음
</span></span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 컴파일 실패: Base::Bar는 가상 함수가 아님
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>요약</strong></p><ol><li>기본 클래스에서 처음 가상 함수를 정의할 때는<code>virtual</code>키워드를 사용합니다.</li><li>서브 클래스에서 기본 클래스 가상 함수(소멸자 포함)를 재정의할 때는<code>override</code>또는<code>final</code>키워드를 사용합니다(둘을 함께 사용하지 마십시오). 그리고<code>virtual</code>키워드를 사용하지 마십시오.</li><li>비가상 함수의 경우<code>virtual</code>, <code>override</code>, <code>final</code>을 모두 사용하지 마십시오.</li></ol><h3 id=규칙-1012-delete키워드를-사용하여-함수-삭제합니다><a name=r10-1-2></a>규칙 10.1.2 <code>delete</code>키워드를 사용하여 함수 삭제합니다.</h3><p><strong>이유</strong>
클래스 멤버 함수를<code>private</code>로 선언하고 구현하지 않는 것에 비해<code>delete</code>키워드는 더 명확하며 적용 범위가 더 넓습니다.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 헤더 파일만 보아서는 복사 생성자가 삭제되었는지 알 수 없습니다.
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 복사 할당 함수를 명확히 삭제합니다.
</span></span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>delete</code>키워드는 비멤버 함수 삭제도 지원합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=규칙-1013-nullptr을-사용하고null또는0을-사용하지-마십시오><a name=r10-1-3></a>규칙 10.1.3 <code>nullptr</code>을 사용하고<code>NULL</code>또는<code>0</code>을 사용하지 마십시오.</h3><p><strong>이유</strong>
오랫동안 C++에는 널 포인터를 나타내는 키워드가 없어서 곤란한 상황이었습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NULL ((void *)0)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// 오류: void*는 char*로 자동 변환되지 않음
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=p>(</span><span class=n>C</span><span class=o>::*</span><span class=n>pmf</span><span class=p>)()</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>C</span><span class=o>::</span><span class=n>Func</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pmf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 오류: void*는 멤버 함수 포인터로 자동 변환되지 않음
</span></span></span></code></pre></div><p><code>NULL</code>을<code>0</code>또는<code>0L</code>로 정의하면 위 문제를 해결할 수 있습니다.</p><p>또는 널 포인터가 필요한 곳에 직접<code>0</code>을 사용합니다. 그러나 이는 또 다른 문제를 야기합니다. 코드가 명확하지 않으며 특히<code>auto</code>자동 추론을 사용할 때:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find()는 포인터를 반환하나요? 정수를 반환하나요?
</span></span></span><span class=line><span class=cl>    <span class=c1>// 무언가 수행
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>0</code>은 문자 그대로<code>int</code>타입(<code>0L</code>은<code>long</code>), 따라서<code>NULL</code>과<code>0</code>은 모두 포인터 타입이 아닙니다.
포인터와 정수 타입을 오버로딩한 함수에<code>NULL</code>이나<code>0</code>을 전달하면 정수 타입 오버로딩 함수가 호출됩니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>      <span class=c1>// F(int) 호출, F(int*) 아님
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>   <span class=c1>// F(int) 호출, F(int*) 아님
</span></span></span></code></pre></div><p>또한<code>sizeof(NULL) == sizeof(void*)</code>가 항상 성립한다는 보장은 없으며, 이는 잠재적 위험입니다.</p><p>요약하면:<code>0</code>이나<code>0L</code>을 직접 사용하면 코드가 명확하지 않으며 타입 안전을 보장하지 못합니다.<code>NULL</code>은 타입 안전을 보장하지 못합니다. 모두 잠재적 위험입니다.</p><p><code>nullptr</code>의 장점은 문자 그대로 널 포인터를 나타내는 것뿐만 아니라 더 이상 정수 타입이 아니라는 점입니다.</p><p><code>nullptr</code>은<code>std::nullptr_t</code>타입이며,<code>std::nullptr_t</code>는 모든 원시 포인터 타입으로 암시적 변환이 가능하여<code>nullptr</code>가 모든 타입의 널 포인터로 작동할 수 있습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// F(int*) 호출
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find()는 포인터를 반환합니다.
</span></span></span><span class=line><span class=cl>    <span class=c1>// 무언가 수행
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=규칙-1014-using을-사용하고typedef를-사용하지-마십시오><a name=r10-1-4></a>규칙 10.1.4 <code>using</code>을 사용하고<code>typedef</code>를 사용하지 마십시오.</h3><p><code>C++11</code>이전에는<code>typedef</code>를 통해 타입의 별명을 정의할 수 있었습니다. <code>std::map&lt;uint32_t, std::vector&lt;int>></code>와 같은 코드를 여러 번 반복하는 것을 아무도 원하지 않을 것입니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>SomeType</span><span class=p>;</span>
</span></span></code></pre></div><p>타입의 별명은 실제로 타입의 캡슐화입니다. 캡슐화를 통해 코드를 더 명확하게 만들 수 있으며,很大程度上 타입 변화로 인한 산탄식 수정을 피할 수 있습니다.
<code>C++11</code>이후<code>using</code>을 제공하여<code>별명 선언(alias declarations)</code>을 구현합니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>SomeType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>두 형식을 비교하면:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Type</span> <span class=n>Alias</span><span class=p>;</span>   <span class=c1>// Type이 먼저 오나요? Alias가 먼저 오나요?
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Alias</span> <span class=o>=</span> <span class=n>Type</span><span class=p>;</span>   <span class=c1>// &#39;할당&#39; 사용법과 일치, 이해하기 쉬움, 실수 적음
</span></span></span></code></pre></div><p><code>using</code>으로 전환하는 것이 충분하지 않다면<code>템플릿 별명(alias template)</code>을 살펴보겠습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 템플릿의 별명을 정의, 한 줄 코드
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyAllocatorVector</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>       <span class=c1>// using으로 정의한 별명 사용
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data_</span><span class=p>;</span>   <span class=c1>// 템플릿 클래스에서 using으로 정의한 별명 사용
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>그러나<code>typedef</code>는 템플릿 매개변수가 있는 별명을 지원하지 않습니다. 대신"우회로"를 사용해야 합니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// typedef를 래핑하는 템플릿을 통해 별명을 정의, 템플릿 클래스를 구현해야 합니다.
</span></span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyAllocatorVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// typedef으로 정의한 별명 사용, ::type 추가 필요
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data_</span><span class=p>;</span>  <span class=c1>// 템플릿 클래스에서 사용, ::type 추가와 typename 필요
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=규칙-1015-const-객체에stdmove를-금지합니다><a name=r10-1-5></a>규칙 10.1.5 const 객체에<code>std::move</code>를 금지합니다.</h3><p>문자 그대로<code>std::move</code>는 객체를 이동한다는 의미입니다. const 객체는 수정할 수 없으므로 당연히 이동할 수 없습니다. 따라서<code>std::move</code>를 const 객체에 사용하면 코드 리더에게 혼란을 야기합니다.
실제 기능에서<code>std::move</code>는 객체를右값 참조 타입으로 변환합니다. const 객체의 경우 const右값 참조로 변환됩니다. 거의 모든 타입이 const右값 참조를 매개변수로 하는 이동 생성자와 이동 할당 연산자를 정의하지 않기 때문에 코드의 실제 기능은 종종 객체 복사로 퇴화하여 성능 저하를 야기합니다.</p><p><strong>잘못된 예시:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>g_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>g_stringList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>myString</span> <span class=o>=</span> <span class=s>&#34;String content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>myString</span><span class=p>);</span> <span class=c1>// 나쁨: myString을 이동하지 않고 복사했습니다.
</span></span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=s>&#34;Another string content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_stringList</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>anotherString</span><span class=p>));</span>    <span class=c1>// 나쁨: anotherString을 이동하지 않고 복사했습니다.
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=스마트-포인터><a name=c10-2></a>스마트 포인터</h2><h3 id=규칙-1021-소유권이-다방면에서-보유되지-않는-단일-인스턴스-클래스-멤버-등은-스마트-포인터보다-원시-포인터를-우선-사용합니다><a name=r10-2-1></a>규칙 10.2.1 소유권이 다방면에서 보유되지 않는 단일 인스턴스, 클래스 멤버 등은 스마트 포인터보다 원시 포인터를 우선 사용합니다.</h3><p><strong>이유</strong>
스마트 포인터는 자동으로 객체 자원을 해제하여 자원 누수를 피할 수 있지만 추가 자원 오버헤드가 있습니다. 예를 들어 스마트 포인터가 자동으로 생성하는 클래스, 생성 및 소멸 오버헤드, 메모리 사용량 증가 등입니다.</p><p>단일 인스턴스, 클래스 멤버 등 객체 소유권이 다방면에서 보유되지 않는 경우 클래스 소멸 시 자원 해제만 하면 됩니다. 추가 오버헤드를 야기하는 스마트 포인터를 사용해서는 안 됩니다.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>foo_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>foo_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>예외</strong></p><ol><li>객체를 반환할 때 포인터 소멸 함수가 필요한 경우 스마트 포인터를 사용할 수 있습니다.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>CreateUniqueUser</span><span class=p>()</span> <span class=c1>// unique_ptr을 사용하여 객체 생성과 해제가 동일한 runtime에서 이루어지도록 보장할 수 있습니다.
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=o>::</span><span class=k>new</span> <span class=n>User</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>),</span> <span class=p>[](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>user</span><span class=o>-&gt;</span><span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>::</span><span class=k>delete</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>CreateSharedUser</span><span class=p>()</span> <span class=c1>// shared_ptr을 사용하여 객체 생성과 해제가 동일한 runtime에서 이루어지도록 보장할 수 있습니다.
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>.</span><span class=n>GetRefPtr</span><span class=p>(),</span> <span class=p>[</span><span class=n>ipcUser</span><span class=p>](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ipcUser</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>객체를 반환하고 객체가 다방면에서 참조되어야 하는 경우 shared_ptr을 사용할 수 있습니다.</li></ol><h3 id=규칙-1022-stdmake_unique를-사용하고new를-사용하지-마십시오><a name=r10-2-2></a>규칙 10.2.2 <code>std::make_unique</code>를 사용하고<code>new</code>를 사용하지 마십시오.</h3><p><strong>이유</strong></p><ol><li><code>make_unique</code>는 더 간결한 생성 방식을 제공합니다.</li><li>복잡한 표현식에서 예외 안전을 보장합니다.</li></ol><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 나쁨: MyClass가 두 번 나타나 중복으로 인한 불일치 위험이 있음
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 좋음: MyClass가 한 번만 나타나 불일치 위험이 없음
</span></span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>타입 중복은 매우 심각한 문제를 야기할 수 있으며 발견하기 어렵습니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 컴파일 성공, new와 delete가 맞지 않음
</span></span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=mi>10</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 비예외 안전: 컴파일러가 함수 인수를 다음과 같이 계산할 수 있음:
</span></span></span><span class=line><span class=cl><span class=c1>// 1. Foo 메모리 할당,
</span></span></span><span class=line><span class=cl><span class=c1>// 2. Foo 생성,
</span></span></span><span class=line><span class=cl><span class=c1>// 3. Bar 호출,
</span></span></span><span class=line><span class=cl><span class=c1>// 4. unique_ptr&lt;Foo&gt; 생성.
</span></span></span><span class=line><span class=cl><span class=c1>// Bar가 예외를 발생시킬 경우 Foo는 파괴되지 않고 메모리 누수가 발생합니다.
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>()),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 예외 안전: 함수 호출이 방해받지 않음.
</span></span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>예외</strong>
<code>std::make_unique</code>는 사용자 정의<code>deleter</code>를 지원하지 않습니다.
사용자 정의<code>deleter</code>가 필요한 시나리오에서는 자신의 네임스페이스에서 맞춤형<code>make_unique</code>버전을 구현하는 것이 좋습니다.
사용자 정의<code>deleter</code>가 있는<code>unique_ptr</code>을 생성하기 위해<code>new</code>를 사용하는 것은 마지막 선택입니다.</p><h3 id=규칙-1024-stdmake_shared를-사용하고new를-사용하지-마십시오><a name=r10-2-4></a>규칙 10.2.4 <code>std::make_shared</code>를 사용하고<code>new</code>를 사용하지 마십시오.</h3><p><strong>이유</strong>
<code>std::make_shared</code>를 사용하여<code>std::shared_ptr</code>을 생성하는 것은 일관성 등의 이유 외에도 성능 측면에서 이점이 있습니다.
<code>std::shared_ptr</code>는 두 개의 엔티티를 관리합니다:</p><ul><li>제어 블록(참조 카운트, <code>deleter</code> 등 저장)</li><li>관리 객체</li></ul><p><code>std::make_shared</code>를 사용하여<code>std::shared_ptr</code>을 생성하면 힙에서 제어 블록과 관리 객체를 모두 수용할 수 있는 메모리를 한 번에 할당합니다. 반면<code>std::shared_ptr&lt;MyClass>(new MyClass)</code>를 사용하여<code>std::shared_ptr</code>을 생성하는 것은<code>new MyClass</code>가 힙 할당을 트리거할 뿐만 아니라<code>std::shard_ptr</code>의 생성자도 두 번째 힙 할당을 트리거하여 추가 오버헤드를 야기합니다.</p><p><strong>예외</strong>
<code>std::make_unique</code>와 마찬가지로<code>std::make_shared</code>는 사용자 정의<code>deleter</code>를 지원하지 않습니다.</p><h2 id=lambda><a name=c10-3></a>Lambda</h2><h3 id=권고-1031-함수가-작동하지-않을-때lambda지역-변수-캡처-또는-지역-함수-작성를-선택합니다><a name=a10-3-1></a>권고 10.3.1 함수가 작동하지 않을 때<code>lambda</code>(지역 변수 캡처 또는 지역 함수 작성)를 선택합니다.</h3><p><strong>이유</strong>
함수는 지역 변수를 캡처하거나 지역 범위에서 선언할 수 없습니다. 지역 상태를 캡처하거나 문장 또는 표현식 범위에 나타날 필요가 있는 경우 가능한 한<code>lambda</code>를 선택하고 수동으로 작성한<code>functor</code>는 피합니다.
반면에<code>lambda</code>와<code>functor</code>는 오버로드할 수 없습니다. 오버로드가 필요하면 함수를 사용합니다.
<code>lambda</code>와 함수 모두 가능한 시나리오에서는 함수를 우선 사용합니다. 가능한 한 간단한 도구를 사용합니다.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// int 또는 string만 수용하는 함수를 작성
</span></span></span><span class=line><span class=cl><span class=c1>// -- 오버로드는 자연스러운 선택
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 지역 상태를 캡처하거나 다른 스레드로 전달
</span></span></span><span class=line><span class=cl><span class=c1>// -- lambda는 자연스러운 선택
</span></span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>Work</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=n>LotsOfWork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>taskNum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>taskNum</span> <span class=o>&lt;</span> <span class=n>max</span><span class=p>;</span> <span class=o>++</span><span class=n>taskNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pool</span><span class=p>.</span><span class=n>Run</span><span class=p>([</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>]</span> <span class=p>{...});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=규칙-1031-비지역-범위에서lambdas를-사용할-때는-참조로-캡처를-피합니다><a name=r10-3-2></a>규칙 10.3.1 비지역 범위에서<code>lambdas</code>를 사용할 때는 참조로 캡처를 피합니다.</h3><p><strong>이유</strong>
비지역 범위의<code>lambdas</code>에는 반환값, 힙에 저장, 또는 다른 스레드로 전달이 포함됩니다. 지역 포인터와 참조는 지역 변수의 수명을 초과하여 존재해서는 안 됩니다.<code>lambdas</code>가 참조로 캡처하면 지역 객체의 참조를 저장하는 것입니다. 이것이 지역 변수 수명을 초과하는 참조를 야기하면 참조로 캡처해서는 안 됩니다.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 나쁨
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// local을 참조로 캡처.
</span></span></span><span class=line><span class=cl>    <span class=c1>// 함수가 반환된 후 local은 더 이상 존재하지 않으며,
</span></span></span><span class=line><span class=cl>    <span class=c1>// 따라서 Process()의 동작은 정의되지 않았습니다!
</span></span></span><span class=line><span class=cl>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 좋음
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// local을 값으로 캡처.
</span></span></span><span class=line><span class=cl>    <span class=c1>// 복사본으로 인해 Process() 호출 중 local은 항상 유효합니다.
</span></span></span><span class=line><span class=cl>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=권고-1032-this를-캡처하는-경우-모든-변수를-명시적으로-캡처합니다><a name=a10-3-2></a>권고 10.3.2 <code>this</code>를 캡처하는 경우 모든 변수를 명시적으로 캡처합니다.</h3><p><strong>이유</strong>
멤버 함수의<code>[=]</code>는 값으로 캡처하는 것처럼 보입니다. 그러나 암시적으로<code>this</code>포인터를 값으로 캡처하여 모든 멤버 변수에 접근할 수 있기 때문에 멤버 변수는 실제로는 참조로 캡처됩니다. 일반적으로 이것은 피해야 합니다. 실제로这样做해야 하는 경우 this 캡처를 명시적으로 작성하십시오.</p><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span>   <span class=c1>// 나쁨: 값으로 캡처하는 것처럼 보이지만 멤버 변수는 실제로 참조로 캡처됨
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// use(42) 호출;
</span></span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// use(43) 호출;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda2</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=k>this</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span> <span class=c1>// 좋음, 명시적으로 값을 캡처하여 혼동을 최소화함
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=권고-1033-기본-캡처-모드-사용을-피합니다><a name=a10-3-3></a>권고 10.3.3 기본 캡처 모드 사용을 피합니다.</h3><p><strong>이유</strong>
lambda 표현식은 두 가지 기본 캡처 모드를 제공합니다: 참조(&)와 값(=).
기본 참조 캡처는 모든 지역 변수의 참조를 암시적으로 캡처하여 액세스할 수 없는 참조를 야기할 수 있습니다. 반대로 명시적으로 캡처할 변수를 작성하면 객체 수명 주기를 더 쉽게 검사할 수 있어 실수 가능성을 줄일 수 있습니다.
기본 값 캡처는 this 포인터를 암시적으로 캡처하여 lambda 함수가 의존하는 변수가 무엇인지 명확히 알기 어렵게 만듭니다. 정적 변수가 있는 경우 lambda가 정적 변수의 복사본을 가지고 있는 것으로 오인하게 만들 수도 있습니다.
따라서 일반적으로 lambda가 캡처해야 하는 변수를 명시적으로 작성하고 기본 캡처 모드를 사용하지 않는 것이 좋습니다.</p><p><strong>잘못된 예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span>  <span class=c1>// 실제로는 addend만 복사함
</span></span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 정적 변수 값에 영향을 줌
</span></span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>올바른 예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>addend</span><span class=p>,</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=n>baseValue</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span>  <span class=c1>// C++14의 캡처 초기화를 사용하여 변수의 복사본을 만듦
</span></span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 정적 변수 값에 영향을 주지 않고 자신의 복사본을 수정함
</span></span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>참조: 《Effective Modern C++》: Item 31: Avoid default capture modes.</p><h2 id=인터페이스><a name=c10-4></a>인터페이스</h2><h3 id=권고-1041-소유권과-무관한-시나리오에서는-스마트-포인터-대신t또는t를-매개변수로-사용합니다><a name=a10-4-1></a>권고 10.4.1 소유권과 무관한 시나리오에서는 스마트 포인터 대신<code>T*</code>또는<code>T&</code>를 매개변수로 사용합니다.</h3><p><strong>이유</strong></p><ol><li>명시적으로 소유권 메커니즘을 전달하거나 공유해야 할 때만 스마트 포인터를 사용합니다.</li><li>스마트 포인터를 통해 전달하면 함수 호출자가 스마트 포인터를 사용하도록 제한됩니다(예: 호출자가 this를 전달하려는 경우).</li><li>공유 소유권 스마트 포인터 전달에는 런타임 오버헤드가 있습니다.</li></ol><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 모든 int*를 수용
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 소유권을 이전하려는 int만 수용
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 소유권을 공유하려는 int만 수용
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 소유권을 변경하지 않지만 특정 소유권 호출자를 필요로 하는 경우
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=k>const</span> <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 모든 int를 수용
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁨
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl>    <span class=n>Use</span><span class=p>(</span><span class=o>*</span><span class=n>w</span><span class=p>);</span> <span class=c1>// w만 사용 -- 수명 주기 관리와 완전히 무관
</span></span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><br><script src=https://giscus.app/client.js data-repo=jqknono/blog data-repo-id=R_kgDONOhENQ data-category=Announcements data-category-id=DIC_kwDONOhENc4CkQDB data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script><br><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a href=/ko-kr/blog/2024/06/28/%EC%A4%91%EA%B5%AD-%EC%A0%84%EC%8B%A0-ipv6%EC%9D%98-%EB%AA%87-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/ aria-label="이전 - 중국 전신 IPv6의 몇 가지 특징" class="btn btn-primary"><span class=me-1>←</span>이전</a></li><li><a href=/ko-kr/blog/2024/06/28/%EB%AA%85%EB%A0%B9%EC%A4%84-%EB%A7%A4%EB%89%B4%EC%96%BC%EC%97%90%EC%84%9C-%EB%8C%80%EA%B4%84%ED%98%B8%EC%9D%98-%EC%9D%98%EB%AF%B8/ aria-label="다음 - 명령줄 매뉴얼에서 대괄호의 의미" class="btn btn-primary">다음<span class=ms-1>→</span></a></li></ul></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/jqknono aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2015&ndash;2026
<span class=td-footer__authors>jqknono</span></span><span class=td-footer__all_rights_reserved>모든 권리 보유</span></div></div></div></footer></div><script src=/js/main.min.70d2ef91374ec2569b2dc1ee9e7569822c0339dc6ba611092d40f6935e5c601a.js integrity="sha256-cNLvkTdOwlabLcHunnVpgiwDOdxrphEJLUD2k15cYBo=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>