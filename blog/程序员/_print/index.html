<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://blog.jqknono.com/blog/%E7%A8%8B%E5%BA%8F%E5%91%98/><link rel=alternate type=application/rss+xml href=https://blog.jqknono.com/blog/%E7%A8%8B%E5%BA%8F%E5%91%98/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>程序员 | Nono Blogs</title>
<meta name=description content="jqknono 的博客"><meta property="og:url" content="https://blog.jqknono.com/blog/%E7%A8%8B%E5%BA%8F%E5%91%98/"><meta property="og:site_name" content="Nono Blogs"><meta property="og:title" content="程序员"><meta property="og:description" content="jqknono 的博客"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="website"><meta itemprop=name content="程序员"><meta itemprop=description content="jqknono 的博客"><meta itemprop=datePublished content="2024-06-28T18:29:45+08:00"><meta itemprop=dateModified content="2024-06-28T18:29:45+08:00"><meta itemprop=keywords content="教程,程序员"><meta name=twitter:card content="summary"><meta name=twitter:title content="程序员"><meta name=twitter:description content="jqknono 的博客"><link rel=preload href=/scss/main.min.8acecbf86e7556fec1884b2edb0c0a5fcb36544832255924728123faf38ac587.css as=style integrity="sha256-is7L+G51Vv7BiEsu2wwKX8s2VEgyJVkkcoEj+vOKxYc=" crossorigin=anonymous><link href=/scss/main.min.8acecbf86e7556fec1884b2edb0c0a5fcb36544832255924728123faf38ac587.css rel=stylesheet integrity="sha256-is7L+G51Vv7BiEsu2wwKX8s2VEgyJVkkcoEj+vOKxYc=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3FFTG72NE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3FFTG72NE")}</script></head><body class="td-section td-blog"><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Nono Blogs</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/blog/><i class='fas fa-cube'></i><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/docs/><i class='fas fa-book'></i><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=https://www.adguardprivate.com target=_blank rel=noopener><i class="fa-solid fa-fire"></i><span>创建私有Adguard</span><sup><i class="ps-1 fa-solid fa-up-right-from-square fa-xs" aria-hidden=true></i></sup></a></li><li class="td-light-dark-menu nav-item dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown data-bs-display=static aria-label="Toggle theme (auto)"><svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=bd-theme-text><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder=站内搜索… aria-label=站内搜索… autocomplete=off data-offline-search-index-json-src=/offline-search-index.efb6bc8fe6239775d509424993cbfc97.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/blog/%E7%A8%8B%E5%BA%8F%E5%91%98/>返回本页常规视图</a>.</p></div><h1 class=title>程序员</h1><ul><li><a href=#pg-9008fe73cde27a37036c6653c441588b>AI辅助编程</a></li><ul><li><a href=#pg-fdda6d076c56597c2d0b47ae31e4e0b5>AI助手比我聪明很多</a></li></ul><li><a href=#pg-5dfa29ccf7ffd4e4504c0c31b00d43c7>网络</a></li><ul><li><a href=#pg-5135bc6d7e7e3d0b75e018935a2afe3b>几个更安全使用公网IPv6的方法</a></li><li><a href=#pg-5cb0c1e11404db39814ae13e98108704>使用常见DDns子域名可能导致电信宽带服务降级</a></li><li><a href=#pg-cec8cf4eb40d88442b70c33f22fbdcc8>家庭网络反向代理的合规性探讨</a></li><li><a href=#pg-931e8eabbd265e7a3bb27d5aa98c3a49>电信IPv6的一些特征</a></li><li><a href=#pg-d088abdb6aab928dad39e27339dd9e87>为什么不应该把TCP思维套在UDP上</a></li><li><a href=#pg-fe14363a9954cb1fb6a2e4a51ef7d5a1>linux网络问题定位</a></li><li><a href=#pg-953696aca9e6689f10d238a6951f475a>如何提升自建DNS服务下的网络体验</a></li><li><a href=#pg-b0ccb01b3aa156438a93cad783d70d49>ChatGPT VPN识别绕过方法</a></li></ul><li><a href=#pg-27c0946c3b62da5f9bdf5d716e89b1ee>杂谈</a></li><ul><li><a href=#pg-e5352cfd6ed96421590af4134771f495>第三方库的陷阱</a></li><li><a href=#pg-f222a10259ecfac0268b18dba6ac986d>方案设计模板</a></li><li><a href=#pg-71c0f3c3e40e5c2307f21b32faf153e5>命令行语法约定</a></li><li><a href=#pg-e937233f5b1797cb39278fd277a8fe8a>命令行手册中括号的含义</a></li><li><a href=#pg-3078f141cd9bdd78799762525d6ed14b>华为C++编程规范</a></li></ul><li><a href=#pg-d260067c1c520d9cc0388047931880b9>问题定位</a></li><ul></ul><li><a href=#pg-5afb8099be6c39ce4dddecbb6d7c8f42>environment</a></li><ul><li><a href=#pg-d3262c6340c09c138f8830e17cfe7666>虚拟内存磁盘配置</a></li><li><a href=#pg-6fa893880eea41a50f03f1fa6455f490>wsl</a></li><li><a href=#pg-6617997f4122afb177edebfea3b07572>vs-remote-debug</a></li><li><a href=#pg-125b181c6e3c8f5fe9891c1835c9b2b7>vscode</a></li><ul></ul></ul><li><a href=#pg-ca251b26ebf6248b9dd287928b686a42>OS</a></li><ul><li><a href=#pg-4c9ceb39a2e6db0c11cf6dea08bd5472>linux</a></li><ul><li><a href=#pg-857dd99748f3a61de100fe2e04bba847>linux导览</a></li></ul><li><a href=#pg-1f064054229b961c68c0b418618cbc82>windows</a></li><ul><li><a href=#pg-feed9e21730b5856a268e31d6db06c37>理解Windows网络_WFP</a></li><li><a href=#pg-021d3a093eb8786e8c11c6673103012b>理解Windows事件跟踪_ETW</a></li><li><a href=#pg-2ff6fe9b17c0d87d77c11f27a7fa527c>wireguard配置</a></li><li><a href=#pg-6fd322b95dfd6a5f84894ff330485c26>Windows阻断网络流量获取</a></li><li><a href=#pg-98219600397f17c3d5e4ac6fbfc5f707>Windows防火墙管理-netsh</a></li><li><a href=#pg-ea3b4f1af238c774fab2871e85bf40ef>Windows相关资源</a></li><li><a href=#pg-cb9613752bee2e31a2596d114cfa27f0>Windows导览</a></li><li><a href=#pg-add85b56bb4af8b5216a8122ebeea317>windows-ipv6管理</a></li><li><a href=#pg-e9e3d6173c9a65d937dabcb06bfd3085>window-message</a></li><li><a href=#pg-193faaa62417d666d3091475b953c37f>Win-to-go</a></li></ul></ul><li><a href=#pg-98d47cdc0b45fd5888633472125c6bce>设计模式究竟有几个原则</a></li><li><a href=#pg-05350a194e913f1a0ae82c3a0ad530da>多平台内容发布工具--蚁小二体验</a></li><li><a href=#pg-07009eb0faa2af68d3ead7fafed15c12>简书的创作体验</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9008fe73cde27a37036c6653c441588b>AI辅助编程</h1><div class="td-byline mb-4"><time datetime=2025-03-17 class=text-body-secondary>Monday, March 17, 2025</time></div><p>拥抱变化.</p></div><div class=td-content><h1 id=pg-fdda6d076c56597c2d0b47ae31e4e0b5>AI助手比我聪明很多</h1><div class="td-byline mb-4"><time datetime=2025-03-17 class=text-body-secondary>Monday, March 17, 2025</time></div><p>对于一个从事编码工作 10 年, 有过镀金经历, 最终也看重面子的中年人, 承认 AI 比我厉害是一件很难为情的事.</p><p>所用的 AI 工具, 一个月总花费不超过 200 元人民币, 而老板给我的薪酬远高于此.</p><p>可以预期会引来众嘲,</p><blockquote><p>&ldquo;那只是你&rdquo;</p></blockquote><blockquote><p>&ldquo;初级程序员是这样的&rdquo;</p></blockquote><blockquote><p>&ldquo;只能做简单的活&rdquo;</p></blockquote><blockquote><p>&ldquo;做不了真正的工程&rdquo;</p></blockquote><blockquote><p>&ldquo;幻觉严重&rdquo;</p></blockquote><blockquote><p>&ldquo;不适合生产环境&rdquo;</p></blockquote><p>我的 AI 工具使用经验足以支持我无视这些嘲讽, 本文不会推荐任何工具, 主要只为思想上的共鸣, 每次都能从跟贴学习到很多.</p><p>我是 Github Copilot 的第一批用户, 从内测就开始使用, 内测完毫不犹豫订了年费, 使用至今. 现在我已不会因为靠自己解决了棘手问题而兴奋, 不会为"优雅的代码"而骄傲, 现在我只为一件事而兴奋, 那就是 AI 准确理解了我的表达, AI 助手完成我的需求, 并且超出了预期.</p><p>在过去十年积累的经验, 在 AI 工具上最有用的是:</p><ul><li>逻辑学</li><li>设计模式</li><li>正则表达式</li><li>markdown</li><li>mermaid</li><li>代码风格</li><li>数据结构和算法</li></ul><p>更细化一点就是:</p><ul><li>大前提, 小前提, 合适的关联关系.</li><li>谨慎创建依赖关系, 严防循环依赖.</li><li>如无必要, 不增加关联关系, 如无必要, 不扩大关联范围.</li><li>严控逻辑块规模.</li><li>使用正则搜索, 并根据命名风格，生成便于正则搜索的代码.</li><li>生成 mermaid, 检视修改微调, 使用 mermaid 指导代码生成.</li><li>使用数据结构和算法的<strong>名称</strong>, 指导代码生成.</li></ul><p>我花了很多时间参与不同的开源项目, 有的是熟悉的领域, 有的是不熟悉的领域, 是经验使我能快速上手. 你会发现, 优秀的项目总是相似的, 挫的项目各有各的挫法.</p><p>如果我记忆力逐渐衰退， 渐渐忘掉了过去积累的所有经验, 但还不得不从事程序员工作养家糊口, 我可以写一张纸条提醒自己, 只能写下最简短的提示词的话, 我会写下: <code>Google "How-To-Ask-Questions"</code></p><blockquote><p>人是否比 AI 更聪明？ 还是部分人比部分 AI 更聪明?</p></blockquote><p>我必须诚实承认, 往自己脸上贴金没有任何实际好处. 正如标题所述, 这篇文章就是撕开面子,展示我内心的真实想法, AI 比我要厉害, 厉害的多. 每当我开始怀疑 AI 时, 我将要提醒自己:</p><blockquote><p>AI 是否比人更蠢？ 还是只是部分人比部分 AI 蠢? 我是否应该重新提问?</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-5dfa29ccf7ffd4e4504c0c31b00d43c7>网络</h1><div class="td-byline mb-4"><time datetime=2024-11-13 class=text-body-secondary>Wednesday, November 13, 2024</time></div><ul><li><input disabled type=checkbox> 网络</li></ul><h1 id=网络>网络</h1><ul><li>绕墙<ul><li>[<a href=wireguard%E5%AF%B9%E6%8A%97%E8%BF%90%E8%90%A5%E5%95%86 title=wireguard对抗运营商>wireguard对抗运营商</a>]</li></ul></li><li>网络问题定位<ul><li>[<a href=/blog/2024/05/28/linux%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/ title=linux网络问题定位>linux网络问题定位</a>]</li><li>[<a href=windows%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D title=windows网络问题定位>windows网络问题定位</a>]</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5135bc6d7e7e3d0b75e018935a2afe3b>几个更安全使用公网IPv6的方法</h1><div class="td-byline mb-4"><time datetime=2025-02-28 class=text-body-secondary>Friday, February 28, 2025</time></div><p>有些人会有使用公网 IPv6 回家的需求, 不同于 tailscale/zerotier 等 VPN 需要内网穿透打洞来建立直连的方式, IPv6 回家就是直连, 手机蜂窝网络大多数时候都是有 IPv6 的, 回家非常方便.</p><p>我之前分享过一篇文章<a href=https://www.v2ex.com/t/1112630>家庭宽带使用常见 DDns 子域名可能会使电信宽带服务降级</a>, 描述使用 IPv6 时运营商挖的一个坑, 简短来说就是域名会被扫, 暴漏自己的域名等同于暴露 IPv6, 因此可能会被扫描, 扫到服务后入站连接一多就降级宽带服务.</p><p>那篇分享里只提到了域名扫描, 没有提到<code>网络空间扫描</code>, 这种扫描不管什么暴露的信息, 直接遍历 IP 池开扫, 这种情况较难防.</p><p><code>网络空间扫描</code>通常包括以下几个方面：</p><ul><li>IP 存活性探测：利用 ARP、ICMP、TCP 等协议来识别在线主机。</li><li>端口/服务探测：通过端口扫描筛选出在线主机的开放端口，并获取目标主机的服务信息、版本信息以及操作系统信息。</li><li>操作系统探测：通过分析响应数据包来推断目标主机的操作系统类型和版本。</li><li>流量采集：监控网络流量以发现异常行为或攻击模式。</li><li>别名解析：针对拥有多个 IP 地址的路由器，建立 IP 地址与路由器之间的映射关系。</li><li>DNS 探测：通过 IP 地址反向解析建立 IP 地址与域名之间的对应关系。</li></ul><p>这里分享几个避免被网络空间扫描扫到的方法:</p><ol><li>内网 DNS 服务器不返回 AAAA 记录</li><li>内网服务仅允许通过域名访问, 不允许直接通过 IP 访问</li><li>使用私有 DNS 服务<a href=https://www.adguardprivate.com>AdGuardPrivate</a></li></ol><h2 id=内网-dns-服务器不返回-aaaa-记录>内网 DNS 服务器不返回 AAAA 记录</h2><p>上网时上到各式各样的网站, 这样自然的访问就可以暴露源 IPv6, 对方服务器可以获取源 IPv6, 用户侧如果没开防火墙的话, 这个 IPv6 就可以放到网络空间扫描的优先遍历池里.</p><p>还可以将<code>/56</code>前缀的 IPv6 地址放到扫描池里, 仅遍历低 16 位, 扫描范围也可大大缩减.</p><p>我使用多年 IPv6 的体会, 日常上网时 IPv6 相较 IPv4 没有明显的区别. 因此我们可以牺牲 IPv6 的外访, 仅用来直连回家.</p><h3 id=设置不返回-ipv6-解析方法>设置不返回 IPv6 解析方法</h3><p>在内网 DNS 服务器上, 设置不返回 <code>AAAA</code> 记录.</p><p>内网 DNS 服务一般用的 AdGuardHome, 参考设置:</p><p><img alt=设置禁用IPv6 src=https://img1.techfetch.dev/blog/202502281307671.png></p><p>设置后, 内网设备访问外网时只会使用 IPv4, 不会再使用 IPv6.</p><h2 id=内网服务仅允许通过域名访问>内网服务仅允许通过域名访问</h2><p>可能家里暴露的服务可以基于端口访问, 这样非常容易被扫到存在服务.</p><p>最好在创建服务时, 不要做监听<code>0.0.0.0</code>和<code>::</code>这样的设置, 经验丰富的能体会到, 几乎所有服务启动指导默认都只监听<code>127.0.0.1</code>和<code>::1</code>, 这是因为监听公网 IP 是存在风险的.</p><h3 id=反向代理仅允许域名设置方法>反向代理仅允许域名设置方法</h3><h4 id=nginx-示例>nginx 示例</h4><p>关键是设置<code>server_name</code>为域名, 不要设置为<code>_</code>或<code>IP</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kn>listen</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kn>server_name</span> <span class=s>yourdomain.com</span><span class=p>;</span> <span class=c1># 将yourdomain.com替换为您的实际域名
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1># 返回403 Forbidden给那些试图通过IP地址访问的用户
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kn>if</span> <span class=s>(</span><span class=nv>$host</span> <span class=s>!=</span> <span class=s>&#39;yourdomain.com&#39;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kn>return</span> <span class=mi>403</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1># 这里是您的网站根目录和其他配置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kn>root</span> <span class=s>/path/to/your/web/root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kn>index</span> <span class=s>index.html</span> <span class=s>index.htm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 其他配置...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=iis-示例>IIS 示例</h4><p>关键是设置<code>host name</code>为域名, 不要留空.</p><p><img alt="IIS 示例" src=https://img1.techfetch.dev/blog/202502281323570.png></p><h3 id=使用私有-dns-服务>使用私有 DNS 服务</h3><p>在仅自己使用的 DNS 服务中添加自定义解析, 以伪造的域名解析到内网服务.</p><p><img alt=DNS重写功能 src=https://img1.techfetch.dev/blog/202502281330658.png></p><p>这样做有几个明显的好处.</p><ol><li>首先域名是可以随便构造的, 不需要购买域名, 省一笔域名费用. 如果这种伪造域名被扫到, 那么攻击者需要请求你的 DNS 服务才能获取到正确解析结果.</li><li>需要同时暴露自己的私有 DNS 服务地址, 以及虚拟域名, 然后扫描者需要修改域名的解析逻辑, 向暴露的私有 DNS 服务器请求域名解析, 再将虚拟域名填入构造的请求<code>Headers</code>中, 才能开始扫描.</li></ol><pre class=mermaid>sequenceDiagram
  participant Scanner as 网络扫描者
  participant DNS as 私有DNS服务器
  participant Service as 内网服务

  Scanner-&gt;&gt;DNS: 1. 发现私有DNS服务器地址
  Scanner-&gt;&gt;DNS: 2. 请求解析虚拟域名
  DNS--&gt;&gt;Scanner: 3. 返回内网服务IP
  Scanner-&gt;&gt;Service: 4. 使用虚拟域名构造Headers
  Note right of Service: 如果Headers中没有正确的虚拟域名&lt;br/&gt;则拒绝访问
  alt Headers正确
    Service--&gt;&gt;Scanner: 5a. 返回服务响应
  else Headers错误
    Service--&gt;&gt;Scanner: 5b. 返回403错误
  end</pre><p>只有扫描者完成以上所有步骤，才可能扫描到内网服务，这大大增加了扫描的难度。</p><p>在<a href=https://www.adguardprivate.com>AdGuardPrivate</a>上可以创建私有 DNS 服务, 使用自定义解析功能添加伪造域名, 当然也可以用<a href=https://www.dnspod.cn>dnspod.cn</a>家的.</p><p>这两家提供服务差别较大, AdGuardPrivate 就是原生的 AdGuardHome 改来的, 功能上远多于 dnspod, 大家自行评估.</p><h2 id=总结>总结</h2><ol><li>内网 DNS 服务器不返回 AAAA 记录<ul><li>前置条件<ul><li>有公网 IPv6</li><li>有内网 DNS 服务器</li></ul></li><li>设置<ul><li>不返回 AAAA 记录</li></ul></li></ul></li><li>内网服务仅允许通过域名访问, 不允许直接通过 IP 访问<ul><li>前置条件<ul><li>有自己的域名</li><li>域名服务商提供 DDNS</li><li>内网有反向代理服务</li></ul></li><li>设置<ul><li>设置 DDNS 任务</li><li>仅允许通过域名访问</li></ul></li></ul></li><li>使用私有 DNS 服务<ul><li>前置条件<ul><li>有私有 DNS 服务</li><li>私有 DNS 服务提供自定义解析</li><li>私有 DNS 服务提供 DDNS</li></ul></li><li>设置<ul><li>设置 DDNS 任务</li><li>添加自定义解析, 伪造域名解析到内网服务</li></ul></li></ul></li></ol><p>最后,</p><ul><li>直连回家最简单最安全的就是内网穿透成功的 tailscale/zerotier, 但有时会因为各种网络原因穿透不成功.</li><li>不要随便连陌生 Wifi, 能一次性把信息给泄露完了. 搞张大流量卡, 暂且把信任交给运营商, 需要便宜大流量卡的联系我(不是), 我也需要.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5cb0c1e11404db39814ae13e98108704>使用常见DDns子域名可能导致电信宽带服务降级</h1><div class="td-byline mb-4"><time datetime=2025-02-19 class=text-body-secondary>Wednesday, February 19, 2025</time></div><p>IPv6 断连和打洞失败问题折腾了三个多月, 终于确认原因, 分享给大家.</p><h2 id=第一次发帖求助-ipv6-断连问题>第一次发帖求助 IPv6 断连问题</h2><p>IPv6 一直可以正常访问, 没有修改设置的情况下, 且设备均有独立 ipv6, 但连不通 ipv6 网络.</p><p><code>curl 6.ipw.cn</code> 拿不到返回, <code>ping6</code> 和 <code>traceroute6 2400:3200::1</code> 都中断.</p><p>光猫桥接路由, 可以拿到路由器的 ipv6 地址, 这是可以访问 ipv6 的地址.</p><p>可以拿到<code>/56</code> 前缀, 路由器下设备都可以拿到分配的 ipv6 地址 <code>240e:36f:15c3:3200::/56</code>, 但都无法连接到 ipv6 网站.</p><p>怀疑是运营商没有建好 <code>240e:36f:15c3:3200::</code>的路由, 但无法确认.</p><p>网友说可能是 PCDN 上传流量过大导致, 但上传流量很小, 也没有开启 PCDN.</p><p>也可能是使用了 Cloudflare 和 Aliyun ESA 反代导致.</p><h2 id=第二次发帖确认直接原因>第二次发帖确认直接原因</h2><p>确认部分地区的电信运营商会因为 IPv6 入站 http/https 链接较多而降级服务, 表现为:</p><ul><li>假 IPv6, ipv6 可以获得 <code>/56</code> 前缀, 各设备 IPv6 分配正常, 但 tracert 缺路由, 导致 ipv6 实际无法联网.</li><li>假穿墙, tailscale 测试连接显示是直连, 但延迟超高, 实际网速极慢.</li></ul><p>关闭 Cloudflare/Aliyun ESA 的反代, 经过多次重启路由后, 可以恢复 IPv6 和真直连.</p><h2 id=关闭反代后仍然断连>关闭反代后仍然断连</h2><p>即使关闭了反代, 关闭 Cloudflare 和 Aliyun ESA 回源, 也会偶发断链, 持续时间较长.</p><p>可能有域名泄露, 或被人使用常见子域名进行扫描, 长期 http 攻击.</p><p>禁用 DDns 域名的解析, 一段时间后, IPv6 恢复正常, tailscale 打洞直连也正常.</p><p>至此再没有发生断连问题.</p><h2 id=最终解决方案>最终解决方案</h2><p>在此建议大家不要使用常见的 DDns 子域名, 如:</p><ul><li>home.example.com</li><li>nas.example.com</li><li>router.example.com</li><li>ddns.example.com</li><li>cloud.example.com</li><li>dev.example.com</li><li>test.example.com</li><li>webdav.example.com</li></ul><p>这里边有几个就是我之前一直使用的, 可能被人一直在扫, 导致电信宽带服务降级, 公网 IPv6 不能正常使用, 总是无法打洞直连.</p><p>大家都知道在网络安全中, 隐藏 IP 的重要性, 这里额外建议保护自己用于 DDns 的域名, 它本质上也是在暴露 IP.</p><p>但仍然有暴露服务的需求怎么办?</p><p>这里有两个实践方案:</p><ul><li>回源方案, 是一种中转服务, 请求先到 VPS 再到 Home Server. 由于流量跳转绕路, 延迟和带宽都会受到一定影响.</li><li>DDns 方案, 是直连方案, 连接体验会好很多, 推荐这种方案. 个人用一般不会超连接数限制, 但如果公开域名, 铺天盖地的 bot 几下就会把连接数升上去.</li></ul><h3 id=回源方案反代>回源方案(反代)</h3><h4 id=cloudflare-tunnel>Cloudflare Tunnel</h4><p>使用 Cloudflare 的 Tunnel, 这样就不会像普通回源那样几十上百个 IP 来访问.</p><h4 id=tailscale-或-zerotier>Tailscale 或 ZeroTier</h4><p>自建 VPN, 前面套一个 VPS, 通过 VPN 来访问内网服务, 这样可以避免同时连接数过高.</p><h3 id=ddns-方案直连>DDns 方案(直连)</h3><h4 id=公网解析>公网解析</h4><p>生成随机字符串比如 GUID, 用于 DDns 域名, 虽然几乎无法记忆, 但个人实际使用时影响不大, 可以自行评估.</p><h4 id=私有解析>私有解析</h4><p>使用个人 Dns 服务, 如:</p><ul><li><a href=https://www.adguardprivate.com>AdguardPriavte</a></li><li><a href=https://dot.pub>dot.pub</a></li></ul><p>用于 DDns 解析.</p><p>这样只有能连接到个人 DNS 服务器的人才能获取指定域名的自定义解析 IP.</p><p>在这种方案下, 就可以使用常见的 DDns 域名, 但需要避免泄露自己的 DNS 服务地址.</p><h2 id=补充>补充</h2><p>坊间传闻, 使用<code>speedtest</code>做子域名有玄学加速作用.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cec8cf4eb40d88442b70c33f22fbdcc8>家庭网络反向代理的合规性探讨</h1><div class=lead>探讨家庭宽带使用反向代理服务时可能遇到的合规性问题及解决方案</div><div class="td-byline mb-4"><time datetime=2025-02-17 class=text-body-secondary>Monday, February 17, 2025</time></div><h1 id=背景>背景</h1><p>约 90 天前，我遇到了湖北电信 IPv6 无法连接的问题。经过长期观察和分析，现总结出以下经验。</p><h1 id=问题分析>问题分析</h1><p>最初怀疑的两个可能原因：</p><ol><li><p>PCDN 使用检测</p><ul><li>虽未主动使用 PCDN</li><li>仅有少量 BT 下载行为</li><li>已实施上传限速，但问题仍然存在</li></ul></li><li><p>家庭服务器作为博客源站</p><ul><li>通过 Cloudflare 回源规则指定端口</li><li>可能被运营商判定为"商用行为"</li></ul></li></ol><p>经过三个月的验证，问题更可能源于向公网开放 HTTP/HTTPS 服务端口。</p><h1 id=具体表现>具体表现</h1><ol><li><p>IPv6 状态异常：</p><ul><li>可获得 /56 前缀</li><li>设备能获取全局 IPv6 地址</li><li>但无法访问外网</li><li>仅光猫桥接的路由器可正常使用 IPv6</li></ul></li><li><p>Tailscale 连接异常：</p><ul><li>源站服务器显示直连但延迟异常（约 400ms）</li><li>其他设备经中继连接，反而延迟更低（约 80ms）</li></ul></li></ol><h1 id=运营商策略分析>运营商策略分析</h1><p>部分地区电信运营商对频繁入站 HTTP/HTTPS 连接采取服务降级措施：</p><ol><li><p>IPv6 服务降级</p><ul><li>分配地址正常</li><li>路由表缺失</li><li>实际无法联网</li></ul></li><li><p>P2P 连接限制</p><ul><li>Tailscale 显示直连</li><li>实际延迟高</li><li>带宽受限</li></ul></li></ol><h1 id=解决方案>解决方案</h1><ol><li><p>关闭反向代理服务：</p><ul><li>停用 Cloudflare/阿里云 ESA 反代</li><li>多次重启路由器后可恢复正常</li></ul></li><li><p>防范域名扫描：
避免使用以下常见子域名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>- home.example.com
</span></span><span class=line><span class=cl>- ddns.example.com
</span></span><span class=line><span class=cl>- dev.example.com
</span></span><span class=line><span class=cl>- test.example.com
</span></span></code></pre></div></li><li><p>最佳实践：</p><ul><li>使用 GUID 生成随机子域名</li><li>避免使用规律性或常见的子域名命名</li><li>定期更换域名以降低被扫描风险</li></ul></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-931e8eabbd265e7a3bb27d5aa98c3a49>电信IPv6的一些特征</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><p><input disabled type=checkbox> 电信IPv6的一些特征</p></li><li><p><input disabled type=checkbox> 电信 IPv6 的一些特征</p></li></ul><p>国内已经全面铺开 ipv6 使用, ipv6 地址池足够大, 个人的每个设备都可以获取到一个 ipv6 地址.<br>家庭用户使用时需要全栈设备都支持 ipv6 才能最终使用到 ipv6, 由于已经推了很多年, 目前来说 2016 年以后买的设备基本都支持 ipv6 了.</p><p>全栈设备包括: 城域设备->小区路由->家庭路由(光猫,路由器)->终端设备(手机,电脑,电视等)</p><p>这里不讨论标准的 ipv6 协议, 只讨论电信的 ipv6 的一些特征.</p><h2 id=地址分配>地址分配</h2><p>首先是地址分配方式, ipv6 有三种分配方式: 静态分配, SLAAC, DHCPv6.<br>湖北电信使用的是 SLAAC, 也就是说电信的 ipv6 地址是由设备自动分配的, 由于电信的 ipv6 地址池足够大, 所以不会出现地址冲突的问题.</p><p>电信 ipv6 地址是随机分配的, 24 小时后重新分配. 如果要从外部访问, 必须使用 DDNS 服务.</p><h2 id=防火墙>防火墙</h2><p>目前可以发现常见的<code>80</code>, <code>139</code>, <code>445</code>等端口已对齐 ipv4 防火前已经都封了, 这非常容易理解, 运营商级的防火墙确实能保护到缺乏网络安全意识的普通用户. 2020 年时电信 ipv6 都是开放的, 现在已经封了一些常用端口.</p><p><code>443</code>端口在电信网内偶尔开放, 但对移动联通不开放. 开发者应注意这一点. 在开发环境测试好的服务, 甚至电信网路手机也能访问, 但移动手机网络却访问不了.</p><p>基于简单的防火墙测试, 建议开发者牢记对运营商防火墙的不信任, 选择一个<strong>5 位数</strong>的端口提供服务.</p><p>另外, 电信防火墙没有屏蔽<code>22</code>端口, Windows 的远程桌面服务端口<code>3389</code>也没有屏蔽.<br>也就是可以远程登录控制, 这会导致一些风险.</p><p>攻击者获取到 IP 或者 DDNS 域名后, 就可以开始展开针对攻击, 利用暴力破解的方式获取到密码, 从而获取到控制权, 域名也会暴露一些个人信息, 例如姓名, 住址等, 也可能利用社会工程学的方式获取到更多信息以加快破解速度.</p><p>建议关闭 <code>ssh</code> 的密码登录, 仅使用密钥登录, 或者使用 VPN 的方式进行远程登录, 或者使用跳板机的方式进行远程登录.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d088abdb6aab928dad39e27339dd9e87>为什么不应该把TCP思维套在UDP上</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 为什么不应该把TCP思维套在UDP上</li></ul><h1 id=为什么不应该把-tcp-思维套在-udp-上>为什么不应该把 TCP 思维套在 UDP 上?</h1><h2 id=结构差异>结构差异</h2><p><img alt=TCP表头 src=https://s2.loli.net/2023/06/30/ndPGpzMRX1L4Q6D.png><br><img alt=UDP表头 src=https://s2.loli.net/2023/06/30/ofdBYKb6iqaICA9.png></p><p>TCP 上的概念很多: 建立通路, 资源使用, 数据传输, 可靠传输, 基于重复累计确认的重传, 超时重传, 校验和, 流量控制, 拥塞控制, 最大分段大小, 选择确认, TCP 窗口缩放选项, TCP 时间戳, 强制数据递交, 终结通路.</p><p>以上这些能力, UDP 基本上都没有, 它仅比链路层多一点区分应用层目的的能力. UDP 足够简单意味着足够灵活.</p><h2 id=如果可能发生则一定会发生>如果可能发生,则一定会发生</h2><p>墨菲定律:</p><blockquote><p>如果有多过一种方式去做某事，而其中一种方式将导致灾难，则必定有人会这样选择。</p></blockquote><p>通常介绍 UDP 适合应用在游戏/语音/视频等场景, 少量的错包不影响业务.
为什么 UDP 适合这些场景? 它能用在这些场景, 不代表它是这些场景的最优方案, 必然是存在 TCP 无法解决的问题, 才让这些服务选择了功能简陋的 UDP 协议. 错包不影响业务扩展开来讲是指 TCP 协议在乎错包, UDP 不在乎错包, 更在乎实时性/连续性. UDP 的特点就是它不在乎 TCP 在乎的因素, 这些因素影响了实时性.</p><p>在代码实现上, UDP 只需要创建一个 socket, 绑定到一个端口上, 即可以开始收发. 通常 socket 用完时, 端口也用完了.</p><p>因此我可以这样使用 UDP:</p><ol><li>往任意 IP 的任意端口发送随机报文, 看看哪个端口有响应</li><li>甲通过 A 端口, 将请求报文发送到乙的 B 端口; 乙将响应报文用 C 端口, 发给甲的 D 端口</li><li>甲通过 A 端口, 将请求报文发送到乙的 B 端口; 乙委托丙将响应报文用 C 端口, 发给甲的 D 端口</li><li>甲通过 A 端口, 将请求报文发送到乙的 B 端口, 但将发送报文的源 IP 修改为了丙的 IP, 乙将会将响应报文发往丙</li><li>双方协商各用 10 个 UDP 端口, 同时进行接受和发送</li></ol><p>这些方法在 TCP 里自然是行不通的, 但在 UDP 协议中, 只要可以这样做, 就一定会有人这样做. 所以当把 TCP 的一些思维套在 UDP 上是一种理想主义, 真实情况常常不是我们能枚举完的.</p><p>UDP 的报文非常简单, 使用也非常灵活, 原本没有连接的概念, 需要自己定义 UDP 连接. 尝试了一些定义方法, 都不能完全准确达到连接方向判断意图, 这时需要接纳一些容错, 毕竟原本就没有 UDP 连接的定义, 当各方对 UDP 连接的定义不一致时, 必然会导致行为与预期不一样.</p><h2 id=客户端视角的-udp>客户端视角的 UDP</h2><p>语音/视频等业务常会产生丢包, 但是丢包方式的不同对业务有着不同的影响. 比如 30%的丢包是均匀发生的, 还是全丢在某个时间段, 对体验的影响有明显的区分. 显然, 我们期待的是更均匀的丢包. 可是 UDP 没有流量控制防止方法, 如何丢包则有一些方法. 尽管 UDP 通信常被描述为"尽力而为", 但是不同方式的"尽力"会达到不同的效果.</p><h2 id=服务商视角的-udp>服务商视角的 UDP</h2><p>如果是 TCP 攻击, 客户端需要一定的开销, 创建连接, 维护连接, 也就是攻击者需要付出一定的代价. 而在 UDP 攻击中, 攻击者付出的代价小很多, 如果攻击者想消耗的就是服务方的带宽流量, UDP 是一个很好的方式. 比如说服务购买了 100GB 的不限速流量, 处理能力仅 10MB 每秒, 但接受速度 1GB 每秒, 那么 90%的请求流量无效, 但这些流量不是免费的. 服务方应该避免产生这种情况.</p><h2 id=运营商的视角的-udp>运营商的视角的 UDP</h2><p>完成一次通信需包含多个终端以及通信通道, 受关注的总是服务端和客户端, 其实运营商的视角同样重要. DDoS 攻击中, 我们常关心服务端的资源消耗情况, 实际上运营商的资源也是有限的, 服务端简单不响应请求, 但接收流量却已经消耗了带宽, 只是这个资源一般属于运营商. 我们在压力测试中常用到"丢包率"指标, 这个指标表达的完整通信链条中的丢包, 而不仅仅是服务端的丢包. 运营商也会丢包. 在运营商看, 服务方仅购买了 1MB/s 的带宽, 但客户端以 1GB/s 的速度发送, 双方都不必为浪费的流量付费, 是运营商承担了这部分带宽的代价. 因此, 运营商必然想办法屏蔽这种流量, 也就是 UDP 的 QoS. 在 TCP 中有拥塞控制, 但在 UDP 中, 运营商可以通过丢包来控制流量. 实际情况中, 运营商更加简单粗暴, 直接屏蔽长时间使用的端口的流量, 也就是 UDP 的端口屏蔽. 在微信通话的实际测试中发现, 每一通电话客户端会使用多个端口, 其中有一个 UDP 端口会和同一服务器的 6 个 UDP 端口进行通信, 推测就是为了应对运营商的端口屏蔽.</p><h2 id=总结>总结</h2><p>UDP 的灵活表示在实现一个目标时, 它有着多种实现方式, 并且都是合法的, 只要能最终实现稳定的通信, 不管它实现的如何和 TCP 大相径庭, 都是"存在即合理"的. 因而, 我们不能完全将 TCP 的概念套用在 UDP 上, 即便为了产品设计, 创造了新的 UDP 连接定义, 也应该能预期并允许出错, 毕竟"允许出错"就是 UDP 的核心功能, 这是 UDP 的优势, 不是它的缺点, 是服务主动选择的协议核心能力, 而不是不得不接受的缺点.</p><h2 id=更多阅读>更多阅读</h2><ul><li><a href=https://cloud.tencent.com/developer/article/1708535>2 万字带你学习 Qos 原理</a></li><li><a href=https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE>传输控制协议</a></li><li><a href=https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE>用户数据报协议</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fe14363a9954cb1fb6a2e4a51ef7d5a1>linux网络问题定位</h1><div class="td-byline mb-4"><time datetime=2024-05-28 class=text-body-secondary>Tuesday, May 28, 2024</time></div><h2 id=排障工具>排障工具</h2><table><thead><tr><th>工具</th><th>说明</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>ping</td><td>测试网络连通性</td><td>ping baidu.com</td><td></td></tr><tr><td>traceroute</td><td>路由跟踪</td><td>traceroute ip</td><td></td></tr><tr><td>route</td><td>路由表</td><td>route -n</td><td></td></tr><tr><td>netstat</td><td>网络连接</td><td>netstat -ano</td><td></td></tr><tr><td>nslookup</td><td>DNS 解析</td><td>nslookup baidu.com</td><td></td></tr><tr><td>ifconfig</td><td>网络配置</td><td>ifconfig</td><td></td></tr><tr><td>arp</td><td>ARP 缓存</td><td>arp -a</td><td></td></tr><tr><td>nbtstat</td><td>NetBIOS</td><td>nbtstat -n</td><td></td></tr><tr><td>netsh</td><td>网络配置</td><td>netsh</td><td></td></tr><tr><td>net</td><td>网络配置</td><td>net</td><td></td></tr><tr><td>tcpdump</td><td>网络抓包</td><td>tcpdump</td><td></td></tr><tr><td>wireshark</td><td>网络抓包</td><td>wireshark</td><td></td></tr><tr><td>ip</td><td>网络配置</td><td>ip addr show</td><td></td></tr><tr><td>ss</td><td>网络连接</td><td>ss -tunlp</td><td></td></tr><tr><td>netstat</td><td>查看网络连接状态</td><td>netstat -anp</td><td></td></tr><tr><td>tcpdump</td><td>抓包工具</td><td>tcpdump -i eth0 -nn -s 0 -c 1000 -w /tmp/tcpdump.pcap</td><td></td></tr><tr><td>iptables</td><td>防火墙</td><td>iptables -L -n -v -t nat -t mangle -t filter</td><td></td></tr><tr><td>ss</td><td>netstat 的替代品</td><td>ss -anp</td><td></td></tr><tr><td>ifconfig</td><td>查看网卡信息</td><td>ifconfig eth0</td><td></td></tr><tr><td>ip</td><td>查看网卡信息</td><td>ip addr show eth0</td><td></td></tr><tr><td>route</td><td>查看路由表</td><td>route -n</td><td></td></tr><tr><td>traceroute</td><td>查看路由跳数</td><td>traceroute <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>ping</td><td>测试网络连通性</td><td>ping <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>telnet</td><td>测试端口连通性</td><td>telnet <a href=https://www.baidu.com>www.baidu.com</a> 80</td><td></td></tr><tr><td>nslookup</td><td>域名解析</td><td>nslookup <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>dig</td><td>域名解析</td><td>dig <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>arp</td><td>查看 arp 缓存</td><td>arp -a</td><td></td></tr><tr><td>netcat</td><td>网络调试工具</td><td>nc -l 1234</td><td></td></tr><tr><td>nmap</td><td>端口扫描工具</td><td>nmap -sT -p 80 <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>mtr</td><td>网络连通性测试工具</td><td>mtr <a href=https://www.baidu.com>www.baidu.com</a></td><td></td></tr><tr><td>iperf</td><td>网络性能测试工具</td><td>iperf -s -p 1234</td><td></td></tr><tr><td>iptraf</td><td>网络流量监控工具</td><td>iptraf -i eth0</td><td></td></tr><tr><td>ipcalc</td><td>IP 地址计算工具</td><td>ipcalc</td><td></td></tr><tr><td>iftop</td><td>网络流量监控工具</td><td>iftop -i eth0</td><td></td></tr><tr><td>iostat</td><td>磁盘 IO 监控工具</td><td>iostat -x 1 10</td><td></td></tr><tr><td>vmstat</td><td>虚拟内存监控工具</td><td>vmstat 1 10</td><td></td></tr><tr><td>sar</td><td>系统性能监控工具</td><td>sar -n DEV 1 10</td><td></td></tr><tr><td>lsof</td><td>查看文件打开情况</td><td>lsof -i:80</td><td></td></tr><tr><td>strace</td><td>跟踪系统调用</td><td>strace -p 1234</td><td></td></tr><tr><td>tcpflow</td><td>抓包工具</td><td>tcpflow -i eth0 -c -C -p -o /tmp/tcpflow</td><td></td></tr><tr><td>tcpick</td><td>抓包工具</td><td>tcpick -i eth0 -C -p -o /tmp/tcpick</td><td></td></tr><tr><td>tcptrace</td><td>抓包工具</td><td>tcptrace -i eth0 -C -p -o /tmp/tcptrace</td><td></td></tr><tr><td>tcpslice</td><td>抓包工具</td><td>tcpslice -i eth0 -C -p -o /tmp/tcpslice</td><td></td></tr><tr><td>tcpstat</td><td>抓包工具</td><td>tcpstat -i eth0 -C -p -o /tmp/tcpstat</td><td></td></tr><tr><td>tcpdump</td><td>抓包工具</td><td>tcpdump -i eth0 -C -p -o /tmp/tcpdump</td><td></td></tr><tr><td>tshark</td><td>抓包工具</td><td>tshark -i eth0 -C -p -o /tmp/tshark</td><td></td></tr><tr><td>wireshark</td><td>抓包工具</td><td>wireshark -i eth0 -C -p -o /tmp/wireshark</td><td></td></tr><tr><td>socat</td><td>网络调试工具</td><td>socat -d -d TCP-LISTEN:1234,fork TCP:www.baidu.com:80</td><td></td></tr><tr><td>ncat</td><td>网络调试工具</td><td>ncat -l 1234 -c &rsquo;ncat <a href=https://www.baidu.com>www.baidu.com</a> 80'</td><td></td></tr><tr><td>netperf</td><td>网络性能测试工具</td><td>netperf -H <a href=https://www.baidu.com>www.baidu.com</a> -l 60 -t TCP_STREAM</td><td></td></tr><tr><td>netcat</td><td>网络调试工具</td><td>netcat -l 1234</td><td></td></tr><tr><td>nc</td><td>网络调试工具</td><td>nc -l 1234</td><td></td></tr><tr><td>netpipe</td><td>网络性能测试工具</td><td>netpipe -l 1234</td><td></td></tr><tr><td>netkit</td><td>网络调试工具</td><td>netkit -l 1234</td><td></td></tr><tr><td>bridge</td><td>网桥工具</td><td>bridge -s</td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-953696aca9e6689f10d238a6951f475a>如何提升自建DNS服务下的网络体验</h1><div class="td-byline mb-4"><time datetime=2024-05-18 class=text-body-secondary>Saturday, May 18, 2024</time></div><h2 id=网络质量和网络体验>网络质量和网络体验</h2><blockquote><p>什么都不做, 即可以获得最好的网络体验</p></blockquote><p>需要明确, 这里<code>网络质量</code>和<code>网络体验</code>是两个不同的概念. 通信是一个过程, 涉及多个设备, 我们可以称单个设备的上下行表现为<code>网络质量</code>, 而整个端到端的通信表现, 我们可以称为<code>网络体验</code>.</p><h2 id=如何衡量网络质量>如何衡量网络质量</h2><p>衡量网络质量通常涉及多个指标和方法。以下是一些常见的衡量网络质量的方法和指标：</p><ol><li><strong>带宽（Bandwidth）</strong>：带宽是指网络传输数据的能力，通常以每秒传输的数据量（比特/秒）来衡量。更高的带宽通常表示更好的网络质量。</li><li><strong>延迟（Latency）</strong>：延迟是指数据从发送端到接收端所需的时间。低延迟表示数据传输速度快，网络响应更快。</li><li><strong>丢包率（Packet Loss Rate）</strong>：丢包率是指在数据传输过程中丢失的数据包的比例。较低的丢包率通常意味着网络质量较好。</li><li><strong>抖动（Jitter）</strong>：抖动是指数据包在传输过程中的变化或波动。较小的抖动表示网络稳定性较高。</li><li><strong>吞吐量（Throughput）</strong>：吞吐量是指网络传输的实际数据量，通常以单位时间内的数据传输量来衡量。更高的吞吐量表示网络质量更好。</li><li><strong>网络拓扑（Network Topology）</strong>：网络拓扑描述了网络中节点之间的连接方式和结构。合理的网络拓扑设计可以提高网络性能和质量。</li><li><strong>服务质量（Quality of Service，QoS）</strong>：QoS 是一组技术和机制，用于确保在网络中的数据传输中实现可接受的服务质量。QoS 可以通过各种方式实现，包括流量控制、优先级队列等。</li><li><strong>网络协议分析（Protocol Analysis）</strong>：通过分析网络协议和数据包，可以了解网络中的性能指标和问题，例如使用 Wireshark 等网络分析工具。</li></ol><p>综合利用这些指标和方法，可以全面地评估网络质量，确定网络性能的优势和改进的空间。 但这些是运营商关注的指标, 对于普通用户, 只需要购买价格合适的路由器即可, 现代路由器都有自动调整网络质量的功能.</p><h2 id=如何衡量网络体验>如何衡量网络体验</h2><p>首先是<strong>可访问性</strong>, 能访问是最重要的基础. 因此, 域名解析服务需要满足基础的能力:</p><ul><li>全面, 上级 DNS 服务需要权威, 且能够解析更多的域名</li><li>正确, 解析结果需要正确, 不能出现解析错误. 部分 DNS 服务商会对一些域名进行劫持或污染, 解析到广告页面.</li><li>及时, ip 地址变更后, 需要及时更新解析结果, 而不是返回旧的 ip 地址</li></ul><p>其次是 DNS 解析结果的 IP 所能提供服务的<code>网络质量</code>.</p><p>互联网服务所能提供的<code>网络质量</code>, 通常<strong>强依赖地域</strong>, 服务器和客户端在地域上越接近, 则服务质量越好.</p><p>许多付费 DNS 解析服务商都支持按地域解析不同 IP, 例如这是阿里云能提供的一部分服务:</p><blockquote><p>（1）运营商线路：支持按联通、电信、移动、教育网、鹏博士、广电网智能解析，细分到省份；<br>（2）海外地区线路：支持，细分到大洲、国家；<br>（3）阿里云线路：支持，细分到各个地区；<br>（4）自定义线路：支持自定义 IP 地址范围智能解析；</p></blockquote><p><img src=https://s2.loli.net/2024/06/20/WRfDMcdJiKHqAzG.png></p><p>按区域解析不同 IP 的机制, 意味着不同地域的用户访问同一个域名时, 会得到不同的解析结果, 自然而然的, 优先解析到距离用户更近的服务器, 将会有更好的网络体验.</p><p>而优化用户网络体验这件事, 一般都是服务提供商根据用户的真实 IP 地址来做优化. 也就是对多数用户来说, <code>什么都不做, 即可以获得最好的网络体验</code>.</p><h2 id=自建-dns-服务如何选择上游-dns-服务>自建 DNS 服务如何选择上游 DNS 服务</h2><p>中文互联网你搜索到的所有资料都会推荐你选择权威 DNS 服务商, 例如阿里云, 腾讯云, Cloudflare, 谷歌等. 这些 DNS 可以满足网络服务的的<code>可访问性</code>, 因为它们全面/正确/及时, 但是, 它们未必会给你解析到最近的服务器 IP.</p><p>互联网上大量的资料推荐大企业的 DNS 服务有其历史原因.</p><p>曾经我国的 ISP 运营商, 仅靠 DNS 劫持加上 HTTP 的中间人攻击, 就能够实现对用户的流量劫持, 从而实现广告推送. 现如今随着 https 的普及, 这种劫持方式已较为少见, 但部分地区的小区宽带仍然可能存在这种问题. 针对 DNS 劫持问题, 实际上改 DNS IP 无济于事, 因为劫持可以针对 53 端口, 而绝大多数 DNS 请求都是未加密的.</p><p>此外, 一些特殊用户希望访问特殊网站, 而部分 DNS 服务商存在 IP 污染问题, 会将特殊网站的域名解析到错误的 IP 地址, 导致无法访问. 而权威 DNS 服务商则较少出现这样问题.</p><p>因此, 这里存在三个问题需要考虑:</p><ol><li>IP 污染</li><li>DNS 劫持</li><li>最优服务体验</li></ol><p>权威 DNS 服务商可以解决问题 1 , 加密协议(DoT/DoH/QUIC)可以解决问题 2.</p><p><strong>想要解决问题 3, 你需要使用回宽带运营商的默认 DNS 服务.</strong>, 正如本文开头所说, <code>什么都不做, 即可以获得最好的网络体验</code>.</p><p>但如果你是一个有追求的人, 或者特殊用户, 下文将介绍如何配置 <code>AdguardHome</code> 及 <code>Clash</code> 两种工具的配置, 以同时解决这三个问题.</p><h2 id=权威且智能的-dns-服务>权威且智能的 DNS 服务</h2><h3 id=adguardhome-配置>AdguardHome 配置</h3><p><a href=https://github.com/AdguardTeam/AdGuardHome>AdguardHome</a>, 以下简称<code>ADG</code> 是一个网络广告拦截与隐私保护软件, 也是一个 DNS 服务. 它支持自定义上游 DNS 服务, 以及自定义 DNS 规则.</p><p><code>ADG</code> 默认的向上游请求 DNS 的方式是<code>负载均衡</code>, 用户可以设置多个上游, <code>ADG</code>将根据历史 DNS 查询加权权重选择其中 DNS 响应最快的上游. 简单说, <code>ADG</code> 会以更高的概率选择更快的 DNS 上游来解析域名, 以较低的概率选择非最优的 DNS 上游.</p><p>我们可以选择第三个选项: <code>最快的IP地址</code>.</p><p><img src=https://s2.loli.net/2024/06/20/oyFdIMDXratRb4q.png></p><p>该选项带来的好处, <code>ADG</code>自行测试上游 DNS 的 IP 解析结果, 将其中延迟最低的 IP 返回给下游客户端. 以下是<strong>bilibili</strong>的常规解析结果.</p><p><img src=https://s2.loli.net/2024/06/20/6ulLerFTCNbhIgo.png></p><p>你可以看到 IP 非常多, 如果<code>ADG</code>不测试 IP 解析结果, 而将所有 IP 返回给客户端, 那么客户端会做什么?</p><p>有的客户端会选择第一个 IP, 有的客户端会选择最后一个 IP, 有的客户端会随机选择一个 IP. 不管是哪种, 都未必是最优的选择.</p><p>开启<code>最快的IP地址</code>选项后, 以下是<strong>bilibili</strong>的优选解析结果, <strong>这一步将会带来<code>网络体验</code>的提升</strong>.</p><p><img src=https://s2.loli.net/2024/06/20/EsG7ekxqLX8fwHA.png></p><p><strong><code>最快的IP地址</code>为什么不是默认选择? 这个功能这么实用, 为什么不默认开启?</strong></p><p>因为它的代价是<em>等待所有上游 DNS 的 IP 解析结果</em>, 当你的上游同时有多个 DNS 服务商时, 向上游的查询时间以其中最慢的为准. 例如, 你的上游有平均服务时长<code>50ms</code>的阿里和平均服务时长<code>500ms</code>谷歌, <code>ADG</code>的上游查询时间将是<code>500ms+</code>.</p><p>因此用户在配置此选项时, 需要权衡上游 DNS 的服务质量和数量, 不要贪多.<br>这里我推荐设置两个上游, <strong>一个权威(<a href=https://dns.alidns.com/dns-query>https://dns.alidns.com/dns-query</a>)</strong>, 加上<strong>一个运营商 DNS</strong>.</p><p>运营商的 DNS IP 各地都不相同, 可以点击<a href=https://ipw.cn/doc/else/dns.html>这里</a>查看自己所在地区的运营商 DNS.</p><p>或者, 你可以在路由器的管理界面上查看运营商推荐的 DNS :</p><p><img src=https://s2.loli.net/2024/06/20/kpmK1nlWyxj4Uiv.png></p><h3 id=clash-配置>Clash 配置</h3><p>特殊需求用户看重 DNS 劫持和 IP 污染问题, 但又不想放弃最优服务体验, 可以使用<code>Clash</code>的<code>dns</code>模块.</p><p>其中<code>nameserver-policy</code>可以指定不同的域名使用不同的 DNS 服务商, 以下是一个示例配置:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>dns</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>default-nameserver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>tls://223.5.5.5:853</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>tls://1.12.12.12:853</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nameserver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>https://dns.alidns.com/dns-query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>https://one.one.one.one/dns-query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>https://dns.google/dns-query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nameserver-policy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;geosite:cn,private,apple&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>202.103.24.68</span><span class=w> </span><span class=c># 自己所在地的运营商 DNS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>https://dns.alidns.com/dns-query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;geosite:geolocation-!cn&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>https://one.one.one.one/dns-query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>https://dns.google/dns-query</span><span class=w>
</span></span></span></code></pre></div><p>它的含义是:</p><ul><li>default-nameserver: 用于解析配置<code>nameserver</code>中的 DNS 服务的 IP</li><li>nameserver: 用于解析网络请求的域名</li><li>nameserver-policy: 根据策略, 指定不同的域名使用不同的 DNS 服务</li></ul><h2 id=感谢阅读>感谢阅读</h2><p>如果本文对您有所帮助, 还请点个赞. 也非常欢迎留言讨论.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b0ccb01b3aa156438a93cad783d70d49>ChatGPT VPN识别绕过方法</h1><div class="td-byline mb-4"><time datetime=2024-05-09 class=text-body-secondary>Thursday, May 09, 2024</time></div><p>如何处理 ChatGPT 报错<br>&ldquo;Unable to load site&rdquo;<br>&ldquo;Please try again later, if you are using a VPN, try turning it off.&rdquo;<br>&ldquo;Check the status page for information on outages.&rdquo;</p><h2 id=前言>前言</h2><p><img src=https://s2.loli.net/2024/05/09/dT4xi1mwFgYRKhq.png></p><p>chatgpt 目前仍然是使用体验最好的聊天机器人，但是在国内使用时，由于网络环境的限制，我们需要使用梯子来访问 chatgpt。但是 chatgpt 对梯子的检测较为严格，如果检测到使用了梯子，会直接拒绝访问。这里介绍一种绕过 chatgpt 对梯子检测的方法。</p><p>有其他人提到更换 IP 来绕过封锁, 但我们一般使用 IP 的地域已经是可以提供服务的地区, 所以这种方法并不一定是实际的拒绝服务原因.</p><p>另外有人提到梯子使用人数较多容易被识别, 劝人购买较贵的使用人数少的梯子, 这也很难成为合理理由, 在 ipv4 短缺的今天, 即便是海外, 也存在大量的社区使用 nat 分配端口, 共用一个 ipv4 的情况. chatgpt 一封就要封一大片, 作为一个被广泛使用的服务, 这样的检测设计肯定是不合理的.</p><p>对大众服务来说, 检测源 IP 一致性则更为合理. 付费梯子的特征通常是限制流量或限制网速, 因此多数使用梯子的用户选择按规则绕过. 绕过自己的运营商可直接访问的地址, 以减少流量消耗, 或者获得更快的访问速度, 仅在访问被防火墙拦截的地址时导入流量到代理. 这种访问目标服务的不同方式, 可能会造成源地址不一致. 例如访问 A 服务需要同时和域名 X 和域名 Y 进行通信, 而防火墙仅拦截了域名 X, 那么在 A 服务看到的同一请求的不同阶段的访问来源 IP 不一致.</p><p><strong>解决代理策略导致的源 IP 不一致问题, 即可绕过 chatgpt 的梯子识别.</strong></p><p>梯子规则中通常会含有<code>域名规则</code>, <code>IP规则</code>等.</p><p>我们还需要知道<code>域名解析</code>的 IP 结果是可以根据地域而变化的, 比如我在 A 地区时解析到附近的服务 IP, 在 B 地区时则解析到不同的 IP. 因此, DNS 的选择也非常重要.</p><h2 id=dns-选择>DNS 选择</h2><p>现在 DNS 有很多的协议, <code>UDP:53</code> 已经是非常落后而且极不安全的协议, 我国甚至已将 DNS 服务列入企业经营中的一级条目. 这主要来源于过去几十年我国的各级运行商使用<code>DNS劫持</code>加<code>HTTP</code>塞入了大量的跳转广告, 蒙骗不少网络小白, 招致大量投诉. 尽管现在<code>Chrome/Edge</code>已经标配自动跳转<code>HTTPS</code>, 标记<code>HTTP</code>网站为不安全, 但我国还存在许多的地方小区级的网络服务提供商, 以及国内各种老版本的<code>Chromium</code>封装魔改, 导致 DNS 劫持和 HTTP 劫持仍然存在.</p><p>因此, 我们需要选择一个安全的 DNS 服务协议, 以避免 DNS 劫持. 根据个人经验, 阿里云的<code>223.5.5.5</code>体验足够好. 当然, 当我提<code>223.5.5.5</code>时, 肯定不是<code>UDP:53</code>的 alidns, 而是<code>DoH</code>或<code>DoT</code>协议. 在配置时, 你需要使用<code>tls://223.5.5.5</code>, 或者<code>https://dns.alidns.com/dns-query</code>写入配置.</p><p>alidns 服务在绝大多数时候都不会污染, 仅在少数敏感时期会出现污染, 你也可以使用我自建的长期 dns 服务<code>tls://dns.jqknono.com</code>, 上游来自<code>8.8.8.8</code>和<code>1.1.1.1</code>, 通过缓存来加速访问.</p><h2 id=域名规则>域名规则</h2><p>首先打开的检测网页会包含检测逻辑, 通过向不同<em>域名</em>发送请求来验证源 IP, 因此这里需要保持域名代理的一致性.</p><p>chatgpt 网页访问的域名除了自己的域名<code>openai</code>外, 还有<code>auth0</code>, <code>cloudflare</code>等第三方域名.</p><p>可以手动写入以下规则:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># openai</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,chatgpt.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,openai.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,openai.org,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,auth0.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,cloudflare.com,PROXY</span><span class=w>
</span></span></span></code></pre></div><h3 id=如何试验域名规则>如何试验域名规则</h3><p>上边列举的域名可能随着 ChatGPT 业务发展而有所变化, 下面说明域名的获取方法.</p><ol><li>浏览器打开 InPrivate 页面, 隐私页面可以避免缓存/cookies 等的影响</li><li>按<code>F12</code>打开控制台, 选择<code>Network</code>/<code>网络</code>选项卡</li><li>访问<code>chat.openai.com</code>, 或者<code>chatgpt.com</code></li><li>下图展示了这篇文章写成时 ChatGPT 使用的域名</li></ol><p><img alt=ChatGPT使用的域名 src=https://s2.loli.net/2024/05/09/SOtMedp8KrGyfzi.png></p><p>仅添加这几个域名可能仍然不够, 这里分析访问失败的连接具体细节. 看到<strong>challenge</strong>的请求的<strong>Content-Security-Policy</strong>中含有众多域名, 我们将其一一添加到代理策略.</p><p><img alt=Content-Security-Policy中的域名 src=https://s2.loli.net/2024/05/09/aYseB9Df3xQqWRz.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># openai</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,chatgpt.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,openai.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,openai.org,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,auth0.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,cloudflare.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># additional</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,oaistatic.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,oaiusercontent.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,intercomcdn.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,intercom.io,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,mixpanel.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,statsigapi.net,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,featuregates.org,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,stripe.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,browser-intake-datadoghq.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,sentry.io,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,live.net,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,live.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,windows.net,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,onedrive.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,microsoft.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,azure.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,sharepoint.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,gstatic.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,google.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,googleapis.com,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>DOMAIN-SUFFIX,googleusercontent.com,PROXY</span><span class=w>
</span></span></span></code></pre></div><h2 id=ip-规则>IP 规则</h2><p>如果上述步骤尝试后仍然不能访问<em>chatgpt.com</em>, 则可能还存在基于<em>IP</em>的检测行为, 以下是我在连接跟踪中尝试出的一些 IP, 你可以自行尝试使用, 需要说明这些 IP 并不一定适用于每个地区, 你或许需要自行尝试.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># openai</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>IP-CIDR6,2606:4700:4400::6812:231c/96,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>IP-CIDR,17.253.84.253/24,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>IP-CIDR,172.64.152.228/24,PROXY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=l>IP-CIDR,104.18.35.28/16,PROXY</span><span class=w>
</span></span></span></code></pre></div><h3 id=如何试验-ip-规则>如何试验 IP 规则</h3><p>你需要了解自己的梯子客户端工具, 在连接跟踪显示页面, 观察新增的连接, 通过这些连接的 IP 地址来尝试添加规则.</p><p>以下是简单的步骤描述:</p><ol><li>浏览器打开 InPrivate 页面, 隐私页面可以避免缓存/cookies 等的影响</li><li>访问<code>chat.openai.com</code>, 或者<code>chatgpt.com</code></li><li>梯子客户端中观察新增连接, 将这些连接加入到代理规则</li></ol><h2 id=协议规则>协议规则</h2><p><code>QUIC</code>是基于<code>UDP</code>的加密协议, chatgpt 大量使用了 <em>QUIC</em> 流量, 因此梯子的服务端/客户端需要支持 UDP 代理, 有许多梯子是不支持 UDP 的, 这也是导致 chatgpt 无法访问的原因之一. 客户端和服务端都支持 UDP, 还需要用户明确配置, 一些客户端会配置默认不代理 UDP 流量. 如果对 UDP 设置不熟悉, 可以设置屏蔽代理客户端的 QUIC 流量, 或者在浏览器设置屏蔽 QUIC. 浏览器发现 QUIC 不通会自动切换到基于 <em>TCP</em> 的 HTTP/2. QUIC 是基于 UDP 的加密协议, 多数时候可以获得更流畅的体验, 有兴趣的可以自行尝试.</p><p><img src=https://s2.loli.net/2024/05/09/UAzbdgQT1y5J63w.png></p><h2 id=最简单配置--白名单模式>最简单配置&ndash;白名单模式</h2><p>配置仅中国 IP 直连, 未匹配到的流量走代理, 这样可以保证 chatgpt 的访问, 也可以保证其他国外服务的访问.</p><p>这种方式的缺点就是流量消耗大, 网络流畅度体验依赖梯子的网络质量, 如果您对自己的梯子有信心, 可以尝试这种方式.</p><p>当然, 您还得记得开启<code>UDP</code>代理.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-27c0946c3b62da5f9bdf5d716e89b1ee>杂谈</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> _index</li></ul></div><div class=td-content><h1 id=pg-e5352cfd6ed96421590af4134771f495>第三方库的陷阱</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 第三方库的陷阱</li></ul><p>今天聊到最近出的第三方日志库的一个漏洞, 可以很低门槛的利用以执行远程命令. 一个日志库和远程命令看着毫不相干, 但是画蛇添足的第三方库遍地都是.</p><p>读的代码越多越感受到很多开源代码的水平非常差, 无论它有多少 k 的 star, star 代表了需求, 不代表开发水平.</p><p>开源的好处是有更多的人来开发, 好处是特性迅速增加, bug 有人来解, 代码有人来审核, 但是水平参差不齐.</p><p>如果没有一个强有力的提交约束, 代码的质量很难保证.</p><p>代码越多增加的攻击面越多</p><p>虽说重复造轮子不好, 但是产品需求就是婴儿车轮子, 一个塑料轮子怎么都用不坏, 装了个飞机轮胎, 徒增攻击面和维护成本. 因此如果只需要婴儿车的轮子, 不需要大材小用.</p><p>维护成本高, 第三方库需要专门的流程和人员去维护. 华为一个魔改的测试框架, 直接导致升级编译器就用例失败, 升级测试框架和升级编译器产生冲突, 维护时要花大量时间继续魔改这条路. 作为参与者深刻体会到魔改三方库的困难. 如果魔改的是特性可以合回开源库还好说, 为了自己的需求去侵入式的定制开发, 会导致很难维护.</p><p>对待第三方库华为创建了一系列流程, 可以说阻力重重.</p><p>门槛收的极紧, 增加的第三方库需要 18 级专家和 20 级部长评审, 基本只有久负盛名的三方库能被使用.</p><p>所有第三方库都放在 thirdparty 文件夹下, 全量编译时 CI 和源库对比, 严格禁止侵入式修改.</p><p>专门的工具追踪所有第三方库的版本, 这部分请了外包人员来管理, 如果开发申请升级版本需要提申请, 部长审核.</p><p>很难找部长去处理这样的事, 当一个流程非常繁琐的时候, 它实际上是在劝你不要这样做.</p><p>对待第三方库应该保持不轻信的态度, 相信自己人的开发.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f222a10259ecfac0268b18dba6ac986d>方案设计模板</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 方案设计模板</li></ul><h1 id=xxx系统子系统详细设计>XXX系统/子系统详细设计</h1><table><thead><tr><th>系统名称</th><th>XXX系统</th></tr></thead><tbody><tr><td>作者</td><td>XXX</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>提交日期</td><td>2021-6-30</td></tr></tbody></table><h2 id=修改记录>修改记录</h2><table><thead><tr><th>修改后版本号</th><th>修改内容</th><th>修改日期</th><th>修改人</th></tr></thead><tbody><tr><td>v1.0</td><td>XXXXXXX</td><td>2021-6-30</td><td>XXX</td></tr><tr><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr></tbody></table><h2 id=技术评审意见>技术评审意见</h2><table><thead><tr><th>No.</th><th>评审人</th><th>评审意见（通过/不通过/待定，可附上评论）</th><th>评审时间</th></tr></thead><tbody><tr><td>1</td><td>XXX</td><td>通过</td><td>2022.1.1</td></tr></tbody></table><h2 id=设计背景>设计背景</h2><h2 id=名词解释>名词解释</h2><ul><li>SIP: 会话初始协议 (Session Initiation Protocol)</li><li>RTP: 实时传输协议（Real-time Transpo<em>rt P</em>rotocol）</li></ul><h2 id=设计目标>设计目标</h2><h3 id=功能需求>功能需求</h3><h3 id=非功能需求不可省略>非功能需求（不可省略）</h3><h2 id=系统环境>系统环境</h2><h3 id=相关软件及硬件可选>相关软件及硬件（可选）</h3><h3 id=系统限制>系统限制</h3><h3 id=数据规模估计不可省略>数据规模估计（不可省略）</h3><h2 id=遍历已有>遍历已有</h2><h2 id=设计思路及折衷>设计思路及折衷</h2><h3 id=假设及与其它系统的依赖联系>假设及与其它系统的依赖/联系</h3><h2 id=系统设计>系统设计</h2><h3 id=基本介绍>基本介绍</h3><h3 id=系统架构图及说明>系统架构图及说明</h3><h3 id=系统流程图及说明可选>系统流程图及说明（可选）</h3><h3 id=与外部系统的接口>与外部系统的接口</h3><h3 id=全局性数据结构说明>全局性数据结构说明</h3><h3 id=xxx1模块简要说明>XXX1模块简要说明</h3><h4 id=xxx1模块的功能>XXX1模块的功能</h4><h4 id=与其它模块的接口>与其它模块的接口</h4><h3 id=xxx2模块简要说明>XXX2模块简要说明</h3><h4 id=xxx2模块的功能>XXX2模块的功能</h4><h4 id=与其它模块的接口-1>与其它模块的接口</h4><h2 id=威胁建模>威胁建模</h2><h2 id=升级影响不可省略>升级影响（不可省略）</h2><h2 id=风险评估及对其它系统影响可选>风险评估及对其它系统影响（可选）</h2><h3 id=已知的或可预知的风险>已知的或可预知的风险</h3><h3 id=与其它系统模块可能的影响>与其它系统/模块可能的影响</h3><h2 id=创新点挖掘可选>创新点挖掘（可选）</h2><h2 id=附件及参考资料>附件及参考资料</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-71c0f3c3e40e5c2307f21b32faf153e5>命令行语法约定</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 命令行语法约定</li></ul><h2 id=参考>参考</h2><ul><li><a href="https://www.ibm.com/docs/en/iotdm/11.3?topic=interface-command-line-syntax">https://www.ibm.com/docs/en/iotdm/11.3?topic=interface-command-line-syntax</a></li><li><a href=https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key>https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key</a></li><li><a href=https://developers.google.com/style/code-syntax>https://developers.google.com/style/code-syntax</a></li><li><a href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01>https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01</a></li><li><a href=https://ftpdocs.broadcom.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/cl_cmd_line_syntax_char.htm>https://ftpdocs.broadcom.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/cl_cmd_line_syntax_char.htm</a></li></ul><p>e.g.</p><table><thead><tr><th>Notation</th><th>Description</th></tr></thead><tbody><tr><td>Text without brackets or braces</td><td>Items you must type as shown.</td></tr><tr><td><code>&lt;</code>Text inside angle brackets<code>></code></td><td>Placeholder for which you must supply a value.</td></tr><tr><td><code>[</code>Text inside square brackets<code>]</code></td><td>Optional items.</td></tr><tr><td><code>{</code>Text inside braces<code>}</code></td><td>Set of required items. You must choose one.</td></tr><tr><td>Vertical bar ( <code>|</code> )</td><td>Separator for mutually exclusive items. You must choose one.</td></tr><tr><td>Ellipsis (<code>…</code>)</td><td>Items that can be repeated and used multiple times.</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e937233f5b1797cb39278fd277a8fe8a>命令行手册中括号的含义</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 命令行手册中括号的含义</li></ul><h1 id=命令行手册中括号的含义>命令行手册中括号的含义</h1><p>在命令行帮助中，不同种类的括号通常有以下含义：</p><ol><li>尖括号 <code>&lt;></code>：<ul><li>尖括号用于表示必需参数，即在运行命令时必须提供的值。通常用于表示命令的基本语法和参数。</li><li>例如：<code>command &lt;filename></code> 表示你需要提供一个文件名作为必需参数，如 <code>command file.txt</code>。</li></ul></li><li>方括号 <code>[]</code>：<ul><li>方括号用于表示可选参数，即在运行命令时可以选择是否提供的值。它们通常用于标记命令的可选参数和选项。</li><li>例如：<code>command [option]</code> 表示你可以选择性地提供一个选项，如 <code>command -v</code> 或 <code>command</code>。</li></ul></li><li>大括号 <code>{}</code>：<ul><li>大括号通常用于表示一组选项或值，表示你需要从中选择一个。它们也被称为"选择性参数组"。</li><li>例如：<code>command {option1 | option2 | option3}</code> 表示你必须从给定的选项中选择一个，如 <code>command option2</code>。</li></ul></li><li>圆括号 <code>()</code>：<ul><li>圆括号在命令行帮助中通常用于表示参数的分组，以明确参数的结构和优先级。</li><li>例如：<code>command (option1 | option2) filename</code> 表示你需要选择 <code>option1</code> 或 <code>option2</code>，并提供一个文件名作为参数，如 <code>command option1 file.txt</code>。</li></ul></li></ol><p>这些括号的使用旨在帮助用户理解命令的语法和参数选择，从而正确地使用命令行工具。在阅读命令行帮助时，仔细注意括号的含义和作用是很重要的，这样可以避免错误的命令输入并获得所需的结果。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3078f141cd9bdd78799762525d6ed14b>华为C++编程规范</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 华为C++编程规范</li></ul><h1 id=c语言编程规范>C++语言编程规范</h1><h2 id=a-namec0-1a目的><a name=c0-1></a>目的</h2><p>规则并不是完美的，通过禁止在特定情况下有用的特性，可能会对代码实现造成影响。但是我们制定规则的目的“为了大多数程序员可以得到更多的好处”， 如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。
参考该规范之前，希望您具有相应的C++语言基础能力，而不是通过该文档来学习C++语言。</p><ol><li>了解C++语言的ISO标准；</li><li>熟知C++语言的基本语言特性，包括C++ 03/11/14/17相关特性；</li><li>了解C++语言的标准库；</li></ol><h2 id=a-namec0-2a总体原则><a name=c0-2></a>总体原则</h2><p>代码需要在保证功能正确的前提下，满足<strong>可读、可维护、安全、可靠、可测试、高效、可移植</strong>的特征要求。</p><h2 id=a-namec0-2a-重点关注><a name=c0-2></a>重点关注</h2><ol><li>约定C++语言的编程风格，比如命名，排版等。</li><li>C++语言的模块化设计，如何设计头文件，类，接口和函数。</li><li>C++语言相关特性的优秀实践，比如常量，类型转换，资源管理，模板等。</li><li>现代C++语言的优秀实践，包括C++11/14/17中可以提高代码可维护性，提高代码可靠性的相关约定。</li><li>本规范优先适于用C++17版本。</li></ol><h2 id=a-namec0-3a-约定><a name=c0-3></a>约定</h2><p><strong>规则</strong>：编程时必须遵守的约定(must)</p><p><strong>建议</strong>：编程时应该遵守的约定(should)</p><p>本规范适用通用C++标准, 如果没有特定的标准版本，适用所有的版本(C++03/11/14/17)。</p><h2 id=a-namec0-4a-例外><a name=c0-4></a>例外</h2><p>无论是&rsquo;规则&rsquo;还是&rsquo;建议&rsquo;，都必须理解该条目这么规定的原因，并努力遵守。
但是，有些规则和建议可能会有例外。</p><p>在不违背总体原则，经过充分考虑，有充足的理由的前提下，可以适当违背规范中约定。
例外破坏了代码的一致性，请尽量避免。&lsquo;规则&rsquo;的例外应该是极少的。</p><p>下列情况，应风格一致性原则优先：
<strong>修改外部开源代码、第三方代码时，应该遵守开源代码、第三方代码已有规范，保持风格统一。</strong></p><h1 id=a-namec2a2-命名><a name=c2></a>2 命名</h1><h2 id=a-namec2-1a通用命名><a name=c2-1></a>通用命名</h2><p><strong>驼峰风格(CamelCase)</strong>
大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。
按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)</p><table><thead><tr><th>类型</th><th>命名风格</th></tr></thead><tbody><tr><td>类类型，结构体类型，枚举类型，联合体类型等类型定义， 作用域名称</td><td>大驼峰</td></tr><tr><td>函数(包括全局函数，作用域函数，成员函数)</td><td>大驼峰</td></tr><tr><td>全局变量(包括全局和命名空间域下的变量，类静态变量)，局部变量，函数参数，类、结构体和联合体中的成员变量</td><td>小驼峰</td></tr><tr><td>宏，常量(const)，枚举值，goto 标签</td><td>全大写，下划线分割</td></tr></tbody></table><p>注意：
上表中__常量__是指全局作用域、namespace域、类的静态成员域下，以 const或constexpr 修饰的基本数据类型、枚举、字符串类型的变量，不包括数组和其他类型变量。
上表中__变量__是指除常量定义以外的其他变量，均使用小驼峰风格。</p><h2 id=a-namec2-2a-文件命名><a name=c2-2></a>文件命名</h2><h3 id=a-namer2-2-1a规则221-c文件以cpp结尾头文件以h结尾><a name=r2-2-1></a>规则2.2.1 C++文件以.cpp结尾，头文件以.h结尾</h3><p>我们推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。
我们推荐使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。</p><p>目前业界还有一些其他的后缀的表示方法：</p><ul><li>头文件： .hh, .hpp, .hxx</li><li>cpp文件：.cc, .cxx, .c</li></ul><p>如果当前项目组使用了某种特定的后缀，那么可以继续使用，但是请保持风格统一。
但是对于本文档，我们默认使用.h和.cpp作为后缀。</p><h3 id=a-namer2-2-2a规则222-c文件名和类名保持一致><a name=r2-2-2></a>规则2.2.2 C++文件名和类名保持一致</h3><p>C++的头文件和cpp文件名和类名保持一致，使用下划线小写风格。</p><p>如果有一个类叫DatabaseConnection，那么对应的文件名：</p><ul><li>database_connection.h</li><li>database_connection.cpp</li></ul><p>结构体，命名空间，枚举等定义的文件名类似。</p><h2 id=a-namec2-3a--函数命名><a name=c2-3></a>函数命名</h2><p>函数命名统一使用大驼峰风格，一般采用动词或者动宾结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>AddElement</span><span class=p>(</span><span class=k>const</span> <span class=n>Element</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Element</span> <span class=nf>GetElement</span><span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteUser</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec2-4a-类型命名><a name=c2-4></a>类型命名</h2><p>类型命名采用大驼峰命名风格。
所有类型命名——类、结构体、联合体、类型定义（typedef）、枚举——使用相同约定，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// classes, structs and unions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>UrlTable</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UrlTableTester</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UrlTableProperties</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>Packet</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedefs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>UrlTableProperties</span><span class=o>*&gt;</span> <span class=n>PropertiesMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// enums
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>UrlTableErrors</span> <span class=p>{</span> <span class=p>...</span>
</span></span></code></pre></div><p>对于命名空间的命名，建议使用大驼峰：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// namespace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>OsUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FileUtils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namea2-4-1a建议241-避免滥用-typedef或者define-对基本类型起别名><a name=a2-4-1></a>建议2.4.1 避免滥用 typedef或者#define 对基本类型起别名</h3><p>除有明确的必要性，否则不要用 typedef/#define 对基本数据类型进行重定义。
优先使用<code>&lt;cstdint></code>头文件中的基本类型：</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有/无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有/无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有/无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有/无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有/无符号整数类型</td></tr></tbody></table><h2 id=a-namec2-5a-变量命名><a name=c2-5></a>变量命名</h2><p>通用变量命名采用小驼峰，包括全局变量，函数形参，局部变量，成员变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tableName</span><span class=p>;</span>  <span class=c1>// Good: 推荐此风格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tablename</span><span class=p>;</span>  <span class=c1>// Bad: 禁止此风格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span>       <span class=c1>// Good: 只有一个单词时，小驼峰为全小写
</span></span></span></code></pre></div><h3 id=a-namer2-5-1a规则251-全局变量应增加-g_-前缀静态变量命名不需要加特殊前缀><a name=r2-5-1></a>规则2.5.1 全局变量应增加 &lsquo;g_&rsquo; 前缀，静态变量命名不需要加特殊前缀</h3><p>全局变量是应当尽量少使用的，使用时应特别注意，所以加上前缀用于视觉上的突出，促使开发人员对这些变量的使用更加小心。</p><ul><li>全局静态变量命名与全局变量相同。</li><li>函数内的静态变量命名与普通局部变量相同。</li><li>类的静态成员变量和普通成员变量相同。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_activeConnectCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>packetCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namer2-5-2a规则252-类的成员变量命名以小驼峰加后下划线组成><a name=r2-5-2></a>规则2.5.2 类的成员变量命名以小驼峰加后下划线组成</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileName_</span><span class=p>;</span>   <span class=c1>// 添加_后缀，类似于K&amp;R命名风格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>对于struct/union的成员变量，仍采用小驼峰不加后缀的命名方式，与局部变量命名风格一致。</p><h2 id=a-namec2-6a-宏常量枚举命名><a name=c2-6></a>宏、常量、枚举命名</h2><p>宏、枚举值采用全大写，下划线连接的格式。
全局作用域内，有名和匿名namespace内的 const 常量，类的静态成员常量，全大写，下划线连接；函数局部 const 常量和类的普通const成员变量，使用小驼峰命名风格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX(a, b)   (((a) &lt; (b)) ? (b) : (a)) </span><span class=c1>// 仅对宏命名举例，并不推荐用宏实现此类功能
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TintColor</span> <span class=p>{</span>    <span class=c1>// 注意，枚举类型名用大驼峰，其下面的取值是全大写，下划线相连
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DARK_RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>GREEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LIGHT_GREEN</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>    <span class=c1>// 函数局部常量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Utils</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>DEFAULT_FILE_SIZE_KB</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>        <span class=c1>// 全局常量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h1 id=a-namec3a3-格式><a name=c3></a>3 格式</h1><h2 id=a-namec3-1a行宽><a name=c3-1></a>行宽</h2><h3 id=a-namer3-1-1a规则311-行宽不超过-120-个字符><a name=r3-1-1></a>规则3.1.1 行宽不超过 120 个字符</h3><p>建议每行字符数不要超过 120 个。如果超过120个字符，请选择合理的方式进行换行。</p><p>例外:</p><ul><li>如果一行注释包含了超过120 个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；</li><li>包含长路径的 #include 语句可以超出120 个字符，但是也需要尽量避免；</li><li>编译预处理中的error信息可以超出一行。
预处理的 error 信息在一行便于阅读和理解，即使超过 120 个字符。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef XXX_YYY_ZZZ
</span></span></span><span class=line><span class=cl><span class=cp>#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 id=a-namec3-2a缩进><a name=c3-2></a>缩进</h2><h3 id=a-namer3-2-1a规则321-使用空格进行缩进每次缩进4个空格><a name=r3-2-1></a>规则3.2.1 使用空格进行缩进，每次缩进4个空格</h3><p>只允许使用空格(space)进行缩进，每次缩进为 4 个空格。不允许使用Tab符进行缩进。
当前几乎所有的集成开发环境（IDE）都支持配置将Tab符自动扩展为4空格输入；请配置你的IDE支持使用空格进行缩进。</p><h2 id=a-namec3-3a大括号><a name=c3-3></a>大括号</h2><h3 id=a-namer3-3-1a规则331-使用-kr-缩进风格><a name=r3-3-1></a>规则3.3.1 使用 K&amp;R 缩进风格</h3><p><strong>K&amp;R风格</strong>
换行时，函数（不包括lambda表达式）左大括号另起一行放行首，并独占一行；其他左大括号跟随语句放行末。
右大括号独占一行，除非后面跟着同一语句的剩余部分，如 do 语句中的 while，或者 if 语句的 else/else if，或者逗号、分号。</p><p>如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span> <span class=p>{</span>     <span class=c1>// 跟随语句放行末，前置1空格
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                   <span class=c1>// 函数左大括号独占一行，放行首
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>推荐这种风格的理由：</p><ul><li>代码更紧凑；</li><li>相比另起一行，放行末使代码阅读节奏感上更连续；</li><li>符合后来语言的习惯，符合业界主流习惯；</li><li>现代集成开发环境（IDE）都具有代码缩进对齐显示的辅助功能，大括号放在行尾并不会对缩进和范围产生理解上的影响。</li></ul><p>对于空函数体，可以将大括号放在同一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec3-4a-函数声明和定义><a name=c3-4></a>函数声明和定义</h2><h3 id=a-namer3-4-1a规则341-函数声明和定义的返回类型和函数名在同一行函数参数列表超出行宽时要换行并合理对齐><a name=r3-4-1></a>规则3.4.1 函数声明和定义的返回类型和函数名在同一行；函数参数列表超出行宽时要换行并合理对齐</h3><p>在声明和定义函数的时候，函数的返回值类型应该和函数名在同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。
参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>FunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>)</span>   <span class=c1>// Good：全在同一行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>VeryVeryVeryLongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span>     <span class=c1>// 行宽不满足所有参数，进行换行
</span></span></span><span class=line><span class=cl><span class=c1></span>                                        <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span>     <span class=c1>// Good：和上一行参数对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>                                        <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>LongFunctionName</span><span class=p>(</span><span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=c1>// 行宽限制，进行换行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName5</span><span class=p>)</span>     <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=nf>ReallyReallyReallyReallyLongFunctionName</span><span class=p>(</span>            <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArgType</span> <span class=n>paramName1</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>ArgType</span> <span class=n>paramName3</span><span class=p>)</span> <span class=c1>// Good: 换行后 4 空格缩进
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec3-5a函数调用><a name=c3-5></a>函数调用</h2><h3 id=a-namer3-5-1a规则351-函数调用入参列表应放在一行超出行宽换行时保持参数进行合理对齐><a name=r3-5-1></a>规则3.5.1 函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐</h3><p>函数调用时，函数参数列表放在一行。参数列表如果超过行宽，需要换行并进行合理的参数对齐。
左圆括号总是跟函数名，右圆括号总是跟最后一个参数。</p><p>换行举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>);</span>   <span class=c1>// Good：函数参数放在一行
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>paramName2</span><span class=p>,</span>                <span class=c1>// Good：保持与上方参数对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>                                 <span class=n>paramName3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>FunctionName</span><span class=p>(</span><span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>paramName3</span><span class=p>,</span> <span class=n>paramName4</span><span class=p>,</span> <span class=n>paramName5</span><span class=p>);</span>                    <span class=c1>// Good：参数换行，4 空格缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>ReturnType</span> <span class=n>result</span> <span class=o>=</span> <span class=n>VeryVeryVeryLongFunctionName</span><span class=p>(</span>           <span class=c1>// 行宽不满足第1个参数，直接换行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>paramName1</span><span class=p>,</span> <span class=n>paramName2</span><span class=p>,</span> <span class=n>paramName3</span><span class=p>);</span>                    <span class=c1>// 换行后，4 空格缩进
</span></span></span></code></pre></div><p>如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Good：每行的参数代表一组相关性较强的数据结构，放在一行便于理解
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DealWithStructureLikeParams</span><span class=p>(</span><span class=n>left</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>left</span><span class=p>.</span><span class=n>y</span><span class=p>,</span>     <span class=c1>// 表示一组相关参数
</span></span></span><span class=line><span class=cl><span class=c1></span>                                         <span class=n>right</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>right</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>  <span class=c1>// 表示另外一组相关参数
</span></span></span></code></pre></div><h2 id=a-namec3-6a-if语句><a name=c3-6></a>if语句</h2><h3 id=a-namer3-6-1a规则361-if语句必须要使用大括号><a name=r3-6-1></a>规则3.6.1 if语句必须要使用大括号</h3><p>我们要求if语句都需要使用大括号，即便只有一条语句。</p><p>理由：</p><ul><li>代码逻辑直观，易读；</li><li>在已有条件语句代码上增加新代码时不容易出错；</li><li>对于在if语句中使用函数式宏时，有大括号保护不易出错（如果宏定义时遗漏了大括号）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>objectIsNotExist</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Good：单行条件语句也加大括号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>CreateNewObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namer3-6-2a规则362-禁止-ifelseelse-if-写在同一行><a name=r3-6-2></a>规则3.6.2 禁止 if/else/else if 写在同一行</h3><p>条件语句中，若有多个分支，应该写在不同行。</p><p>如下是正确的写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// Good: else 与 if 在不同行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是不符合规范的案例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>someConditions</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=c1>// Bad: else 与 if 在同一行
</span></span></span></code></pre></div><h2 id=a-namec3-7a-循环语句><a name=c3-7></a>循环语句</h2><h3 id=a-namer3-7-1a规则371-循环语句必须使用大括号><a name=r3-7-1></a>规则3.7.1 循环语句必须使用大括号</h3><p>和条件表达式类似，我们要求for/while循环语句必须加上大括号，即便循环体是空的，或循环语句只有一条。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// Good: 使用了大括号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>   <span class=c1>// Good：循环体是空，使用大括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>continue</span><span class=p>;</span>           <span class=c1>// Good：continue 表示空逻辑，使用大括号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>      <span class=c1>// Bad: 应该加上括号
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>);</span>      <span class=c1>// Bad：使用分号容易让人误解是while语句中的一部分
</span></span></span></code></pre></div><h2 id=a-namec3-8a-switch语句><a name=c3-8></a>switch语句</h2><h3 id=a-namer3-8-1a规则381-switch-语句的-casedefault-要缩进一层><a name=r3-8-1></a>规则3.8.1 switch 语句的 case/default 要缩进一层</h3><p>switch 语句的缩进风格如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>             <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DoSomething1</span><span class=p>();</span> <span class=c1>// Good: 缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span>           <span class=c1>// Good: 带大括号格式
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DoSomething2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=o>:</span>                 <span class=c1>// Bad: case 未缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span>                <span class=c1>// Bad: default 未缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec3-9a-表达式><a name=c3-9></a>表达式</h2><h3 id=a-namea3-9-1a建议391-表达式换行要保持换行的一致性运算符放行末><a name=a3-9-1></a>建议3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><p>较长的表达式，不满足行宽要求的时候，需要在适当的地方换行。一般在较低优先级运算符或连接符后面截断，运算符或连接符放在行末。
运算符、连接符放在行末，表示“未结束，后续还有”。
例：</p><p>// 假设下面第一行已经不满足行宽要求</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>currentValue</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>&amp;&amp;</span>  <span class=c1>// Good：换行后，逻辑操作符放在行尾
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>someCondition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>reallyReallyLongVariableName1</span> <span class=o>+</span>    <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span>             <span class=n>reallyReallyLongVariableName2</span><span class=p>;</span>
</span></span></code></pre></div><p>表达式换行后，注意保持合理对齐，或者4空格缩进。参考下面例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>         <span class=c1>// Good: 4空格缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>longVariableName1</span> <span class=o>+</span> <span class=n>longVariableName2</span> <span class=o>+</span> <span class=n>longVariableName3</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>          <span class=n>longVariableName4</span> <span class=o>+</span> <span class=n>longVariableName5</span> <span class=o>+</span> <span class=n>longVariableName6</span><span class=p>;</span>   <span class=c1>// Good: 保持对齐
</span></span></span></code></pre></div><h2 id=a-namec3-10a-变量赋值><a name=c3-10></a>变量赋值</h2><h3 id=a-namer3-10-1a规则3101-多个变量定义和赋值语句不允许写在一行><a name=r3-10-1></a>规则3.10.1 多个变量定义和赋值语句不允许写在一行</h3><p>每行只有一个变量初始化的语句，更容易阅读和理解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span></code></pre></div><p>下面是不符合规范的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>maxCount</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=kt>bool</span> <span class=n>isCompleted</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Bad：多个变量初始化需要分开放在多行，每行一个变量初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Bad：多个变量定义需要分行，每行一个
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pointY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>pointX</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>pointY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Bad：多个变量赋值语句放同一行
</span></span></span></code></pre></div><p>例外：for 循环头、if 初始化语句（C++17）、结构化绑定语句（C++17）中可以声明和初始化多个变量。这些语句中的多个变量声明有较强关联，如果强行分成多行会带来作用域不一致，声明和初始化割裂等问题。</p><h2 id=a-namec3-11a-初始化><a name=c3-11></a>初始化</h2><p>初始化包括结构体、联合体、及数组的初始化</p><h3 id=a-namer3-11-1a规则3111-初始化换行时要有缩进并进行合理对齐><a name=r3-11-1></a>规则3.11.1 初始化换行时要有缩进，并进行合理对齐</h3><p>结构体或数组初始化时，如果换行应保持4空格缩进。
从可读性角度出发，选择换行点和对齐位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec3-12a-指针与引用><a name=c3-12></a>指针与引用</h2><h3 id=a-namea3-12-1a建议3121--指针类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-1></a>建议3.12.1 指针类型"<code>*</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>指针命名: <code>*</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>   <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Bad
</span></span></span></code></pre></div><p>例外：当变量被 const 修饰时，"<code>*</code>&rdquo; 无法跟随变量，此时也不要跟随类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>VERSION</span> <span class=o>=</span> <span class=s>&#34;V100&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=a-namea3-12-2a建议3122--引用类型跟随变量名或者类型不要两边都留有或者都没有空格><a name=a3-12-2></a>建议3.12.2 引用类型"<code>&</code>&ldquo;跟随变量名或者类型，不要两边都留有或者都没有空格</h3><p>引用命名：<code>&</code>靠左靠右都可以，但是不要两边都有或者都没有空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>     <span class=c1>// Good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*&amp;</span> <span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，*&amp; 一起跟随变量名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>rp</span> <span class=o>=</span> <span class=n>pi</span><span class=p>;</span>  <span class=c1>// Good，指针的引用，* 跟随类型，&amp; 跟随变量名
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>&amp;</span><span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>      <span class=c1>// Bad
</span></span></span></code></pre></div><h2 id=a-namec3-13a-编译预处理><a name=c3-13></a>编译预处理</h2><h3 id=a-namer3-13-1a规则3131-编译预处理的统一放在行首嵌套编译预处理语句时可以进行缩进><a name=r3-13-1></a>规则3.13.1 编译预处理的&rdquo;#&ldquo;统一放在行首，嵌套编译预处理语句时，&rdquo;#&ldquo;可以进行缩进</h3><p>编译预处理的&rdquo;#&ldquo;统一放在行首，即使编译预处理的代码是嵌入在函数体中的，&rdquo;#&ldquo;也应该放在行首。</p><h3 id=a-namer3-13-2a规则3132-避免使用宏><a name=r3-13-2></a>规则3.13.2 避免使用宏</h3><p>宏会忽略作用域，类型系统以及各种规则，容易引发问题。应尽量避免使用宏定义，如果必须使用宏，要保证证宏名的唯一性。
在C++中，有许多方式来避免使用宏：</p><ul><li>用const或enum定义易于理解的常量</li><li>用namespace避免名字冲突</li><li>用inline函数避免函数调用的开销</li><li>用template函数来处理多种类型</li></ul><p>在文件头保护宏、条件编译、日志记录等必要场景中可以使用宏。</p><h3 id=a-namer3-13-3a规则3133-禁止使用宏来表示常量><a name=r3-13-3></a>规则3.13.3 禁止使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名； 宏没有类型检查，不安全； 宏没有作用域。</p><h3 id=a-namer3-13-4a规则3134-禁止使用函数式宏><a name=r3-13-4></a>规则3.13.4 禁止使用函数式宏</h3><p>宏义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。
函数式宏的缺点如下：</p><ul><li>函数式宏缺乏类型检查，不如函数调用检查严格</li><li>宏展开时宏参数不求值，可能会产生非预期结果</li><li>宏没有独立的作用域</li><li>宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性</li><li>在特定场景中必须用编译器对宏的扩展语法，如GCC的statement expression，影响可移植性</li><li>宏在预编译阶段展开后，在期后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题</li><li>对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀</li></ul><p>函数没有宏的上述缺点。但是，函数相比宏，最大的劣势是执行效率不高（增加函数调用的开销和编译器优化的难度）。
为此，可以在必要时使用内联函数。内联函数跟宏类似，也是在调用点展开。不同之处在于内联函数是在编译时展开。</p><p>内联函数兼具函数和宏的优点：</p><ul><li>内联函数执行严格的类型检查</li><li>内联函数的参数求值只会进行一次</li><li>内联函数就地展开，没有函数调用的开销</li><li>内联函数比函数优化得更好</li></ul><p>对于性能要求高的产品代码，可以考虑用内联函数代替函数。</p><p>例外：
在日志记录场景中，需要通过函数式宏保持调用点的文件名（<strong>FILE</strong>）、行号（<strong>LINE</strong>）等信息。</p><h2 id=a-namec3-14a-空格和空行><a name=c3-14></a>空格和空行</h2><h3 id=a-namer3-14-1a规则3141-水平空格应该突出关键字和重要信息避免不必要的留白><a name=r3-14-1></a>规则3.14.1 水平空格应该突出关键字和重要信息，避免不必要的留白</h3><p>水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。总体规则如下：</p><ul><li>if, switch, case, do, while, for等关键字之后加空格；</li><li>小括号内部的两侧，不要加空格；</li><li>大括号内部两侧有无空格，左右必须保持一致；</li><li>一元操作符（& * + ‐ ~ !）之后不要加空格；</li><li>二元操作符（= + ‐ &lt; > * / % | & ^ &lt;= >= == != ）左右两侧加空格</li><li>三目运算符（? :）符号两侧均需要空格</li><li>前置和后置的自增、自减（++ &ndash;）和变量之间不加空格</li><li>结构体成员操作符（. ->）前后不加空格</li><li>逗号(,)前面不加空格，后面增加空格</li><li>对于模板和类型转换(&lt;>)和类型之间不要添加空格</li><li>域操作符(::)前后不要添加空格</li><li>冒号(:)前后根据情况来判断是否要添加空格</li></ul><p>常规情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：大括号前应该留空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Good：变量初始化时，=前后应该有空格，分号前面不要留空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>    <span class=c1>// Good：大括号内两侧都无空格
</span></span></span></code></pre></div><p>函数定义和函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>arg1</span><span class=p>,</span><span class=n>arg2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>^</span>    <span class=c1>// Bad: 逗号后面需要增加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                 <span class=o>^</span>          <span class=o>^</span>  <span class=c1>// Bad: 函数参数列表的左括号后面不应该有空格，右括号前面不应该有空格
</span></span></span></code></pre></div><p>指针和取地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>     <span class=c1>// Good：*操作符和指针p之间不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：&amp;操作符和变量x之间不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>    <span class=c1>// Good：通过.访问成员变量时不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>   <span class=c1>// Good：通过-&gt;访问成员变量时不加空格
</span></span></span></code></pre></div><p>操作符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// Good：赋值操作的=前后都要加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5</span><span class=p>;</span>  <span class=c1>// Good：负数的符号和数值之前不要加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>x</span><span class=p>;</span>     <span class=c1>// Good：前置和后置的++/--和变量之间不要加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>y</span><span class=p>)</span>  <span class=c1>// Good：布尔操作符前后要加上空格，！操作和变量之间不要空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>/</span> <span class=n>z</span><span class=p>;</span>  <span class=c1>// Good：二元操作符前后要加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>=</span> <span class=n>w</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>z</span><span class=p>);</span>    <span class=c1>// Good：括号内的表达式前后不需要加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>  <span class=c1>// Good: 三目运算符， ？和：前后需要添加空格
</span></span></span></code></pre></div><p>循环和条件语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：if关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>           <span class=c1>// Good：else关键字和大括号之间加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{}</span>   <span class=c1>// Good：while关键字和括号之间加空格，括号内条件语句前后不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>someRange</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good：for关键字和括号之间加空格，分号之后加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Good: switch 关键字后面有1空格
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>     <span class=c1>// Good：case语句条件和冒号之间不加空格
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>模板和转换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在类型与指针操作符之间留空格也可以, 但要保持一致.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>域操作符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>    <span class=c1>// Good: 命名空间访问，不要留空格
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>GetValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{}</span>  <span class=c1>// Good: 对于成员函数定义，不要留空格
</span></span></span></code></pre></div><p>冒号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 添加空格的场景
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Good: 类的派生需要留有空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 构造函数初始化列表需要留有空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 位域表示也留有空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>XX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不添加空格的场景
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Good: 对于public:, private:这种类访问权限的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对于switch-case的case和default后面的冒号不用添加空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意：当前的集成开发环境（IDE）可以设置删除行尾的空格，请正确配置。</p><h3 id=a-namea3-14-1a建议3141-合理安排空行保持代码紧凑><a name=a3-14-1></a>建议3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：</p><ul><li>根据上下内容的相关程度，合理安排空行；</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不使用连续 <strong>3</strong> 个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但namespace的大括号内不作要求。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Bar</span><span class=p>()</span>  <span class=c1>// Bad：最多使用连续2个空行。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行首不要加入空行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：大括号内的代码块行尾不要加入空行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Foo</span><span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Bad：函数体内行首不要加空行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec3-15a-类><a name=c3-15></a>类</h2><h3 id=a-namer3-15-1a规则3151-类访问控制块的声明依次序是-public-protected-private缩进和-class-关键字对齐><a name=r3-15-1></a>规则3.15.1 类访问控制块的声明依次序是 public:, protected:, private:，缩进和 class 关键字对齐</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>      <span class=c1>// 注意没有缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MyClass</span><span class=p>();</span>  <span class=c1>// 标准的4空格缩进
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>explicit</span> <span class=nf>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SomeFunctionThatDoesNothing</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetVar</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=p>{</span> <span class=n>someVar_</span> <span class=o>=</span> <span class=n>var</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVar</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>someVar_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>SomeInternalFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>someOtherVar_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在各个部分中，建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它成员函数, 数据成员。</p><h3 id=a-namer3-15-2a规则3152-构造函数初始化列表放在同一行或按四格缩进并排多行><a name=r3-15-2></a>规则3.15.2 构造函数初始化列表放在同一行或按四格缩进并排多行</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 如果所有变量能放在同一行:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果不能放在同一行,
</span></span></span><span class=line><span class=cl><span class=c1>// 必须置于冒号后, 并缩进4个空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span> <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Good: 逗号后面留有空格
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果初始化列表需要置于多行, 需要逐行对齐
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=o>::</span><span class=n>MyClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>someVar_</span><span class=p>(</span><span class=n>var</span><span class=p>),</span>             <span class=c1>// 缩进4个空格
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>someOtherVar_</span><span class=p>(</span><span class=n>var</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=a-namec4a4-注释><a name=c4></a>4 注释</h1><p>一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明。
注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，<strong>按需注释</strong>。</p><p>注释内容要简洁、明了、无二义性，信息全面且不冗余。</p><p><strong>注释跟代码一样重要。</strong>
写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释，即注释解释代码难以表达的意图，不要重复代码信息。
修改代码时，也要保证其相关注释的一致性。只改代码，不改注释是一种不文明行为，破坏了代码与注释的一致性，让阅读者迷惑、费解，甚至误解。</p><p>使用英文进行注释。</p><h2 id=a-namec3-1a注释风格><a name=c3-1></a>注释风格</h2><p>在 C++ 代码中，使用 <code>/*</code> <code>*/</code>和 <code>//</code> 都是可以的。
按注释的目的和位置，注释可分为不同的类型，如文件头注释、函数头注释、代码注释等等；
同一类型的注释应该保持统一的风格。</p><p>注意：本文示例代码中，大量使用 &lsquo;//&rsquo; 后置注释只是为了更精确的描述问题，并不代表这种注释风格更好。</p><h2 id=a-namec4-2a--文件头注释><a name=c4-2></a>文件头注释</h2><h3 id=a-namer3-1a规则31-文件头注释必须包含版权许可><a name=r3-1></a>规则3.1 文件头注释必须包含版权许可</h3><p>/*</p><ul><li>Copyright (c) 2020 XXX</li><li>Licensed under the Apache License, Version 2.0 (the &ldquo;License&rdquo;);</li><li>you may not use this file except in compliance with the License.</li><li>You may obtain a copy of the License at
*</li><li><pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre></li></ul><p>*</p><ul><li>Unless required by applicable law or agreed to in writing, software</li><li>distributed under the License is distributed on an &ldquo;AS IS&rdquo; BASIS,</li><li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li><li>See the License for the specific language governing permissions and</li><li>limitations under the License.
*/</li></ul><h2 id=a-namec4-3a-函数头注释><a name=c4-3></a>函数头注释</h2><h3 id=a-namer4-3-1a规则431-公有public函数必须编写函数头注释><a name=r4-3-1></a>规则4.3.1 公有（public）函数必须编写函数头注释</h3><p>公有函数属于类对外提供的接口，调用者需要了解函数的功能、参数的取值范围、返回的结果、注意事项等信息才能正常使用。
特别是参数的取值范围、返回的结果、注意事项等都无法做到自注示，需要编写函数头注释辅助说明。</p><h3 id=a-namer4-3-2a规则432-禁止空有格式的函数头注释><a name=r4-3-2></a>规则4.3.2 禁止空有格式的函数头注释</h3><p>并不是所有的函数都需要函数头注释；
函数签名无法表达的信息，加函数头注释辅助说明;</p><p>函数头注释统一放在函数声明或定义上方，使用如下风格之一：
使用<code>//</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 单行函数头
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 多行函数头
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>使用<code>/* */</code>写函数头</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 单行函数头 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func1</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种单行函数头
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 多行函数头
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Func3</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>函数尽量通过函数名自注释，按需写函数头注释。
不要写无用、信息冗余的函数头；不要写空有格式的函数头。</p><p>函数头注释内容可选，但不限于：功能说明、返回值，性能约束、用法、内存约定、算法实现、可重入的要求等等。
模块对外头文件中的函数接口声明，其函数头注释，应当将重要、有用的信息表达清楚。</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 返回实际写入的字节数，-1表示写入失败
</span></span></span><span class=line><span class=cl><span class=cm> * 注意，内存 buf 由调用者负责释放
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>坏的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 函数名：WriteString
</span></span></span><span class=line><span class=cl><span class=cm> * 功能：写入字符串
</span></span></span><span class=line><span class=cl><span class=cm> * 参数：
</span></span></span><span class=line><span class=cl><span class=cm> * 返回值：
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>上面例子中的问题：</p><ul><li>参数、返回值，空有格式没内容</li><li>函数名信息冗余</li><li>关键的 buf 由谁释放没有说清楚</li></ul><h2 id=a-namec4-4a-代码注释><a name=c4-4></a>代码注释</h2><h3 id=a-namer4-4-1a规则441-代码注释放于对应代码的上方或右边><a name=r4-4-1></a>规则4.4.1 代码注释放于对应代码的上方或右边</h3><h3 id=a-namer4-4-2a规则442-注释符与注释内容间要有1空格右置注释与前面代码至少1空格><a name=r4-4-2></a>规则4.4.2 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格</h3><p>代码上方的注释，应该保持对应代码一样的缩进。
选择并统一使用如下风格之一：
使用<code>//</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是单行注释
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这是多行注释
</span></span></span><span class=line><span class=cl><span class=c1>// 第二行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>使用<code>/*' '*/</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 这是单行注释 */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * 另一种方式的多行注释
</span></span></span><span class=line><span class=cl><span class=cm> * 第二行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>();</span>
</span></span></code></pre></div><p>代码右边的注释，与代码之间，至少留1空格，建议不超过4空格。
通常使用扩展后的 TAB 键即可实现 1-4 空格的缩进。</p><p>选择并统一使用如下风格之一：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>  <span class=c1>// 放右边的注释
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>bar</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>  <span class=cm>/* 放右边的注释 */</span>
</span></span></code></pre></div><p>右置格式在适当的时候，上下对齐会更美观。
对齐后的注释，离左边代码最近的那一行，保证1-4空格的间隔。
例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>A_CONST</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>         <span class=cm>/* 相关的同类注释，可以考虑上下对齐 */</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>ANOTHER_CONST</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>   <span class=cm>/* 上下对齐时，与左侧代码保持间隔 */</span>
</span></span></code></pre></div><p>当右置的注释超过行宽时，请考虑将注释置于代码上方。</p><h3 id=a-namer4-4-3a规则443-不用的代码段直接删除不要注释掉><a name=r4-4-3></a>规则4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。
正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 /* */ 和 //，还包括 #if 0， #ifdef NEVER_DEFINED 等等。</p><h1 id=a-namec5a5-头文件><a name=c5></a>5 头文件</h1><h2 id=a-namec5-1a-头文件职责><a name=c5-1></a>头文件职责</h2><p>头文件是模块或文件的对外接口，头文件的设计体现了大部分的系统设计。
头文件中适合放置接口的声明，不适合放置实现（内联函数除外）。对于cpp文件中内部才需要使用的函数、宏、枚举、结构定义等不要放在头文件中。
头文件应当职责单一。头文件过于复杂，依赖过于复杂还是导致编译时间过长的主要原因。</p><h3 id=a-namea5-1-1a建议511-每一个cpp文件应有一个对应的h文件用于声明需要对外公开的类与接口><a name=a5-1-1></a>建议5.1.1 每一个.cpp文件应有一个对应的.h文件，用于声明需要对外公开的类与接口</h3><p>通常情况下，每个.cpp文件都有一个相应的.h，用于放置对外提供的函数声明、宏定义、类型定义等。
如果一个.cpp文件不需要对外公布任何接口，则其就不应当存在。
例外：<strong>程序的入口（如main函数所在的文件），单元测试代码，动态库代码。</strong></p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef FOO_H
</span></span></span><span class=line><span class=cl><span class=cp>#define FOO_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;Foo.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span> <span class=c1>// Good: 对内函数的声明放在.cpp文件的头部，并声明为匿名namespace或者static限制其作用域
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec5-2a-头文件依赖><a name=c5-2></a>头文件依赖</h2><h3 id=a-namer5-2-1a规则521-禁止头文件循环依赖><a name=r5-2-1></a>规则5.2.1 禁止头文件循环依赖</h3><p>头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。</p><p>头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。</p><h3 id=a-namer5-2-4a规则522-头文件必须编写define保护防止重复包含><a name=r5-2-4></a>规则5.2.2 头文件必须编写<code>#define</code>保护，防止重复包含</h3><p>为防止头文件被重复包含，所有头文件都应当使用 #define 保护；不要使用 #pragma once</p><p>定义包含保护符时，应该遵守如下规则：
1）保护符使用唯一名称；
2）不要在受保护部分的前后放置代码或者注释，文件头注释除外。</p><p>示例：假定timer模块的timer.h，其目录为timer/include/timer.h,应按如下方式保护：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp>#define TIMER_INCLUDE_TIMER_H
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h3 id=a-namer5-2-5a规则523-禁止通过声明的方式引用外部函数接口变量><a name=r5-2-5></a>规则5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。
通过 extern 声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。
同时这种隐式依赖，容易导致架构腐化。</p><p>不符合规范的案例：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>   <span class=c1>// Bad: 通过extern的方式使用外部函数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>应该改为：</p><p>// a.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>   </span><span class=c1>// Good: 通过包含头文件的方式使用其他.cpp提供的接口
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>();</span>
</span></span></code></pre></div><p>// b.cpp内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>例外，有些场景需要引用其内部函数，但并不想侵入代码时，可以 extern 声明方式引用。
如：
针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数；
当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数。</p><h3 id=a-namer5-2-6a规则524-禁止在extern-c中包含头文件><a name=r5-2-6></a>规则5.2.4 禁止在extern &ldquo;C"中包含头文件</h3><p>在 extern &ldquo;C&rdquo; 中包含头文件，有可能会导致 extern &ldquo;C&rdquo; 嵌套，部分编译器对 extern &ldquo;C&rdquo; 嵌套层次有限制，嵌套层次太多会编译错误。</p><p>在C，C++混合编程的情况下，在extern &ldquo;C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。</p><p>示例，存在a.h和b.h两个头文件：</p><p>// a.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define A(value) Foo(value)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>// b.h内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>使用C++预处理器展开b.h，将会得到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>按照 a.h 作者的本意，函数 Foo 是一个 C++ 自由函数，其链接规范为 &ldquo;C++"。
但在 b.h 中，由于 <code>#include "a.h"</code> 被放到了 <code>extern "C"</code> 的内部，函数 Foo 的链接规范被不正确地更改了。</p><p>例外：
如果在 C++ 编译环境中，想引用纯C的头文件，这些C头文件并没有<code> extern "C"</code> 修饰。非侵入式的做法是，在 <code>extern "C"</code> 中去包含C头文件。</p><h3 id=a-namea5-2-1a建议521尽量避免使用前置声明而是通过include来包含头文件><a name=a5-2-1></a>建议5.2.1尽量避免使用前置声明，而是通过<code>#include</code>来包含头文件</h3><p>前置声明（forward declaration）通常指类、模板的纯粹声明，没伴随着其定义。</p><ul><li>优点：<ol><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li></ol></li><li>缺点：<ol><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li><li>前置声明可能会被库的后续更改所破坏。前置声明模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间<code> std::</code> 的 symbol 时，其行为未定义（在C++11标准规范中明确说明）。</li><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</li><li>很难判断什么时候该用前置声明，什么时候该用<code>#include</code>，某些场景下面前置声明和<code>#include</code>互换以后会导致意想不到的结果。</li></ol></li></ul><p>所以我们尽可能避免使用前置声明，而是使用#include头文件来保证依赖关系。</p><h1 id=a-namec6a6-作用域><a name=c6></a>6 作用域</h1><h2 id=a-namec6-1a-命名空间><a name=c6-1></a>命名空间</h2><h3 id=a-namea6-1-1a建议611-对于cpp文件中不需要导出的变量常量或者函数请使用匿名namespace封装或者用static修饰><a name=a6-1-1></a>建议6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰</h3><p>在C++ 2003标准规范中，使用static修饰文件作用域的变量，函数等被标记为deprecated特性，所以更推荐使用匿名namespace。</p><p>主要原因如下：</p><ol><li>static在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数，静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li>static只能保证变量，常量和函数的文件作用域，但是namespace还可以封装类型等。</li><li>统一namespace来处理C++的作用域，而不需要同时使用static和namespace来管理。</li><li>static修饰的函数不能用来实例化模板，而匿名namespace可以。</li></ol><p>但是不要在 .h 中使用中使用匿名namespace或者static。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Foo.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_COUNT</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InternalFun</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Fun</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>MAX_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>InternalFun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namer6-1-1a规则611-不要在头文件中或者include之前使用using导入命名空间><a name=r6-1-1></a>规则6.1.1 不要在头文件中或者#include之前使用using导入命名空间</h3><p>说明：使用using导入命名空间会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using导入命名空间。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件a.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>NamespaceA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 头文件b.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>NamespaceB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>G</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Fun</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 源代码a.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;a.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>NamespaceA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;b.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>G</span><span class=p>();</span> <span class=c1>// using namespace NamespaceA在#include “b.h”之前，引发歧义：NamespaceA::Fun，NamespaceB::Fun调用不明确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>对于在头文件中使用using导入单个符号或定义别名，允许在模块自定义名字空间中使用，但禁止在全局名字空间中使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// foo.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fancy/string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Bad，禁止向全局名字空间导入符号
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>fancy</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>  <span class=c1>// Good，可以在模块自定义名字空间中导入符号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>MyVector</span> <span class=o>=</span> <span class=n>fancy</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>  <span class=c1>// Good，C++11可在自定义名字空间中定义别名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec6-2a-全局函数和静态成员函数><a name=c6-2></a>全局函数和静态成员函数</h2><h3 id=a-namea6-2-1a建议621-优先使用命名空间来管理全局函数如果和某个class有直接关系的可以使用静态成员函数><a name=a6-2-1></a>建议6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数</h3><p>说明：非成员函数放在名字空间内可避免污染全局作用域， 也不要用类+静态成员方法来简单管理全局函数。 如果某个全局函数和某个类有紧密联系， 那么可以作为类的静态成员函数。</p><p>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>File</span> <span class=n>CreateTempFile</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec6-3a-全局常量和静态成员常量><a name=c6-3></a>全局常量和静态成员常量</h2><h3 id=a-namea6-3-1a建议631-优先使用命名空间来管理全局常量如果和某个class有直接关系的可以使用静态成员常量><a name=a6-3-1></a>建议6.3.1 优先使用命名空间来管理全局常量，如果和某个class有直接关系的，可以使用静态成员常量</h3><p>说明：全局常量放在命名空间内可避免污染全局作用域， 也不要用类+静态成员常量来简单管理全局常量。 如果某个全局常量和某个类有紧密联系， 那么可以作为类的静态成员常量。</p><p>如果你需要定义一些全局常量，只给某个cpp文件使用，那么请使用匿名namespace来管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>MyNamespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>SEPARATOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec6-4a-全局变量><a name=c6-4></a>全局变量</h2><h3 id=a-namea6-4-1a建议641-尽量避免使用全局变量考虑使用单例模式><a name=a6-4-1></a>建议6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>说明：全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>g_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>g_counter</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>使用单实例模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Counter</span><span class=o>&amp;</span> <span class=n>GetInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Counter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  <span class=c1>// 单实例实现简单举例
</span></span></span><span class=line><span class=cl><span class=c1></span>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Increase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Print</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Counter</span><span class=p>()</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Increase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Counter</span><span class=o>::</span><span class=n>GetInstance</span><span class=p>().</span><span class=n>Print</span><span class=p>();</span>
</span></span></code></pre></div><p>实现单例模式以后，实现了全局唯一一个实例，和全局变量同样的效果，并且单实例提供了更好的封装性。</p><p>例外：有的时候全局变量的作用域仅仅是模块内部，这样进程空间里面就会有多个全局变量实例，每个模块持有一份，这种场景下是无法使用单例模式解决的。</p><h1 id=a-namec7a7-类><a name=c7></a>7 类</h1><h2 id=a-namec7-1a-构造拷贝构造赋值和析构函数><a name=c7-1></a>构造，拷贝构造，赋值和析构函数</h2><p>构造，拷贝，移动和析构函数提供了对象的生命周期管理方法：</p><ul><li>构造函数（constructor）： <code>X()</code></li><li>拷贝构造函数（copy constructor）：<code>X(const X&)</code></li><li>拷贝赋值操作符（copy assignment）：<code>operator=(const X&)</code></li><li>移动构造函数（move constructor）：<code>X(X&&)</code> <em>C++11以后提供</em></li><li>移动赋值操作符（move assignment）：<code>operator=(X&&)</code> <em>C++11以后提供</em></li><li>析构函数（destructor）：<code>~X()</code></li></ul><h3 id=a-namer7-1-1a规则711-类的成员变量必须显式初始化><a name=r7-1-1></a>规则7.1.1 类的成员变量必须显式初始化</h3><p>说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。</p><p>例外：</p><ul><li>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化。</li></ul><p>示例：如下代码没有构造函数，私有数据成员无法初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//…
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Message</span> <span class=n>message</span><span class=p>;</span>   <span class=c1>// message成员变量没有初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>message</span><span class=p>.</span><span class=n>ProcessOutMsg</span><span class=p>();</span>   <span class=c1>// 后续使用存在隐患
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 因此，有必要定义默认构造函数，如下：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgID_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>msgBuffer_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ProcessOutMsg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>someIdentifier_</span><span class=p>;</span> <span class=c1>// 具有默认构造函数，不需要显式初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namea7-1-1a建议711-成员变量优先使用声明时初始化c11和构造函数初始化列表初始化><a name=a7-1-1></a>建议7.1.1 成员变量优先使用声明时初始化（C++11）和构造函数初始化列表初始化</h3><p>说明：C++11的声明时初始化可以一目了然的看出成员初始值，应当优先使用。如果成员初始化值和构造函数相关，或者不支持C++11，则应当优先使用构造函数初始化列表来初始化成员。相比起在构造函数体中对成员赋值，初始化列表的代码更简洁，执行性能更好，而且可以对const成员和引用成员初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Message</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span><span class=p>()</span> <span class=o>:</span> <span class=n>msgLength_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1>// Good，优先使用初始化列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>msgBuffer_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>  <span class=c1>// Bad，不推荐在构造函数中赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgID_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>  <span class=c1>// Good，C++11中使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msgLength_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msgBuffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer7-1-2a规则712-为避免隐式转换将单参数构造函数声明为explicit><a name=r7-1-2></a>规则7.1.2 为避免隐式转换，将单参数构造函数声明为explicit</h3><p>说明：单参数构造函数如果没有用explicit声明，则会成为隐式转换函数。
示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span><span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ProcessFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFoo</span><span class=p>(</span><span class=n>test</span><span class=p>);</span>  <span class=c1>// 编译不通过
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码编译不通过，因为<code>ProcessFoo</code>需要的参数是Foo类型，传入的string类型不匹配。</p><p>如果将Foo构造函数的explicit关键字移除，那么调用<code>ProcessFoo</code>传入的string就会触发隐式转换，生成一个临时的Foo对象。往往这种隐式转换是让人迷惑的，并且容易隐藏Bug，得到了一个不期望的类型转换。所以对于单参数的构造函数是要求explicit声明。</p><h3 id=a-namer7-1-3a规则713-如果不需要拷贝构造函数赋值操作符--移动构造函数赋值操作符请明确禁止><a name=r7-1-3></a>规则7.1.3 如果不需要拷贝构造函数、赋值操作符 / 移动构造函数、赋值操作符，请明确禁止</h3><p>说明：如果用户不定义，编译器默认会生成拷贝构造函数和拷贝赋值操作符， 移动构造和移动赋值操作符（移动语义的函数C++11以后才有）。
如果我们不要使用拷贝构造函数，或者赋值操作符，请明确拒绝：</p><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li><p>使用C++11提供的delete, 请参见后面现代C++的相关章节。</p></li><li><p>推荐继承NoCopyable、NoMovable，禁止使用DISALLOW_COPY_AND_MOVE，DISALLOW_COPY，DISALLOW_MOVE等宏。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NoCopyable</span><span class=p>,</span> <span class=k>public</span> <span class=n>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>NoCopyable和NoMovable的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoCopyable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=p>(</span><span class=k>const</span> <span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoCopyable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoCopyable</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoMovable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NoMovable</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>NoMovable</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer7-1-4a规则714-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止><a name=r7-1-4></a>规则7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><p>拷贝构造函数和拷贝赋值操作符都是具有拷贝语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, C++11可以使用delete
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer7-1-5a规则715-移动构造和移动赋值操作符应该是成对出现或者禁止><a name=r7-1-5></a>规则7.1.5 移动构造和移动赋值操作符应该是成对出现或者禁止</h3><p>在C++11中增加了move操作，如果需要某个类支持移动操作，那么需要实现移动构造和移动赋值操作符。</p><p>移动构造函数和移动赋值操作符都是具有移动语义的，应该同时出现或者禁止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 同时出现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时default， C++11支持
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 同时禁止, 使用C++11的delete
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer7-1-6a规则716-禁止在构造函数和析构函数中调用虚函数><a name=r7-1-6></a>规则7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>说明：在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。
在C++中，一个基类一次只构造一个完整的对象。</p><p>示例：类Base是基类，Sub是派生类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Log</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// 不同的派生类调用不同的日志文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>()</span>         <span class=c1>// 基类构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Log</span><span class=p>();</span>           <span class=c1>// 调用虚函数Log
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>                                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Log</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当执行如下语句：
<code>Sub sub;</code>
会先执行Sub的构造函数，但首先调用Base的构造函数，由于Base的构造函数调用虚函数Log，此时Log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为。
同样的道理也适用于析构函数。</p><h3 id=a-namer7-1-7a规则717-多态基类中的拷贝构造函数拷贝赋值操作符移动构造函数移动赋值操作符必须为非public函数或者为delete函数><a name=r7-1-7></a>规则7.1.7 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数</h3><p>如果报一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。
【反例】
如下代码中，基类没有定义拷贝构造函数或拷贝赋值操作符，编译器会自动生成这两个特殊成员函数，
如果派生类对象赋值给基类对象时就发生切片。可以将此例中的拷贝构造函数和拷贝赋值操作符声明为delete，编译器可检查出此类赋值行为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>                      
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>               
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=o>&amp;</span><span class=n>base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>other</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span> <span class=c1>// 不符合：发生切片
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>other</span><span class=p>.</span><span class=n>Fun</span><span class=p>();</span> <span class=c1>// 调用的时Base类的Fun函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// 传入的是派生类对象
</span></span></span></code></pre></div><ol><li>将拷贝构造函数或者赋值操作符设置为private，并且不实现：</li></ol><h2 id=a-namec7-2a-继承><a name=c7-2></a>继承</h2><h3 id=a-namer7-2-1a规则721-基类的析构函数应该声明为virtual不准备被继承的类需要声明为final><a name=r7-2-1></a>规则7.2.1 基类的析构函数应该声明为virtual，不准备被继承的类需要声明为final</h3><p>说明：只有基类析构函数是virtual，通过多态调用的时候才能保证派生类的析构函数被调用。</p><p>示例：基类的析构函数没有声明为virtual导致了内存泄漏。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Base&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=p>()</span> <span class=o>:</span> <span class=n>numbers_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Sub&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>size_t</span> <span class=n>numberCount</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers_</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=n>numberCount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>numbers_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>getVersion</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>numbers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>args</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于基类Base的析构函数没有声明为virtual，当对象被销毁时，只会调用基类的析构函数，不会调用派生类Sub的析构函数，导致内存泄漏。
例外：
NoCopyable、NoMovable这种没有任何行为，仅仅用来做标识符的类，可以不定义虚析构也不定义final。</p><h3 id=a-namer7-2-2a规则722-禁止虚函数使用缺省参数值><a name=r7-2-2></a>规则7.2.2 禁止虚函数使用缺省参数值</h3><p>说明：在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，规定所有虚函数均不允许声明缺省参数值。
示例：虚函数display缺省参数值text是由编译时刻决定的，而非运行时刻，没有达到多态的目的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Base!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Display</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>text</span>  <span class=o>=</span> <span class=s>&#34;Sub!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>text</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Sub</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>  <span class=c1>// 程序输出结果: Base! 而期望输出：Sub!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sub</span><span class=o>-&gt;</span><span class=n>Display</span><span class=p>();</span>   <span class=c1>// 程序输出结果: Sub!
</span></span></span><span class=line><span class=cl><span class=c1></span>   
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer7-2-3a规则723-禁止重新定义继承而来的非虚函数><a name=r7-2-3></a>规则7.2.3 禁止重新定义继承而来的非虚函数</h3><p>说明：因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sub</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Sub</span><span class=o>*</span> <span class=n>sub</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sub</span><span class=p>();</span>                    
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>sub</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sub</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>    <span class=c1>// 调用子类的Fun                 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>base</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>();</span>   <span class=c1>// 调用父类的Fun
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><h2 id=a-namec7-3a-多重继承><a name=c7-3></a>多重继承</h2><p>在实际开发过程中使用多重继承的场景是比较少的，因为多重继承使用过程中有下面的典型问题：</p><ol><li>菱形继承所带来的数据重复，以及名字二义性。因此，C++引入了virtual继承来解决这类问题;</li><li>即便不是菱形继承，多个父类之间的名字也可能存在冲突，从而导致的二义性;</li><li>如果子类需要扩展或改写多个父类的方法时，造成子类的职责不明，语义混乱;</li><li>相对于委托，继承是一种白盒复用，即子类可以访问父类的protected成员, 这会导致更强的耦合。而多重继承，由于耦合了多个父类，相对于单根继承，这会产生更强的耦合关系。</li></ol><p>多重继承具有下面的优点：
多重继承提供了一种更简单的组合来实现多种接口或者类的组装与复用。</p><p>所以，对于多重继承的只有下面几种情况下面才允许使用多重继承。</p><h3 id=a-namea7-3-1a建议731-使用多重继承来实现接口分离与多角色组合><a name=a7-3-1></a>建议7.3.1 使用多重继承来实现接口分离与多角色组合</h3><p>如果某个类需要实现多重接口，可以通过多重继承把多个分离的接口组合起来，类似 scala 语言的 traits 混入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role1</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role2</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Role3</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object1</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role1</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object2</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Role2</span><span class=p>,</span> <span class=k>public</span> <span class=n>Role3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>在C++标准库中也有类似的实现样例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_istream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_ostream</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>basic_iostream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>basic_istream</span><span class=p>,</span> <span class=k>public</span> <span class=n>basic_ostream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec7-4a-重载><a name=c7-4></a>重载</h2><p>重载操作符要有充分理由,而且不要改变操作符原有语义，例如不要使用 ‘+’ 操作符来做减运算。
操作符重载令代码更加直观，但也有一些不足：</p><ul><li>混淆直觉，误以为该操作和内建类型一样是高性能的，忽略了性能降低的可能；</li><li>问题定位时不够直观，按函数名查找比按操作符显然更方便。</li><li>重载操作符如果行为定义不直观(例如将‘+’ 操作符来做减运算)，会让代码产生混淆。</li><li>赋值操作符的重载引入的隐式转换会隐藏很深的bug。可以定义类似Equals()、CopyFrom()等函数来替代=,==操作符。</li></ul><h1 id=a-namec8a-8-函数><a name=c8></a>8 函数</h1><h2 id=a-namec8-1a函数设计><a name=c8-1></a>函数设计</h2><h3 id=a-namer8-1-1a规则811-避免函数过长函数不超过50行非空非注释><a name=r8-1-1></a>规则8.1.1 避免函数过长，函数不超过50行（非空非注释）</h3><p>函数应该可以一屏显示完 (50行以内)，只做一件事情，而且把它做好。</p><p>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。</p><p>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。</p><p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的bug。
建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</p><h2 id=a-namec8-2a内联函数><a name=c8-2></a>内联函数</h2><h3 id=a-namea8-2-1a建议821-内联函数不超过10行非空非注释><a name=a8-2-1></a>建议8.2.1 内联函数不超过10行（非空非注释）</h3><p><strong>说明</strong>：内联函数具有一般函数的特性，它与一般函数不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。</p><p>内联函数只适合于只有 1~10 行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，也没有必要用内联函数实现，一般的编译器会放弃内联方式，而采用普通的方式调用函数。</p><p>如果内联函数包含复杂的控制结构，如循环、分支(switch)、try-catch 等语句，一般编译器将该函数视同普通函数。
<strong>虚函数、递归函数不能被用来做内联函数</strong>。</p><h2 id=a-namec8-3a-函数参数><a name=c8-3></a>函数参数</h2><h3 id=a-namea8-3-1a建议831-函数参数使用引用取代指针><a name=a8-3-1></a>建议8.3.1 函数参数使用引用取代指针</h3><p><strong>说明</strong>：引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。</p><p>如果是基于老平台开发的产品，则优先顺从原有平台的处理方式。
选择 const 避免参数被修改，让代码阅读者清晰地知道该参数不被修改，可大大增强代码可读性。</p><p>例外：当传入参数为编译期长度未知的数组时，可以使用指针而不是引用。</p><h3 id=a-namea8-3-2a建议832-使用强类型参数避免使用void><a name=a8-3-2></a>建议8.3.2 使用强类型参数，避免使用void*</h3><p>尽管不同的语言对待强类型和弱类型有自己的观点，但是一般认为c/c++是强类型语言，既然我们使用的语言是强类型的，就应该保持这样的风格。
好处是尽量让编译器在编译阶段就检查出类型不匹配的问题。</p><p>使用强类型便于编译器帮我们发现错误，如下代码中注意函数 FooListAddNode 的使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FooNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BarNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FooListAddNode</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span> <span class=c1>// Bad: 这里用 void * 类型传递参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=p>(</span><span class=n>FooNode</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAppend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_FooList</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>foo</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MakeTheList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FooNode</span> <span class=o>*</span><span class=n>foo</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BarNode</span> <span class=o>*</span><span class=n>bar</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FooListAddNode</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span>        <span class=c1>// Wrong: 这里本意是想传递参数 foo，但错传了 bar，却没有报错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ol><li>可以使用模板函数来实现参数类型的变化。</li><li>可以使用基类指针来实现多态。</li></ol><h3 id=a-namea8-3-3a建议833-函数的参数个数不超过5个><a name=a8-3-3></a>建议8.3.3 函数的参数个数不超过5个</h3><p>函数的参数过多，会使得该函数易于受外部变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。</p><p>如果超过可以考虑:</p><ul><li>看能否拆分函数</li><li>看能否将相关参数合在一起，定义结构体</li></ul><h1 id=a-namec9a-9-c其他特性><a name=c9></a>9 C++其他特性</h1><h2 id=a-namec9-1a-常量与初始化><a name=c9-1></a>常量与初始化</h2><p>不变的值更易于理解、跟踪和分析，所以应该尽可能地使用常量代替变量，定义值的时候，应该把const作为默认的选项。</p><h3 id=a-namer9-1-1a规则911-不允许使用宏来表示常量><a name=r9-1-1></a>规则9.1.1 不允许使用宏来表示常量</h3><p><strong>说明</strong>：宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MAX_MSISDN_LEN 20    </span><span class=c1>// 不好
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// C++请使用const常量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 好
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 对于C++11以上版本，可以使用constexpr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=a-namea9-1-1a建议911-一组相关的整型常量应定义为枚举><a name=a9-1-1></a>建议9.1.1 一组相关的整型常量应定义为枚举</h3><p><strong>说明</strong>：枚举比<code>#define</code>或<code>const int</code>更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>Week</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUNDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MONDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TUESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WEDNESDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>THURSDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FRIDAY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SATURDAY</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLACK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=n>Week</span> <span class=n>today</span><span class=p>,</span> <span class=n>Color</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 编译报错，参数类型错误
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 不好的例子:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>SUNDAY</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MONDAY</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLACK</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>BLUE</span>   <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ColorizeCalendar</span><span class=p>(</span><span class=kt>int</span> <span class=n>today</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ColorizeCalendar</span><span class=p>(</span><span class=n>BLUE</span><span class=p>,</span> <span class=n>SUNDAY</span><span class=p>);</span> <span class=c1>// 不会报错
</span></span></span></code></pre></div><p>当枚举值需要对应到具体数值时，须在声明时显式赋值。否则不需要显式赋值，以避免重复赋值，降低维护(增加、删除成员)工作量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：S协议里定义的设备ID值，用于标识设备类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>DeviceType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_UNKNOWN</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_DSMP</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_ISMG</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DEV_WAPPORTAL</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>程序内部使用，仅用于分类的情况，不应该进行显式的赋值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：程序中用来标识会话状态的枚举定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>SessionState</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INIT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WAITING_FOR_RESPONSE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>应当尽量避免枚举值重复，如必须重复也要用已定义的枚举来修饰</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RTCPType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SR</span> <span class=o>=</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MIN_TYPE</span> <span class=o>=</span> <span class=n>RTCP_SR</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RR</span>    <span class=o>=</span> <span class=mi>201</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_SDES</span>  <span class=o>=</span> <span class=mi>202</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_BYE</span>   <span class=o>=</span> <span class=mi>203</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_APP</span>   <span class=o>=</span> <span class=mi>204</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RTPFB</span> <span class=o>=</span> <span class=mi>205</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PSFB</span>  <span class=o>=</span> <span class=mi>206</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_XR</span>  <span class=o>=</span> <span class=mi>207</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_RSI</span> <span class=o>=</span> <span class=mi>208</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_PUBPORTS</span> <span class=o>=</span> <span class=mi>209</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RTCP_MAX_TYPE</span> <span class=o>=</span> <span class=n>RTCP_PUBPORTS</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer9-1-2a规则912-不允许使用魔鬼数字><a name=r9-1-2></a>规则9.1.2 不允许使用魔鬼数字</h3><p>所谓魔鬼数字即看不懂、难以理解的数字。</p><p>魔鬼数字并非一个非黑即白的概念，看不懂也有程度，需要自行判断。
例如数字 12，在不同的上下文中情况是不一样的：
type = 12; 就看不懂，但 <code>monthsCount = yearsCount * 12</code>; 就能看懂。
数字 0 有时候也是魔鬼数字，比如 <code>status = 0</code>; 并不能表达是什么状态。</p><p>解决途径：
对于局部使用的数字，可以增加注释说明
对于多处使用的数字，必须定义 const 常量，并通过符号命名自注释。</p><p>禁止出现下列情况：
没有通过符号来解释数字含义，如<code> const int ZERO = 0</code>
符号命名限制了其取值，如 <code>const int XX_TIMER_INTERVAL_300MS = 300</code>，直接使用<code>XX_TIMER_INTERVAL_MS</code>来表示该常量是定时器的时间间隔。</p><h3 id=a-namer9-1-3a规则913-常量应该保证单一职责><a name=r9-1-3></a>规则9.1.3 常量应该保证单一职责</h3><p><strong>说明</strong>：一个常量只用来表示一个特定功能，即一个常量不能有多种用途。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 好的例子：协议A和协议B，手机号(MSISDN)的长度都是20。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>A_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>B_MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 或者使用不同的名字空间：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>Namespace1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Namespace2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>MAX_MSISDN_LEN</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namer9-1-4a规则914-禁止用memcpy_smemset_s初始化非pod对象><a name=r9-1-4></a>规则9.1.4 禁止用memcpy_s、memset_s初始化非POD对象</h3><p><strong>说明</strong>：<code>POD</code>全称是<code>Plain Old Data</code>，是C++ 98标准(ISO/IEC 14882, first edition, 1998-09-01)中引入的一个概念，<code>POD</code>类型主要包括<code>int</code>, <code>char</code>, <code>float</code>，<code>double</code>，<code>enumeration</code>，<code>void</code>，指针等原始类型以及聚合类型，不能使用封装和面向对象特性（如用户定义的构造/赋值/析构函数、基类、虚函数等）。</p><p>由于非POD类型比如非聚合类型的class对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。</p><p>即使对聚合类型的class，使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡<code>memcpy_s</code>、<code>memset_s</code>操作。</p><p>对于POD类型的详细说明请参见附录。</p><h3 id=a-namea9-1-2a建议912-变量使用时才声明并初始化><a name=a9-1-2></a>建议9.1.2 变量使用时才声明并初始化</h3><p><strong>说明</strong>：变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并同时初始化，非常方便地避免了此类低级错误。</p><p>在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：</p><ul><li>程序难以理解和维护：变量的定义与使用分离。</li><li>变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值(比如零)来初始化，这通常是一种浪费，如果变量在被赋于有效值以前使用，还会导致错误。</li></ul><p>遵循变量作用域最小化原则与就近声明原则， 使得代码更容易阅读,方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子：声明与初始化分离
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>        <span class=c1>// 声明时未初始化：调用缺省构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>;</span>  <span class=c1>// 再次调用赋值操作符函数；声明与定义在不同的地方，理解相对困难
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 好的例子：声明与初始化一体，理解相对容易
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=nf>name</span><span class=p>(</span><span class=s>&#34;zhangsan&#34;</span><span class=p>);</span>  <span class=c1>// 调用构造函数
</span></span></span></code></pre></div><h2 id=a-namec9-2a-表达式><a name=c9-2></a>表达式</h2><h3 id=a-namer9-2-1a规则921-含有变量自增或自减运算的表达式中禁止再次引用该变量><a name=r9-2-1></a>规则9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量</h3><p>含有变量自增或自减运算的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。各个编译器或者同一个编译器不同版本实现可能会不一致。
为了更好的可移植性，不应该对标准未定义的运算次序做任何假设。</p><p>注意，运算次序的问题不能使用括号来解决，因为这不是优先级的问题。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Bad: b[i]运算跟 i++，先后顺序并不明确。
</span></span></span></code></pre></div><p>正确的写法是将自增或自减运算单独放一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 单独一行
</span></span></span></code></pre></div><p>函数参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>   <span class=c1>// Bad: 传递第2个参数时，不确定自增运算有没有发生
</span></span></span></code></pre></div><p>正确的写法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span>            <span class=c1>// Good: 单独一行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span> <span class=o>=</span> <span class=n>Func</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=a-namer9-2-2a规则922-switch语句要有default分支><a name=r9-2-2></a>规则9.2.2 switch语句要有default分支</h3><p>大部分情况下，switch语句中要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。</p><p>特例：
如果switch条件变量是枚举类型，并且 case 分支覆盖了所有取值，则加上default分支处理有些多余。
现代编译器都具备检查是否在switch语句中遗漏了某些枚举值的case分支的能力，会有相应的warning提示。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因为switch条件变量是枚举值，这里可以不用加default处理分支
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>RED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoRedThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>BLUE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DoBlueThing</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namea9-2-1a建议921-表达式的比较应当遵循左侧倾向于变化右侧倾向于不变的原则><a name=a9-2-1></a>建议9.2.1 表达式的比较，应当遵循左侧倾向于变化、右侧倾向于不变的原则</h3><p>当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX > v) 更是难于理解。
应当按人的正常阅读、表达习惯，将常量放右边。写成如下方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也有特殊情况，如：<code>if (MIN &lt; value && value &lt; MAX)</code> 用来描述区间时，前半段是常量在左的。</p><p>不用担心将 &lsquo;==&rsquo; 误写成 &lsquo;=&rsquo;，因为<code> if (value = MAX)</code> 会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><h3 id=a-namea9-2-2a建议922-使用括号明确操作符的优先级><a name=a9-2-2></a>建议9.2.2 使用括号明确操作符的优先级</h3><p>使用括号明确操作符的优先级，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。下面是如何使用括号的建议。</p><ul><li>二元及以上操作符, 如果涉及多种操作符，则应该使用括号</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>         <span class=cm>/* 操作符相同，可以不加括号 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>     <span class=cm>/* 逗号两边的表达式，不需要括号 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>      <span class=cm>/* 操作符不同，需要括号 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=p>(</span><span class=n>b</span> <span class=o>/</span> <span class=mi>5</span><span class=p>);</span>       <span class=cm>/* 操作符不同，需要括号 */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=p>(</span><span class=n>a</span> <span class=err>–</span> <span class=n>b</span><span class=p>);</span>    <span class=cm>/* 操作符不同，需要括号 */</span>
</span></span></code></pre></div><h2 id=a-namec9-3a-类型转换><a name=c9-3></a>类型转换</h2><p>避免使用类型分支来定制行为：类型分支来定制行为容易出错，是企图用C++编写C代码的明显标志。这是一种很不灵活的技术，要添加新类型时，如果忘记修改所有分支，编译器也不会告知。使用模板和虚函数，让类型自己而不是调用它们的代码来决定行为。</p><p>建议避免类型转换，我们在代码的类型设计上应该考虑到每种数据的数据类型是什么，而不是应该过度使用类型转换来解决问题。在设计某个基本类型的时候，请考虑：</p><ul><li>是无符号还是有符号的</li><li>是适合float还是double</li><li>是使用int8，int16，int32还是int64，确定整形的长度</li></ul><p>但是我们无法禁止使用类型转换，因为C++语言是一门面向机器编程的语言，涉及到指针地址，并且我们会与各种第三方或者底层API交互，他们的类型设计不一定是合理的，在这个适配的过程中很容易出现类型转换。</p><p>例外：在调用某个函数的时候，如果我们不想处理函数结果，首先要考虑这个是否是你的最好的选择。如果确实不想处理函数的返回值，那么可以使用(void)转换来解决。</p><h3 id=a-namer9-3-1a规则931-如果确定要使用类型转换请使用由c提供的类型转换而不是c风格的类型转换><a name=r9-3-1></a>规则9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换</h3><p><strong>说明</strong>：</p><p>C++提供的类型转换操作比C风格更有针对性，更易读，也更加安全，C++提供的转换有：</p><ul><li>类型转换：</li></ul><ol><li><code>dynamic_cast</code>：主要用于继承体系下行转换，<code>dynamic_cast</code>具有类型检查的功能，请做好基类和派生类的设计，避免使用dynamic_cast来进行转换。</li><li><code>static_cast</code>：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。如果是纯粹的算数转换，那么请使用后面的大括号转换方式。</li><li><code>reinterpret_cast</code>：用于转换不相关的类型。<code>reinterpret_cast</code>强制编译器将某个类型对象的内存重新解释成另一种类型，这是一种不安全的转换，建议尽可能少用<code>reinterpret_cast</code>。</li><li><code>const_cast</code>：用于移除对象的<code>const</code>属性，使对象变得可修改，这样会破坏数据的不变性，建议尽可能少用。</li></ol><ul><li>算数转换： （C++11开始支持）
对于那种算数转换，并且类型信息没有丢失的，比如float到double， int32到int64的转换，推荐使用大括号的初始方式。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=n>someFloat</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>i</span><span class=p>{</span> <span class=n>someInt32</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namea9-3-1a建议931-避免使用dynamic_cast><a name=a9-3-1></a>建议9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依赖于C++的RTTI， 让程序员在运行时识别C++类对象的类型。</li><li><code>dynamic_cast</code>的出现一般说明我们的基类和派生类设计出现了问题，派生类破坏了基类的契约，不得不通过<code>dynamic_cast</code>转换到子类进行特殊处理，这个时候更希望来改善类的设计，而不是通过<code>dynamic_cast</code>来解决问题。</li></ol><h3 id=a-namea9-3-2a建议932-避免使用reinterpret_cast><a name=a9-3-2></a>建议9.3.2 避免使用<code>reinterpret_cast</code></h3><p><strong>说明</strong>：<code>reinterpret_cast</code>用于转换不相关类型。尝试用<code>reinterpret_cast</code>将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。</p><h3 id=a-namea9-3-3a建议933-避免使用const_cast><a name=a9-3-3></a>建议9.3.3 避免使用<code>const_cast</code></h3><p><strong>说明</strong>：<code>const_cast</code>用于移除对象的<code>const</code>和<code>volatile</code>性质。</p><p>使用const_cast转换后的指针或者引用来修改const对象，行为是未定义的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>2048</span><span class=p>;</span>      <span class=c1>// 未定义行为
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好的例子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>Fun</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>  <span class=c1>// 未定义行为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec9-4a资源分配和释放><a name=c9-4></a>资源分配和释放</h2><h3 id=a-namer9-4-1a规则941-单个对象释放使用delete数组对象释放使用delete-><a name=r9-4-1></a>规则9.4.1 单个对象释放使用delete，数组对象释放使用delete []</h3><p>说明：单个对象删除使用delete， 数组对象删除使用delete []，原因：</p><ul><li>调用new所包含的动作：从系统中申请一块内存，并调用此类型的构造函数。</li><li>调用new[n]所包含的动作：申请可容纳n个对象的内存，并且对每一个对象调用其构造函数。</li><li>调用delete所包含的动作：先调用相应的析构函数，再将内存归还系统。</li><li>调用delete[]所包含的动作：对每一个对象调用析构函数，再释放所有内存</li></ul><p>如果new和delete的格式不匹配，结果是未知的。对于非class类型， new和delete不会调用构造与析构函数。</p><p>错误写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>正确写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>numberArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>numberArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>numberArray</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=a-namea9-4-1a建议941-使用-raii-特性来帮助追踪动态分配><a name=a9-4-1></a>建议9.4.1 使用 RAII 特性来帮助追踪动态分配</h3><p>说明：RAII是“资源获取就是初始化”的缩语(Resource Acquisition Is Initialization)，是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。</p><p>RAII 的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。这种做法有两大好处：</p><ul><li>我们不需要显式地释放资源。</li><li>对象所需的资源在其生命期内始终保持有效。这样，就不必检查资源有效性的问题，可以简化逻辑、提高效率。</li></ul><p>示例：使用RAII不需要显式地释放互斥资源。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockGuard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span><span class=p>(</span><span class=k>const</span> <span class=n>LockType</span><span class=o>&amp;</span> <span class=n>lockType</span><span class=p>)</span><span class=o>:</span> <span class=n>lock_</span><span class=p>(</span><span class=n>lockType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Acquire</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>LockGuard</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockType</span> <span class=n>lock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockGuard</span> <span class=n>lockGuard</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 操作数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec9-5a标准库><a name=c9-5></a>标准库</h2><p>STL标准模板库在不同产品使用程度不同，这里列出一些基本规则和建议，供各团队参考。</p><h3 id=a-namer9-5-1a规则951-不要保存stdstring的c_str返回的指针><a name=r9-5-1></a>规则9.5.1 不要保存std::string的c_str()返回的指针</h3><p>说明：在C++标准中并未规定string::c_str()指针持久有效，因此特定STL实现完全可以在调用string::c_str()时返回一个临时存储区并很快释放。所以为了保证程序的可移植性，不要保存string::c_str()的结果，而是在每次需要时直接调用。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>  <span class=c1>// 表达式结束以后，name的生命周期还在，指针有效
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果中间调用了string的非const成员函数，导致string被修改，比如operator[], begin()等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 可能会导致text的内容不可用，或者不是原来的字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;2&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 后续使用text指针，其字符串内容不再是&#34;demo&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;demo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>text</span> <span class=o>=</span> <span class=p>(</span><span class=n>name</span> <span class=o>+</span> <span class=n>test</span><span class=p>).</span><span class=n>c_str</span><span class=p>();</span> <span class=c1>// 表达式结束以后，+号产生的临时对象被销毁，指针无效
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 后续使用text指针，其已不再指向合法内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>例外：在少数对性能要求非常高的代码中，为了适配已有的只接受const char*类型入参的函数，可以临时保存string::c_str()返回的指针。但是必须严格保证string对象的生命周期长于所保存指针的生命周期，并且保证在所保存指针的生命周期内，string对象不会被修改。</p><h3 id=a-namea9-5-1a建议951-使用stdstring代替char><a name=a9-5-1></a>建议9.5.1 使用std::string代替char*</h3><p>说明：使用string代替<code>char*</code>有很多优势，比如：</p><ol><li>不用考虑结尾的’\0’；</li><li>可以直接使用+, =, ==等运算符以及其它字符串操作函数；</li><li>不需要考虑内存分配操作，避免了显式的new/delete，以及由此导致的错误；</li></ol><p>需要注意的是某些stl实现中string是基于写时复制策略的，这会带来2个问题，一是某些版本的写时复制策略没有实现线程安全，在多线程环境下会引起程序崩溃；二是当与动态链接库相互传递基于写时复制策略的string时，由于引用计数在动态链接库被卸载时无法减少可能导致悬挂指针。因此，慎重选择一个可靠的stl实现对于保证程序稳定是很重要的。</p><p>例外：
当调用系统或者其它第三方库的API时，针对已经定义好的接口，只能使用<code>char*</code>。但是在调用接口之前都可以使用string，在调用接口时使用string::c_str()获得字符指针。
当在栈上分配字符数组当作缓冲区使用时，可以直接定义字符数组，不要使用string，也没有必要使用类似<code>vector&lt;char></code>等容器。</p><h3 id=a-namer9-5-2a规则952-禁止使用auto_ptr><a name=r9-5-2></a>规则9.5.2 禁止使用auto_ptr</h3><p>说明：在stl库中的std::auto_ptr具有一个隐式的所有权转移行为，如下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span>
</span></span></code></pre></div><p>当执行完第2行语句后，p1已经不再指向第1行中分配的对象，而是变为nullptr。正因为如此，auto_ptr不能被置于各种标准容器中。
转移所有权的行为通常不是期望的结果。对于必须转移所有权的场景，也不应该使用隐式转移的方式。这往往需要程序员对使用auto_ptr的代码保持额外的谨慎，否则出现对空指针的访问。
使用auto_ptr常见的有两种场景，一是作为智能指针传递到产生auto_ptr的函数外部，二是使用auto_ptr作为RAII管理类，在超出auto_ptr的生命周期时自动释放资源。
对于第1种场景，可以使用std::shared_ptr来代替。
对于第2种场景，可以使用C++11标准中的std::unique_ptr来代替。其中std::unique_ptr是std::auto_ptr的代替品，支持显式的所有权转移。</p><p>例外：
在C++11标准得到普遍使用之前，在一定需要对所有权进行转移的场景下，可以使用std::auto_ptr，但是建议对std::auto_ptr进行封装，并禁用封装类的拷贝构造函数和赋值运算符，以使该封装类无法用于标准容器。</p><h3 id=a-namea9-5-2a建议952-使用新的标准头文件><a name=a9-5-2></a>建议9.5.2 使用新的标准头文件</h3><p>说明：
使用C++的标准头文件时，请使用<code>&lt;cstdlib></code>这样的，而不是<code>&lt;stdlib.h></code>这种的。</p><h2 id=a-namec9-6a-const的用法><a name=c9-6></a>const的用法</h2><p>在声明的变量或参数前加上关键字 const 用于指明变量值不可被篡改 (如 <code>const int foo</code> ). 为类中的函数加上 const 限定符表明该函数不会修改类成员变量的状态 (如 <code>class Foo { int Bar(char c) const; };</code>)。 const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障， 便于尽早发现错误。因此, 我们强烈建议在任何可能的情况下使用 const。
有时候，使用C++11的constexpr来定义真正的常量可能更好。</p><h3 id=a-namer9-6-1a规则961-对于指针和引用类型的形参如果是不需要修改的请使用const><a name=r9-6-1></a>规则9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用const</h3><p>不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PrintFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>foo</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=a-namer9-6-2a规则962-对于不会修改成员变量的成员函数请使用const修饰><a name=r9-6-2></a>规则9.6.2 对于不会修改成员变量的成员函数请使用const修饰</h3><p>尽可能将成员函数声明为 const。 访问函数应该总是 const。只要不修改数据成员的成员函数，都声明为const。
对于虚函数，应当从设计意图上考虑继承链上的所有类是否需要在此虚函数中修改数据成员，而不是仅关注单个类的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>PrintValue</span><span class=p>()</span> <span class=k>const</span> <span class=c1>// const修饰成员函数，不会修改成员变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value_</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetValue</span><span class=p>()</span> <span class=k>const</span>  <span class=c1>// const修饰成员函数，不会修改成员变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namea9-6-1a建议961-初始化后不会再修改的成员变量定义为const><a name=a9-6-1></a>建议9.6.1 初始化后不会再修改的成员变量定义为const</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span> <span class=n>dataLength_</span><span class=p>(</span><span class=n>length</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>dataLength_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=a-namec9-7a-异常><a name=c9-7></a>异常</h2><h3 id=a-namea9-7-1a建议971-c11中如果函数不会抛出异常声明为noexcept><a name=a9-7-1></a>建议9.7.1 C++11中，如果函数不会抛出异常，声明为<code>noexcept</code></h3><p><strong>理由</strong></p><ol><li>如果函数不会抛出异常，声明为<code>noexcept</code>可以让编译器最大程度的优化函数，如减少执行路径，提高错误退出的效率。</li><li><code>vector</code>等STL容器，为了保证接口的健壮性，如果保存元素的<code>move运算符</code>没有声明为<code>noexcept</code>，则在容器扩张搬移元素时不会使用<code>move机制</code>，而使用<code>copy机制</code>，带来性能损失的风险。如果一个函数不能抛出异常，或者一个程序并没有截获某个函数所抛出的异常并进行处理，那么这个函数可以用新的<code>noexcept</code>关键字对其进行修饰，表示这个函数不会抛出异常或者抛出的异常不会被截获并处理。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>double</span> <span class=n>sqrt</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>  <span class=c1>// 永远不会抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 即使可能抛出异常，也可以使用 noexcept
</span></span></span><span class=line><span class=cl><span class=c1>// 这里不准备处理内存耗尽的异常，简单地将函数声明为noexcept
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>MyComputation</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>noexcept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>    <span class=c1>// 可能会抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>   <span class=c1>// 最大的优化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>RetType</span> <span class=nf>Function</span><span class=p>(</span><span class=n>Type</span> <span class=n>params</span><span class=p>);</span>            <span class=c1>// 更少的优化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// std::vector 的 move 操作需要声明 noexcept
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo1</span><span class=p>(</span><span class=n>Foo1</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>);</span>  <span class=c1>// no noexcept
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo1</span><span class=o>&gt;</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo1</span><span class=p>());</span>  <span class=c1>// 触发容器扩张，搬移已有元素时调用copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo2</span><span class=p>(</span><span class=n>Foo2</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo2</span><span class=o>&gt;</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>a2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Foo2</span><span class=p>());</span>  <span class=c1>// 触发容器扩张，搬移已有元素时调用move constructor
</span></span></span></code></pre></div><p><strong>注意</strong>
默认构造函数、析构函数、<code>swap</code>函数，<code>move操作符</code>都不应该抛出异常。</p><h2 id=a-namec9-8a-模板与泛型编程><a name=c9-8></a>模板与泛型编程</h2><h3 id=a-namea9-8-1a规则981-禁止在openharmony项目中进行泛型编程><a name=a9-8-1></a>规则9.8.1 禁止在OpenHarmony项目中进行泛型编程</h3><p>泛型编程和面向对象编程的思想、理念以及技巧完全不同，OpenHarmony项目主流使用面向对象的思想。</p><p>C++提供了强大的泛型编程的机制，能够实现非常灵活简洁的类型安全的接口，实现类型不同但是行为相同的代码复用。</p><p>但是C++泛型编程存在以下缺点：</p><ol><li>对泛型编程不很熟练的人，常常会将面向对象的逻辑写成模板、将不依赖模板参数的成员写在模板中等等导致逻辑混乱代码膨胀诸多问题。</li><li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩难懂的。在复杂的地方使用模板的代码让人更不容易读懂，并且debug 和维护起来都很麻烦。</li><li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解。</li><li>模板如果使用不当，会导致运行时代码过度膨胀。</li><li>模板代码难以修改和重构。模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用。</li></ol><p>所以，OpenHarmony大部分部件禁止模板编程，仅有 <strong>少数部件</strong> 可以使用泛型编程，并且开发的模板要有详细的注释。
例外：</p><ol><li>stl适配层可以使用模板</li></ol><h2 id=a-namec9-9a-宏><a name=c9-9></a>宏</h2><p>在C++语言中，我们强烈建议尽可能少使用复杂的宏</p><ul><li>对于常量定义，请按照前面章节所述，使用const或者枚举；</li><li>对于宏函数，尽可能简单，并且遵循下面的原则，并且优先使用内联函数，模板函数等进行替换。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不推荐使用宏函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SQUARE(a, b) ((a) * (b))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 请使用模板函数，内联函数等来替换。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=n>Square</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><p>如果需要使用宏，请参考C语言规范的相关章节。
<strong>例外</strong>：一些通用且成熟的应用，如：对 new, delete 的封装处理，可以保留对宏的使用。</p><h1 id=a-namec10a-10-现代c特性><a name=c10></a>10 现代C++特性</h1><p>随着 ISO 在2011年发布 C++11 语言标准，以及2017年3月发布 C++17 ，现代C++(C++11/14/17等)增加了大量提高编程效率、代码质量的新语言特性和标准库。
本章节描述了一些可以帮助团队更有效率的使用现代C++，规避语言陷阱的指导意见。</p><h2 id=a-namec10-1a-代码简洁性和安全性提升><a name=c10-1></a>代码简洁性和安全性提升</h2><h3 id=a-namea10-1-1a建议1011-合理使用auto><a name=a10-1-1></a>建议10.1.1 合理使用<code>auto</code></h3><p><strong>理由</strong></p><ul><li><code>auto</code>可以避免编写冗长、重复的类型名，也可以保证定义变量时初始化。</li><li><code>auto</code>类型推导规则复杂，需要仔细理解。</li><li>如果能够使代码更清晰，继续使用明确的类型，且只在局部变量使用<code>auto</code>。</li></ul><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 避免冗长的类型名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 避免重复类型名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 保证初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// 编译正确，没有初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>x</span><span class=p>;</span>   <span class=c1>// 编译失败，必须初始化
</span></span></span></code></pre></div><p>auto 的类型推导可能导致困惑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>           <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>ca</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>    <span class=c1>// const int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>   <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>aa</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>         <span class=c1>// int, 忽略 const 和 reference
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>ila1</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>   <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>ila2</span><span class=p>{</span> <span class=mi>10</span> <span class=p>};</span>      <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura1</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>      <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura2</span> <span class=o>=</span> <span class=n>ca</span><span class=p>;</span>     <span class=c1>// const int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ura3</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>// int&amp;&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>arr1</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>        <span class=c1>// const int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;</span> <span class=n>arr2</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>       <span class=c1>// const int(&amp;)[10]
</span></span></span></code></pre></div><p>如果没有注意 <code>auto</code> 类型推导时忽略引用，可能引入难以发现的性能问题:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>  <span class=c1>// auto 推导为 std::string，拷贝 v[0]
</span></span></span></code></pre></div><p>如果使用<code>auto</code>定义接口，如头文件中的常量，可能因为开发人员修改了值，而导致类型发生变化。</p><h3 id=a-namer10-1-1a规则1011-在重写虚函数时请使用override或final关键字><a name=r10-1-1></a>规则10.1.1 在重写虚函数时请使用<code>override</code>或<code>final</code>关键字</h3><p><strong>理由</strong>
<code>override</code>和<code>final</code>关键字都能保证函数是虚函数，且重写了基类的虚函数。如果子类函数与基类函数原型不一致，则产生编译告警。<code>final</code>还保证虚函数不会再被子类重写。</p><p>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类虚函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现。也可以避免有多个子类时，重写虚函数的修改遗漏。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// 编译失败: Derived::Foo 和 Base::Foo 原型不一致，不是重写
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 正确: Derived::Foo 重写 Base::Foo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=k>final</span><span class=p>;</span>   <span class=c1>// 正确: Derived::Foo(int) 重写 Base::Foo(int)，且Derived的派生类不能再重写此函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>       <span class=c1>// 编译失败: Base::Bar 不是虚函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p><strong>总结</strong></p><ol><li>基类首次定义虚函数，使用<code>virtual</code>关键字</li><li>子类重写基类虚函数（包括析构函数），使用<code>override</code>或<code>final</code>关键字（但不要两者一起使用），并且不使用<code>virtual</code>关键字</li><li>非虚函数，<code>virtual</code>、<code>override</code>和<code>final</code>都不使用</li></ol><h3 id=a-namer10-1-2a规则1012-使用delete关键字删除函数><a name=r10-1-2></a>规则10.1.2 使用<code>delete</code>关键字删除函数</h3><p><strong>理由</strong>
相比于将类成员函数声明为<code>private</code>但不实现，<code>delete</code>关键字更明确，且适用范围更广。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 只看头文件不知道拷贝构造是否被删除
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 明确删除拷贝赋值函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>delete</code>关键字还支持删除非成员函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Process</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=a-namer10-1-3a规则1013-使用nullptr而不是null或0><a name=r10-1-3></a>规则10.1.3 使用<code>nullptr</code>，而不是<code>NULL</code>或<code>0</code></h3><p><strong>理由</strong>
长期以来，C++没有一个代表空指针的关键字，这是一件很尴尬的事：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NULL ((void *)0)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// 错误: void* 不能自动转换为 char*
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=p>(</span><span class=n>C</span><span class=o>::*</span><span class=n>pmf</span><span class=p>)()</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>C</span><span class=o>::</span><span class=n>Func</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pmf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 错误: void* 不能自动转换为指向成员函数的指针
</span></span></span></code></pre></div><p>如果把<code>NULL</code>被定义为<code>0</code>或<code>0L</code>。可以解决上面的问题。</p><p>或者在需要空指针的地方直接使用<code>0</code>。但这引入另一个问题，代码不清晰，特别是使用<code>auto</code>自动推导：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() 返回的是 指针 还是 整数?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>0</code>字面上是<code>int</code>类型(<code>0L</code>是<code>long</code>)，所以<code>NULL</code>和<code>0</code>都不是指针类型。
当重载指针和整数类型的函数时，传递<code>NULL</code>或<code>0</code>都调用到整数类型重载的函数:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>      <span class=c1>// 调用 F(int)，而非 F(int*)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>   <span class=c1>// 调用 F(int)，而非 F(int*)
</span></span></span></code></pre></div><p>另外，<code>sizeof(NULL) == sizeof(void*)</code>并不一定总是成立的，这也是一个潜在的风险。</p><p>总结： 直接使用<code>0</code>或<code>0L</code>，代码不清晰，且无法做到类型安全；使用<code>NULL</code>无法做到类型安全。这些都是潜在的风险。</p><p><code>nullptr</code>的优势不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。</p><p><code>nullptr</code>是<code>std::nullptr_t</code>类型，而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// 调用 F(int*)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// Find() 返回的是 指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namer10-1-4a规则1014-使用using而非typedef><a name=r10-1-4></a>规则10.1.4 使用<code>using</code>而非<code>typedef</code></h3><p>在<code>C++11</code>之前，可以通过<code>typedef</code>定义类型的别名。没人愿意多次重复<code>std::map&lt;uint32_t, std::vector&lt;int>></code>这样的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>SomeType</span><span class=p>;</span>
</span></span></code></pre></div><p>类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。
在<code>C++11</code>之后，提供<code>using</code>，实现<code>声明别名(alias declarations)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>SomeType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>对比两者的格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Type</span> <span class=n>Alias</span><span class=p>;</span>   <span class=c1>// Type 在前，还是 Alias 在前
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>Alias</span> <span class=o>=</span> <span class=n>Type</span><span class=p>;</span>   <span class=c1>// 符合&#39;赋值&#39;的用法，容易理解，不易出错
</span></span></span></code></pre></div><p>如果觉得这点还不足以切换到<code>using</code>，我们接着看看<code>模板别名(alias template)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 定义模板的别名，一行代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyAllocatorVector</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>       <span class=c1>// 使用 using 定义的别名
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data_</span><span class=p>;</span>   <span class=c1>// 模板类中使用 using 定义的别名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>而<code>typedef</code>不支持带模板参数的别名，只能"曲线救国&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 通过模板包装 typedef，需要实现一个模板类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyAllocatorVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>MyAllocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// 使用 typedef 定义的别名，多写 ::type
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>MyAllocatorVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>data_</span><span class=p>;</span>  <span class=c1>// 模板类中使用，除了 ::type，还需要加上 typename
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namer10-1-5a规则1015-禁止使用stdmove操作const对象><a name=r10-1-5></a>规则10.1.5 禁止使用std::move操作const对象</h3><p>从字面上看，<code>std::move</code>的意思是要移动一个对象。而const对象是不允许修改的，自然也无法移动。因此用<code>std::move</code>操作const对象会给代码阅读者带来困惑。
在实际功能上，<code>std::move</code>会把对象转换成右值引用类型；对于const对象，会将其转换成const的右值引用。由于极少有类型会定义以const右值引用为参数的移动构造函数和移动赋值操作符，因此代码实际功能往往退化成了对象拷贝而不是对象移动，带来了性能上的损失。</p><p><strong>错误示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>g_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>g_stringList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>myString</span> <span class=o>=</span> <span class=s>&#34;String content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>myString</span><span class=p>);</span> <span class=c1>// bad:并没有移动myString，而是进行了复制
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=s>&#34;Another string content&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>g_stringList</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>anotherString</span><span class=p>));</span>    <span class=c1>// bad:并没有移动anotherString，而是进行了复制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=a-namec10-2a-智能指针><a name=c10-2></a>智能指针</h2><h3 id=a-namer10-2-1a规则1021-单例类的成员等所有权不会被多方持有的优先使用原始指针而不是智能指针><a name=r10-2-1></a>规则10.2.1 单例、类的成员等所有权不会被多方持有的优先使用原始指针而不是智能指针</h3><p><strong>理由</strong>
智能指针会自动释放对象资源避免资源泄露，但会带额外的资源开销。如：智能指针自动生成的类、构造和析构的开销、内存占用多等。</p><p>单例、类的成员等对象的所有权不会被多方持有的情况，仅在类析构中释放资源即可。不应该使用智能指针增加额外的开销。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>foo_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>*</span> <span class=n>foo_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>例外</strong></p><ol><li>返回创建的对象时，需要指针销毁函数的可以使用智能指针。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>CreateUniqueUser</span><span class=p>()</span> <span class=c1>// 可使用unique_ptr保证对象的创建和释放在同一runtime
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=n>User</span> <span class=o>*</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=o>::</span><span class=k>new</span> <span class=n>User</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>),</span> <span class=p>[](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>user</span><span class=o>-&gt;</span><span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>::</span><span class=k>delete</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>CreateSharedUser</span><span class=p>()</span> <span class=c1>// 可使用shared_ptr保证对象的创建和释放在同一runtime中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>ipcUser</span> <span class=o>=</span> <span class=n>iface_cast</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>remoter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span><span class=p>(</span><span class=n>ipcUser</span><span class=p>.</span><span class=n>GetRefPtr</span><span class=p>(),</span> <span class=p>[</span><span class=n>ipcUser</span><span class=p>](</span><span class=n>User</span> <span class=o>*</span><span class=n>user</span><span class=p>)</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ipcUser</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>返回创建的对象且对象需要被多方引用时，可以使用shared_ptr。</li></ol><h3 id=a-namer10-2-2a规则1022-使用stdmake_unique而不是new创建unique_ptr><a name=r10-2-2></a>规则10.2.2 使用<code>std::make_unique</code>而不是<code>new</code>创建<code>unique_ptr</code></h3><p><strong>理由</strong></p><ol><li><code>make_unique</code>提供了更简洁的创建方式</li><li>保证了复杂表达式的异常安全</li></ol><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好：两次出现 MyClass，重复导致不一致风险
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>MyClass</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 好：只出现一次 MyClass，不存在不一致的可能
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyClass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>重复出现类型可能导致非常严重的问题，且很难发现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 编译正确，但new和delete不配套
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=mi>10</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=kt>uint8_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 非异常安全: 编译器可能按如下顺序计算参数:
</span></span></span><span class=line><span class=cl><span class=c1>// 1. 分配 Foo 的内存,
</span></span></span><span class=line><span class=cl><span class=c1>// 2. 构造 Foo,
</span></span></span><span class=line><span class=cl><span class=c1>// 3. 调用 Bar,
</span></span></span><span class=line><span class=cl><span class=c1>// 4. 构造 unique_ptr&lt;Foo&gt;.
</span></span></span><span class=line><span class=cl><span class=c1>// 如果 Bar 抛出异常, Foo 不会被销毁，产生内存泄露。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>()),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 异常安全: 调用函数不会被打断.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F</span><span class=p>(</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>Bar</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>例外</strong>
<code>std::make_unique</code>不支持自定义<code>deleter</code>。
在需要自定义<code>deleter</code>的场景，建议在自己的命名空间实现定制版本的<code>make_unique</code>。
使用<code>new</code>创建自定义<code>deleter</code>的<code>unique_ptr</code>是最后的选择。</p><h3 id=a-namer10-2-4a规则1024-使用stdmake_shared而不是new创建shared_ptr><a name=r10-2-4></a>规则10.2.4 使用<code>std::make_shared</code>而不是<code>new</code>创建<code>shared_ptr</code></h3><p><strong>理由</strong>
使用<code>std::make_shared</code>除了类似<code>std::make_unique</code>一致性等原因外，还有性能的因素。
<code>std::shared_ptr</code>管理两个实体：</p><ul><li>控制块(存储引用计数，<code>deleter</code>等)</li><li>管理对象</li></ul><p><code>std::make_shared</code>创建<code>std::shared_ptr</code>，会一次性在堆上分配足够容纳控制块和管理对象的内存。而使用<code>std::shared_ptr&lt;MyClass>(new MyClass)</code>创建<code>std::shared_ptr</code>，除了<code>new MyClass</code>会触发一次堆分配外，<code>std::shard_ptr</code>的构造函数还会触发第二次堆分配，产生额外的开销。</p><p><strong>例外</strong>
类似<code>std::make_unique</code>，<code>std::make_shared</code>不支持定制<code>deleter</code></p><h2 id=a-namec10-3a-lambda><a name=c10-3></a>Lambda</h2><h3 id=a-namea10-3-1a建议1031-当函数不能工作时选择使用lambda捕获局部变量或编写局部函数><a name=a10-3-1></a>建议10.3.1 当函数不能工作时选择使用<code>lambda</code>(捕获局部变量，或编写局部函数)</h3><p><strong>理由</strong>
函数无法捕获局部变量或在局部范围内声明；如果需要这些东西，尽可能选择<code>lambda</code>，而不是手写的<code>functor</code>。
另一方面，<code>lambda</code>和<code>functor</code>不会重载；如果需要重载，则使用函数。
如果<code>lambda</code>和函数都可以的场景，则优先使用函数；尽可能使用最简单的工具。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 编写一个只接受 int 或 string 的函数
</span></span></span><span class=line><span class=cl><span class=c1>// -- 重载是自然的选择
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 需要捕获局部状态，或出现在语句或表达式范围
</span></span></span><span class=line><span class=cl><span class=c1>// -- lambda 是自然的选择
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Work</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=n>LotsOfWork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>taskNum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>taskNum</span> <span class=o>&lt;</span> <span class=n>max</span><span class=p>;</span> <span class=o>++</span><span class=n>taskNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pool</span><span class=p>.</span><span class=n>Run</span><span class=p>([</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>]</span> <span class=p>{...});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=a-namer10-3-2a规则1031-非局部范围使用lambdas避免使用按引用捕获><a name=r10-3-2></a>规则10.3.1 非局部范围使用<code>lambdas</code>，避免使用按引用捕获</h3><p><strong>理由</strong>
非局部范围使用<code>lambdas</code>包括返回值，存储在堆上，或者传递给其它线程。局部的指针和引用不应该在它们的范围外存在。<code>lambdas</code>按引用捕获就是把局部对象的引用存储起来。如果这会导致超过局部变量生命周期的引用存在，则不应该按引用捕获。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 按引用捕获 local.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 当函数返回后，local 不再存在，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 因此 Process() 的行为未定义!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 按值捕获 local。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 因为拷贝，Process() 调用过程中，local 总是有效的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>threadPool</span><span class=p>.</span><span class=n>QueueWork</span><span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=n>Process</span><span class=p>(</span><span class=n>local</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-namea10-3-2a建议1032-如果捕获this则显式捕获所有变量><a name=a10-3-2></a>建议10.3.2 如果捕获<code>this</code>，则显式捕获所有变量</h3><p><strong>理由</strong>
在成员函数中的<code>[=]</code>看起来是按值捕获。但因为是隐式的按值获取了<code>this</code>指针，并能够操作所有成员变量，数据成员实际是按引用捕获的，一般情况下建议避免。如果的确需要这样做，明确写出对<code>this</code>的捕获。</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span>   <span class=c1>// 不好: 看起来像是拷贝/按值捕获，成员变量实际上是按引用捕获
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// 调用 use(42);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>data_</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Lambda</span><span class=p>();</span> <span class=c1>// 调用 use(43);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>Lambda2</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=k>this</span><span class=p>]()</span> <span class=p>{</span> <span class=n>Use</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>data_</span><span class=p>);</span> <span class=p>};</span> <span class=c1>// 好，显式指定按值捕获，最明确，最少的混淆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=a-namea10-3-3a建议1033-避免使用默认捕获模式><a name=a10-3-3></a>建议10.3.3 避免使用默认捕获模式</h3><p><strong>理由</strong>
lambda表达式提供了两种默认捕获模式：按引用（&）和按值（=）。
默认按引用捕获会隐式的捕获所有局部变量的引用，容易导致访问悬空引用。相比之下，显式的写出需要捕获的变量可以更容易的检查对象生命周期，减小犯错可能。
默认按值捕获会隐式的捕获this指针，且难以看出lambda函数所依赖的变量是哪些。如果存在静态变量，还会让阅读者误以为lambda拷贝了一份静态变量。
因此，通常应当明确写出lambda需要捕获的变量，而不是使用默认捕获模式。</p><p><strong>错误示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=p>{</span>  <span class=c1>// 实际上只复制了addend
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 修改会影响静态变量的值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>正确示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>addend</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>addend</span><span class=p>,</span> <span class=n>baseValue</span> <span class=o>=</span> <span class=n>baseValue</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span>  <span class=c1>// 使用C++14的捕获初始化拷贝一份变量
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>baseValue</span><span class=p>;</span>    <span class=c1>// 修改自己的拷贝，不会影响静态变量的值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>baseValue</span> <span class=o>+</span> <span class=n>addend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>参考：《Effective Modern C++》：Item 31: Avoid default capture modes.</p><h2 id=a-namec10-4a-接口><a name=c10-4></a>接口</h2><h3 id=a-namea10-4-1a建议1041-不涉及所有权的场景使用t或t作为参数而不是智能指针><a name=a10-4-1></a>建议10.4.1 不涉及所有权的场景，使用<code>T*</code>或<code>T&</code>作为参数，而不是智能指针</h3><p><strong>理由</strong></p><ol><li>只在需要明确所有权机制时，才通过智能指针转移或共享所有权.</li><li>通过智能指针传递，限制了函数调用者必须使用智能指针(如调用者希望传递<code>this</code>)。</li><li>传递共享所有权的智能指针存在运行时的开销。</li></ol><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 接受任何 int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 只能接受希望转移所有权的 int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 只能接受希望共享所有权的 int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>G</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不改变所有权，但需要特定所有权的调用者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=k>const</span> <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 接受任何 int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>H</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>F</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;&amp;</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Use</span><span class=p>(</span><span class=o>*</span><span class=n>w</span><span class=p>);</span> <span class=c1>// 只使用 w -- 完全不涉及生命周期管理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-d260067c1c520d9cc0388047931880b9>问题定位</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5afb8099be6c39ce4dddecbb6d7c8f42>environment</h1><div class="td-byline mb-4"><time datetime=2024-11-13 class=text-body-secondary>Wednesday, November 13, 2024</time></div></div><div class=td-content><h1 id=pg-d3262c6340c09c138f8830e17cfe7666>虚拟内存磁盘配置</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 虚拟内存磁盘配置</li></ul><h1 id=虚拟内存磁盘配置>虚拟内存磁盘配置</h1><h2 id=浏览器缓存到虚拟磁盘>浏览器缓存到虚拟磁盘</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bat data-lang=bat><span class=line><span class=cl><span class=p>&lt;</span>!-- imdisk --&gt;
</span></span><span class=line><span class=cl><span class=k>rd</span> /q /s <span class=s2>&#34;C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\Cache&#34;</span>
</span></span><span class=line><span class=cl><span class=k>rd</span> /q /s <span class=s2>&#34;C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\Code Cache&#34;</span>
</span></span><span class=line><span class=cl><span class=k>md</span> M:\Edge_Cache\
</span></span><span class=line><span class=cl><span class=k>md</span> M:\Edge_CodeCache\
</span></span><span class=line><span class=cl><span class=k>mklink</span> /D <span class=s2>&#34;C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\Cache&#34;</span> <span class=s2>&#34;M:\Edge_Cache\&#34;</span>
</span></span><span class=line><span class=cl><span class=k>mklink</span> /D <span class=s2>&#34;C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\Code Cache&#34;</span> <span class=s2>&#34;M:\Edge_CodeCache\&#34;</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6fa893880eea41a50f03f1fa6455f490>wsl</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><h1 id=配置-wsl>配置 wsl</h1><ul><li><a href=/blog/2024/06/28/wsl/#配置-wsl>配置 wsl</a><ul><li><a href=/blog/2024/06/28/wsl/#远程访问-ssh>远程访问 ssh</a></li><li><a href=/blog/2024/06/28/wsl/#配置-wsl-1>配置 wsl</a></li></ul></li></ul><h2 id=远程访问-ssh>远程访问 ssh</h2><p><strong>wsl</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo apt install openssh-server
</span></span><span class=line><span class=cl>sudo nano /etc/ssh/sshd_config
</span></span><span class=line><span class=cl>/etc/ssh/sshd_config
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...STUFF ABOVE THIS...
</span></span><span class=line><span class=cl>Port <span class=m>2222</span>
</span></span><span class=line><span class=cl><span class=c1>#AddressFamily any</span>
</span></span><span class=line><span class=cl>ListenAddress 0.0.0.0
</span></span><span class=line><span class=cl><span class=c1>#ListenAddress ::</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...STUFF BELOW  THIS...
</span></span></code></pre></div><p><strong>windows</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=n>service</span> <span class=n>ssh</span> <span class=nb>start
</span></span></span><span class=line><span class=cl><span class=nb></span><span class=n>netsh</span> <span class=n>interface</span> <span class=n>portproxy</span> <span class=n>add</span> <span class=n>v4tov4</span> <span class=n>listenaddress</span><span class=p>=</span><span class=mf>0.0</span><span class=p>.</span><span class=py>0</span><span class=p>.</span><span class=py>0</span> <span class=n>listenport</span><span class=p>=</span><span class=mf>2222</span> <span class=n>connectaddress</span><span class=p>=</span><span class=mf>172.23</span><span class=p>.</span><span class=py>129</span><span class=p>.</span><span class=py>80</span> <span class=n>connectport</span><span class=p>=</span><span class=mf>2222</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>firewall</span> <span class=n>add</span> <span class=n>rule</span> <span class=n>name</span><span class=p>=</span><span class=s2>&#34;Open Port 2222 for WSL2&#34;</span> <span class=n>dir</span><span class=p>=</span><span class=k>in</span> <span class=n>action</span><span class=p>=</span><span class=n>allow</span> <span class=n>protocol</span><span class=p>=</span><span class=n>TCP</span> <span class=n>localport</span><span class=p>=</span><span class=mf>2222</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>interface</span> <span class=n>portproxy</span> <span class=n>show</span> <span class=n>v4tov4</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>int</span> <span class=n>portproxy</span> <span class=n>reset</span> <span class=n>all</span>
</span></span></code></pre></div><h2 id=配置-wsl-1>配置 wsl</h2><p><a href=https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configuration-setting-for-wslconfig>https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configuration-setting-for-wslconfig</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=nb>Set-Content</span> <span class=n>-Path</span> <span class=s2>&#34;</span><span class=nv>$env:userprofile</span><span class=s2>\\.wslconfig&#34;</span> <span class=n>-Value</span> <span class=s2>&#34;
</span></span></span><span class=line><span class=cl><span class=s2># Settings apply across all Linux distros running on WSL 2
</span></span></span><span class=line><span class=cl><span class=s2>[wsl2]
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB
</span></span></span><span class=line><span class=cl><span class=s2>memory=2GB
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Sets the VM to use two virtual processors
</span></span></span><span class=line><span class=cl><span class=s2>processors=2
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel
</span></span></span><span class=line><span class=cl><span class=s2># kernel=C:\\temp\\myCustomKernel
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6
</span></span></span><span class=line><span class=cl><span class=s2># kernelCommandLine = vsyscall=emulate
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Sets amount of swap storage space to 8GB, default is 25% of available RAM
</span></span></span><span class=line><span class=cl><span class=s2>swap=1GB
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx
</span></span></span><span class=line><span class=cl><span class=s2>swapfile=C:\\temp\\wsl-swap.vhdx
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free
</span></span></span><span class=line><span class=cl><span class=s2>pageReporting=false
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Turn off default connection to bind WSL 2 localhost to Windows localhost
</span></span></span><span class=line><span class=cl><span class=s2>localhostforwarding=true
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Disables nested virtualization
</span></span></span><span class=line><span class=cl><span class=s2>nestedVirtualization=false
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging
</span></span></span><span class=line><span class=cl><span class=s2>debugConsole=true
</span></span></span><span class=line><span class=cl><span class=s2>&#34;</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6617997f4122afb177edebfea3b07572>vs-remote-debug</h1><div class="td-byline mb-4"><time datetime=2022-11-13 class=text-body-secondary>Sunday, November 13, 2022</time></div><h1 id=remote-debug-with-visual-studio>remote debug with visual studio</h1><p>远程调试 C++:
<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019</a></p><p>Attach 调试:
<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019</a></p><p>配置联调程序为 service:
<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019#bkmk_configureService">https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019#bkmk_configureService</a></p><p>如何配置启动参数:
<a href=https://stackoverflow.com/questions/6740422/visual-studio-remote-debugging-a-service>https://stackoverflow.com/questions/6740422/visual-studio-remote-debugging-a-service</a></p><p>可用参数:
<a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/174c2039-b316-455a-800e-18c0d93b74bc/visual-studio-2010-remote-debugger-settings-dont-persist?forum=vsdebug">https://social.msdn.microsoft.com/Forums/vstudio/en-US/174c2039-b316-455a-800e-18c0d93b74bc/visual-studio-2010-remote-debugger-settings-dont-persist?forum=vsdebug</a></p><p>自己添加任务</p><p><code>"C:\Program Files\Microsoft Visual Studio 16.0\Common7\IDE\Remote Debugger\x64\msvsmon.exe"</code></p><p>启动参数</p><p><code>/noauth /anyuser /port:4045 /nosecuritywarn /timeout 360000</code></p><p>开发机连接: <code>test0.example.com:4045</code></p><p>远程访问(需提前开启开发者模式): <code>http://test0.example.com:50080/</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-125b181c6e3c8f5fe9891c1835c9b2b7>vscode</h1><div class="td-byline mb-4"><time datetime=2024-11-13 class=text-body-secondary>Wednesday, November 13, 2024</time></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ca251b26ebf6248b9dd287928b686a42>OS</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div></div><div class=td-content><h1 id=pg-4c9ceb39a2e6db0c11cf6dea08bd5472>linux</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> _index</li></ul></div><div class=td-content><h1 id=pg-857dd99748f3a61de100fe2e04bba847>linux导览</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><p><input disabled type=checkbox> linux导览</p></li><li><p>[<a href=%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91 title=内核模块开发>内核模块开发</a>]</p></li><li><p>[<a href=linux%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%A9%E5%86%99 title=linux源码中的一些缩写>linux源码中的一些缩写</a>]</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1f064054229b961c68c0b418618cbc82>windows</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div></div><div class=td-content><h1 id=pg-feed9e21730b5856a268e31d6db06c37>理解Windows网络_WFP</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 理解Windows网络_WFP</li></ul><h1 id=理解-windows-网络>理解 Windows 网络</h1><ul><li><input disabled type=checkbox> 理解 Windows 网络</li></ul><h2 id=wfp>WFP</h2><h3 id=名词解释>名词解释</h3><p><a href=https://learn.microsoft.com/en-us/windows/win32/fwp/object-model>https://learn.microsoft.com/en-us/windows/win32/fwp/object-model</a>
<a href=https://learn.microsoft.com/en-us/windows/win32/fwp/basic-operation>https://learn.microsoft.com/en-us/windows/win32/fwp/basic-operation</a>
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network>https://learn.microsoft.com/en-us/windows-hardware/drivers/network</a></p><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/callout>callout</a>: A callout provides functionality that extends the capabilities of the Windows Filtering Platform. A callout consists of a set of callout functions and a GUID key that uniquely identifies the callout.
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/callout-driver>callout driver</a>: A callout driver is a driver that registers callouts with the Windows Filtering Platform. A callout driver is a type of filter driver.
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/callout-function>callout function</a>: A callout function is a function that is called by the Windows Filtering Platform to perform a specific task. A callout function is associated with a callout.
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/filter>filter</a>: A filter is a set of functions that are called by the Windows Filtering Platform to perform filtering operations. A filter consists of a set of filter functions and a GUID key that uniquely identifies the filter.
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/filter-engine>filter engine</a>: The filter engine is the component of the Windows Filtering Platform that performs filtering operations. The filter engine is responsible for calling the filter functions that are registered with the Windows Filtering Platform.
<a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/network/filter-layer>filter layer</a>: A filter layer is a set of functions that are called by the Windows Filtering Platform to perform filtering operations. A filter layer consists of a set of filter layer functions and a GUID key that uniquely identifies the filter layer.</p><p>Dispatcher队列触发回调是尽快触发形式, 不需要等队列满, 因此可以满足实时性.
当用户回调较慢时, 阻塞的报文会尽可能插入下个队列, 队列上限256. 更多的阻塞报文则由系统缓存, 粗略的测试缓存能力是16500, 系统缓存能力可能随机器性能和配置不同存在差异.
用户回调处理报文时, 存在两份报文实体:
内核报文, 在回调处理完队列后一并释放. 因此回调较慢时, 一次回调执行会最多锁定系统256个报文的缓存能力.
回调中的拷贝, 处理完单个报文后立即释放.</p><p>在FwppNetEvent1Callback中对报文进行拷贝组装, 不会操作原始报文, 对业务没有影响.</p><p>订阅可以使用模板过滤器, 以减少需要处理的报文:</p><p><a href=https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_net_event_enum_template0>https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_net_event_enum_template0</a></p><p>filterCondition</p><p>An array of FWPM_FILTER_CONDITION0 structures that contain distinct filter conditions (duplicated filter conditions will generate an error). All conditions must be true for the action to be performed. In other words, the conditions are AND&rsquo;ed together. If no conditions are specified, the action is always performed.</p><p>不可使用相同的filter
所有过滤器间的关系是"与", 需要全都满足
微软文档显示支持的过滤器有八种, 实际上支持的过滤器会更多.</p><p>FWPM_CONDITION_IP_PROTOCOL</p><p>The IP protocol number, as specified in RFC 1700.
FWPM_CONDITION_IP_LOCAL_ADDRESS</p><p>The local IP address.
FWPM_CONDITION_IP_REMOTE_ADDRESS</p><p>The remote IP address.
FWPM_CONDITION_IP_LOCAL_PORT</p><p>The local transport protocol port number. For ICMP, the message type.
FWPM_CONDITION_IP_REMOTE_PORT</p><p>The remote transport protocol port number. For ICMP, the message code.
FWPM_CONDITION_SCOPE_ID</p><p>The interface IPv6 scope identifier. Reserved for internal use.
FWPM_CONDITION_ALE_APP_ID</p><p>The full path of the application.
FWPM_CONDITION_ALE_USER_ID</p><p>The identification of the local user.
枚举系统已注册的订阅发现已有两个订阅, 查看其sessionKey GUID无法确认由谁注册, 对其进行分析发现两个订阅各自实现了以下功能:</p><p>订阅了所有FWPM_NET_EVENT_TYPE_CLASSIFY_DROP的数据包, 统计了所有被丢弃的包.
订阅了所有FWPM_NET_EVENT_TYPE_CLASSIFY_ALLOW的数据包, 可以用来做流量统计
这两个订阅用到的contition filter都是FWPM_CONDITION_NET_EVENT_TYPE(206e9996-490e-40cf-b831-b38641eb6fcb), 说明可以实现过滤的filter不止微软文档中提到的8个.</p><p>更多调研发现用户态调用接口仅能捕获drop的事件, 非drop事件需要使用内核模式获取, 因此微隔离不能使用FWPM_CONDITION_NET_EVENT_TYPE获取事件.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-021d3a093eb8786e8c11c6673103012b>理解Windows事件跟踪_ETW</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> 理解Windows事件跟踪_ETW</li></ul><h1 id=理解-etw>理解 ETW</h1><p>筛除了一些不必要的信息, 完整文档参阅: <a href=https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal>https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal</a></p><h2 id=理解基础>理解基础</h2><p><a href=https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing>https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing</a></p><p><img alt=架构 src=https://learn.microsoft.com/en-us/windows/win32/etw/images/etdiag2.png></p><h2 id=session>Session</h2><p>存在四种 session</p><table><thead><tr><th>session 种类</th><th>使用</th><th>限制</th><th>特点</th></tr></thead><tbody><tr><td><a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-an-event-tracing-session>Event Tracing Session</a>(Standard ETW)</td><td>1. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties>EVENT_TRACE_PROPERTIES</a>2. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-starttracea>StartTrace</a>, 创建 session3. EnableTrace 1. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletrace>EnableTrace</a> for classic provider 2. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletraceex>EnableTraceEx</a> for manifest-based provider4. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracea>ControlTrace</a>  停止 session</td><td>- 一个 manifest-based provider 仅支持提供事件到至多 8 个 session- 一个 classic provider, 仅能服务一个 session.- session 抢占 provider 行为是后来居上.</td><td>标准 ETW.</td></tr><tr><td><a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-a-systemtraceprovider-session>SystemTraceProvider Session</a></td><td>1. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties>EVENT_TRACE_PROPERTIES</a>-><strong>EnableFlags</strong>2. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-starttracea>StartTrace</a>3. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracea>ControlTrace</a>  停止 session</td><td>- **SystemTraceProvider **是一个内核事件 provider, 提供一套<a href=https://learn.microsoft.com/en-us/windows/win32/etw/nt-kernel-logger-constants>预定义的内核事件</a>.- <strong><a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session>NT Kernel Logger session</a><strong>是系统预置 session, 记录一系列系统预定义的内核事件- <strong>Win7/WinServer2008R2</strong>仅 NT Kernel Logger session 可使用 SystemTraceProvider - <strong>Win8/WinServer2012</strong>的 SystemTraceProvider 可以提供事件给</strong>8 个 logger session</strong>, 其中两个固定为 NT Kernel Logger 和 Circular Kernel Context Logger.- <strong>Win10 20348</strong>之后, 各 Systerm provider 可以被单独控制.</td><td>获取系统内核预定义事件.</td></tr><tr><td><a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-an-autologger-session>AutoLogger session</a></td><td>1. 修改注册表 2. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletraceex>EnableTraceEx</a>3. <a href=https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracea>ControlTrace</a>  停止 session</td><td>- **<a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-the-global-logger-session>Global Logger Session</a>**是特殊独立的 session, 记录系统启动时事件.- 普通 AutoLogger 需要自行使能 provider, GlobleLogger 不需要.- AutoLogger 不支持 NT Kernel Logger 事件, 仅 GlobalLogger 支持.- 影响启动时间, 节制使用</td><td>记录操作系统启动期间事件</td></tr><tr><td><a href=https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-a-private-logger-session>Private Logger Session</a></td><td>-</td><td>- User-mode ETW- 仅进程内使用- 不计入 64 session 并行限制.</td><td>进程私有</td></tr></tbody></table><h2 id=工具>工具</h2><ul><li><a href=https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/logman>logman</a></li><li><a href=https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wevtutil>wevtutil</a><ul><li>xpath 查询实例: <code>wevtutil qe Security /c:2 /q:"*[System[EventID=5157]]" /f:text</code></li></ul></li><li><a href=https://learn.microsoft.com/zh-cn/windows-hardware/drivers/devtest/tracelog>tracelog</a><ul><li>使用 viusal studio 的<code>tracelog</code>工具, 可以在运行时动态的添加和删除 ETW Provider, 以及动态的添加和删除 ETW Session</li></ul></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/wes/message-compiler--mc-exe->mc</a></li><li><a href=https://github.com/repnz/etw-providers-docs>etw-providers-docs</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2ff6fe9b17c0d87d77c11f27a7fa527c>wireguard配置</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> wireguard配置</li></ul><h1 id=wireguard-配置>wireguard 配置</h1><h2 id=防火墙配置>防火墙配置</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=n>wireguard</span> <span class=p>/</span><span class=n>installtunnelservice</span> <span class=p>&lt;</span><span class=n>wg_conf_path</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>wg</span> <span class=n>show</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetConnectionProfile</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetAdapter</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetFirewallProfile</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetFirewallProfile</span> <span class=n>-Profile</span> <span class=n>domain</span><span class=p>,</span><span class=n>public</span><span class=p>,</span><span class=n>private</span> <span class=n>-DisabledInterfaceAliases</span> <span class=p>&lt;</span><span class=n>wg_config_name</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPInterface</span> <span class=n>-ifindex</span> <span class=p>&lt;</span><span class=n>interface</span> <span class=n>index</span><span class=p>&gt;</span> <span class=n>-Forwarding</span> <span class=n>Enabled</span>
</span></span><span class=line><span class=cl><span class=nb>New-NetFirewallRule</span> <span class=n>-DisplayName</span> <span class=s2>&#34;@wg1&#34;</span> <span class=n>-Direction</span> <span class=n>Inbound</span>  <span class=n>-RemoteAddress</span> <span class=mf>10.66</span><span class=p>.</span><span class=py>66</span><span class=p>.</span><span class=mf>1</span><span class=p>/</span><span class=mf>24</span> <span class=n>-Action</span> <span class=n>Allow</span>
</span></span><span class=line><span class=cl><span class=nb>New-NetFirewallRule</span> <span class=n>-DisplayName</span> <span class=s2>&#34;@wg1&#34;</span> <span class=n>-Direction</span> <span class=n>Outbound</span> <span class=n>-RemoteAddress</span> <span class=mf>10.66</span><span class=p>.</span><span class=py>66</span><span class=p>.</span><span class=mf>1</span><span class=p>/</span><span class=mf>24</span> <span class=n>-Action</span> <span class=n>Allow</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=c># 定位拦截原因</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;{0CCE9225-69AE-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>enable</span>
</span></span><span class=line><span class=cl><span class=n>wevtutil</span> <span class=n>qe</span> <span class=n>Security</span> <span class=p>/</span><span class=n>q:</span><span class=s2>&#34;*[System/EventID=5152]&#34;</span> <span class=p>/</span><span class=n>c:</span><span class=mf>5</span> <span class=p>/</span><span class=n>rd</span><span class=err>:</span><span class=n>true</span> <span class=p>/</span><span class=n>f:text</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;{0CCE9225-69AE-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>disable</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6fd322b95dfd6a5f84894ff330485c26>Windows阻断网络流量获取</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Windows阻断网络流量获取</li></ul><h1 id=windows-阻断网络流量获取>Windows 阻断网络流量获取</h1><ul><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-windows-阻断网络流量获取->Windows 阻断网络流量获取</a><ul><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-搭建测试工程->搭建测试工程</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-通过审计获取-block-事件->通过审计获取 block 事件</a><ul><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-获取-provider-信息->获取 provider 信息</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-构造-block-事件->构造 block 事件</a></li></ul></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-监控网络事件net_event->监控网络事件(NET_EVENT)</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-监控网络链接netconnection->监控网络链接(NetConnection)</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-application-layer-enforcementale介绍->Application Layer Enforcement(ALE)介绍</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-编码->编码</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-结论->结论</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-附录->附录</a><ul><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-wfp-体系结构->WFP 体系结构</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-数据流->数据流</a></li><li><a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/#-参考链接->参考链接</a></li></ul></li></ul></li></ul><ul><li>需要识别出被阻断的流量, 被阻断的流量包括出站入站方向.</li><li>阻断的两种形式, 基于链接(connection), 和基于数据包(packet). 数据包的丢弃较为频繁常见, 需要审查丢弃原因, 基于链接的阻断更符合实际需关注的阻断场景.</li><li>许多正常处理的报文也会被 drop, 因此需要区分 drop 和 block 行为, 我们主要关注 block 的情况.</li></ul><h2 id=搭建测试工程>搭建测试工程</h2><p>WFP 主要工作在 usermode, 另一部分在 kernalmode, 能力以驱动形式体现, 搭建测试环境的方法比较复杂. 推荐的方法是测试机使用另一台物理机, 开发机编译好后, 发送至测试机远程调试.
受条件限制, 我们也可以直接在本地进行调试.</p><ul><li><a href=https://github.com/microsoft/Windows-driver-samples>Microsoft WFP Sample 工程</a><ul><li>只关注: Windows-driver-samples\network\trans\WFPSampler</li></ul></li><li><a href=https://docs.microsoft.com/zh-cn/samples/microsoft/windows-driver-samples/windows-filtering-platform-sample/>WFPSampler 工程指导</a></li></ul><p>编译问题:</p><ul><li><a href=https://github.com/microsoft/Windows-driver-samples/pull/538>缺失 api-ms-win-net-isolation-l1-1-0</a></li><li><a href=https://stackoverflow.com/questions/44837612/wfpsampler-compilation-issue-wfpcalloutsclassreg-not-found>wfpcalloutsclassreg-not-found</a></li></ul><p>其它问题:</p><ul><li><a href=https://answers.microsoft.com/en-us/protect/forum/all/your-organization-used-windows-defender/ef12b7be-41f5-4b71-a73c-e4f99ba944f7>驱动程序无法运行</a></li><li><a href=https://stackoverflow.com/questions/84847/how-do-i-create-a-self-signed-certificate-for-code-signing-on-windows>如何签名</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows-hardware/drivers/develop/preparing-a-computer-for-manual-driver-deployment>准备部署的测试机</a></li></ul><h2 id=通过审计获取-block-事件>通过审计获取 block 事件</h2><ul><li><a href=https://docs.microsoft.com/en-us/windows/win32/fwp/auditing-and-logging>Auditing 文档</a></li><li><a href=https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/auditpol>auditpol 文档</a></li></ul><p>默认情况下，禁用对 WFP 的审核。</p><ul><li>可以通过组策略对象编辑器 MMC 管理单元、本地安全策略 MMC 管理单元或 auditpol.exe 命令，按类别(category)启用审核。</li><li>可以通过 auditpol.exe 命令按子类别(subcategory)启用审核。</li><li>应该使用 guid 进行设置, 否则不同语言系统有本地化的问题.</li><li>审计使用循环日志, 128KB 不用担心资源消耗</li></ul><p>类别<a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/auditing-constants>https://docs.microsoft.com/en-us/windows/win32/secauthz/auditing-constants</a></p><table><thead><tr><th>Category/Subcategory</th><th>GUID</th></tr></thead><tbody><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td><strong>Object Access</strong></td><td>{6997984A-797A-11D9-BED3-505054503030}</td></tr><tr><td><strong>Policy Change</strong></td><td>{6997984D-797A-11D9-BED3-505054503030}</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p><strong>Object Access</strong> 子类和对应 GUID <a href=https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpac/77878370-0712-47cd-997d-b07053429f6d>https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpac/77878370-0712-47cd-997d-b07053429f6d</a></p><table><thead><tr><th>Object Access Subcategory</th><th>Subcategory GUID</th><th>Inclusion Setting</th></tr></thead><tbody><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr><tr><td><strong>Filtering Platform Packet Drop</strong></td><td>{0CCE9225-69AE-11D9-BED3-505054503030}</td><td>No Auditing</td></tr><tr><td><strong>Filtering Platform Connection</strong></td><td>{0CCE9226-69AE-11D9-BED3-505054503030}</td><td>No Auditing</td></tr><tr><td><strong>Other Object Access Events</strong></td><td>{0CCE9227-69AE-11D9-BED3-505054503030}</td><td>No Auditing</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p><strong>Policy Change</strong> 子类和对应 GUID:</p><table><thead><tr><th>Policy Change Subcategory</th><th>Subcategory GUID</th></tr></thead><tbody><tr><td><strong>Audit Policy Change</strong></td><td>{0CCE922F-69AE-11D9-BED3-505054503030}</td></tr><tr><td>Authentication Policy Change</td><td>{0CCE9230-69AE-11D9-BED3-505054503030}</td></tr><tr><td>Authorization Policy Change</td><td>{0CCE9231-69AE-11D9-BED3-505054503030}</td></tr><tr><td>MPSSVC Rule-Level Policy Change</td><td>{0CCE9232-69AE-11D9-BED3-505054503030}</td></tr><tr><td><strong>Filtering Platform Policy Change</strong></td><td>{0CCE9233-69AE-11D9-BED3-505054503030}</td></tr><tr><td>Other Policy Change Events</td><td>{0CCE9234-69AE-11D9-BED3-505054503030}</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># auditpol手册参阅: https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/auditpol</span>
</span></span><span class=line><span class=cl><span class=c># 本段主要关注 &#39;Object Access&#39; 类别</span>
</span></span><span class=line><span class=cl><span class=c># 获取可查询的字段</span>
</span></span><span class=line><span class=cl><span class=c># -v 显示GUID, -r显示csv报告</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>list</span> <span class=p>/</span><span class=n>category</span> <span class=p>/</span><span class=n>v</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>list</span> <span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=p>*</span> <span class=p>/</span><span class=n>v</span>
</span></span><span class=line><span class=cl><span class=c># 获取某个子类别的审计设置</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>get</span> <span class=p>/</span><span class=n>category</span><span class=err>:</span><span class=s1>&#39;Object Access&#39;</span> <span class=p>/</span><span class=nb>r </span><span class=p>|</span> <span class=nb>ConvertFrom-Csv</span><span class=p>|</span> <span class=nb>Get-Member</span>
</span></span><span class=line><span class=cl><span class=c># 查询guid</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>get</span> <span class=p>/</span><span class=n>category</span><span class=err>:</span><span class=s1>&#39;Object Access&#39;</span> <span class=p>/</span><span class=nb>r </span><span class=p>|</span> <span class=nb>ConvertFrom-Csv</span><span class=p>|</span> <span class=nb>Format-Table</span> <span class=n>Subcategory</span><span class=p>,</span><span class=s1>&#39;Subcategory GUID&#39;</span><span class=p>,</span><span class=s1>&#39;Inclusion Setting&#39;</span>
</span></span><span class=line><span class=cl><span class=c># 查找subcategory</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>list</span> <span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;Object Access&#34;</span><span class=p>,</span><span class=s2>&#34;Policy Change&#34;</span> <span class=n>-v</span>
</span></span><span class=line><span class=cl><span class=c># 备份</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>backup</span> <span class=p>/</span><span class=n>file</span><span class=err>:</span><span class=n>d:</span><span class=p>\</span><span class=n>audit</span><span class=p>.</span><span class=py>bak</span>
</span></span><span class=line><span class=cl><span class=c># 还原</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>restore</span> <span class=p>/</span><span class=n>file</span><span class=err>:</span><span class=n>d:</span><span class=p>\</span><span class=n>audit</span><span class=p>.</span><span class=py>bak</span>
</span></span><span class=line><span class=cl><span class=c># 修改Policy</span>
</span></span><span class=line><span class=cl><span class=c># **Policy Change**    | {6997984D-797A-11D9-BED3-505054503030}</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>category</span><span class=err>:</span><span class=s2>&#34;{6997984D-797A-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>disable</span>
</span></span><span class=line><span class=cl><span class=c># Filtering Platform Policy Change | {0CCE9233-69AE-11D9-BED3-505054503030}</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;{0CCE9233-69AE-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>enable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>enable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># **Object Access**    | {6997984A-797A-11D9-BED3-505054503030}</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=n>get</span> <span class=p>/</span><span class=n>category</span><span class=err>:</span><span class=s2>&#34;{6997984A-797A-11D9-BED3-505054503030}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>category</span><span class=err>:</span><span class=s2>&#34;{6997984A-797A-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>disable</span>
</span></span><span class=line><span class=cl><span class=c># Filtering Platform Packet Drop | {0CCE9225-69AE-11D9-BED3-505054503030}</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;{0CCE9225-69AE-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>enable</span>
</span></span><span class=line><span class=cl><span class=c># Filtering Platform Connection  | {0CCE9226-69AE-11D9-BED3-505054503030}</span>
</span></span><span class=line><span class=cl><span class=n>auditpol</span> <span class=p>/</span><span class=nb>set </span><span class=p>/</span><span class=n>subcategory</span><span class=err>:</span><span class=s2>&#34;{0CCE9226-69AE-11D9-BED3-505054503030}&#34;</span> <span class=p>/</span><span class=n>success</span><span class=err>:</span><span class=n>disable</span> <span class=p>/</span><span class=n>failure</span><span class=err>:</span><span class=n>enable</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 读取日志</span>
</span></span><span class=line><span class=cl><span class=nv>$Events</span> <span class=p>=</span> <span class=nb>Get-WinEvent</span> <span class=n>-LogName</span> <span class=s1>&#39;Security&#39;</span>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$event</span> <span class=k>in</span> <span class=nv>$Events</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>ForEach</span> <span class=p>(</span><span class=nv>$line</span> <span class=k>in</span> <span class=vm>$</span><span class=p>(</span><span class=nv>$event</span><span class=p>.</span><span class=py>Message</span> <span class=n>-split</span> <span class=s2>&#34;</span><span class=se>`r`n</span><span class=s2>&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>Write-host</span> <span class=nv>$event</span><span class=p>.</span><span class=py>RecordId</span> <span class=s1>&#39;:&#39;</span> <span class=nv>$Line</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>事件说明:</p><table><thead><tr><th>Event ID</th><th>Explanation</th></tr></thead><tbody><tr><td>5031(F)</td><td>The Windows Firewall Service <strong>blocked</strong> an application from accepting incoming connections on the network.</td></tr><tr><td>5150(-)</td><td>The Windows Filtering Platform <strong>blocked</strong> a <strong>packet</strong>.</td></tr><tr><td>5151(-)</td><td>A more restrictive Windows Filtering Platform filter has <strong>blocked</strong> a <strong>packet</strong>.</td></tr><tr><td>5152(F)</td><td>The Windows Filtering Platform <strong>blocked</strong> a <strong>packet</strong>.</td></tr><tr><td>5153(S)</td><td>A more restrictive Windows Filtering Platform filter has <strong>blocked</strong> a <strong>packet</strong>.</td></tr><tr><td>5154(S)</td><td>The Windows Filtering Platform has permitted an application or service to listen on a port for incoming connections.</td></tr><tr><td>5155(F)</td><td>The Windows Filtering Platform has <strong>blocked</strong> an application or service from listening on a port for incoming connections.</td></tr><tr><td>5156(S)</td><td>The Windows Filtering Platform has permitted a connection.</td></tr><tr><td><strong>5157(F)</strong></td><td>The Windows Filtering Platform has <strong>blocked</strong> a connection.</td></tr><tr><td>5158(S)</td><td>The Windows Filtering Platform has permitted a bind to a local port.</td></tr><tr><td>5159(F)</td><td>The Windows Filtering Platform has <strong>blocked</strong> a bind to a local port.</td></tr></tbody></table><p>关注的事件详细说明:</p><ul><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/audit-filtering-platform-packet-drop>Audit Filtering Platform Packet Drop</a><ul><li><p>这类事件产生量非常大，建议关注<strong>5157</strong>事件, 它记录了几乎相同的信息, 但是 5157 基于链接记录而不是基于数据包.</p></li><li><p>Failure events volume typically is very high for this subcategory and typically used for troubleshooting. If you need to monitor blocked connections, it is better to use “5157(F): The Windows Filtering Platform has blocked a connection,” because it contains almost the same information and generates per-connection, not per-packet.
<img alt=建议5157 src=https://s2.loli.net/2023/05/06/gaoLAnlNu1QT3zf.png></p></li><li><p><del><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5152>5152</a></del></p></li><li><p><del><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5153>5153</a></del></p></li></ul></li><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/audit-filtering-platform-connection>Audit Filtering Platform Connection</a><ul><li>建议只关注失败事件, 如被阻止的连接, 按需关注允许的链接.</li><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5031>5031</a><ul><li>If you don’t have any firewall rules (Allow or Deny) in Windows Firewall for specific applications, you will get this event from Windows Filtering Platform layer, because by default this layer is denying any incoming connections.</li></ul></li><li><del><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5150>5150</a></del></li><li><del><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5151>5151</a></del></li><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5155>5155</a></li><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5157>5157</a></li><li><a href=https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-5159>5159</a></li></ul></li></ul><h3 id=获取-provider-信息>获取 provider 信息</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 获取security相关的provider信息</span>
</span></span><span class=line><span class=cl><span class=nb>Get-WinEvent</span> <span class=n>-ListProvider</span> <span class=s2>&#34;*Security*&#34;</span>  <span class=p>|</span> <span class=nb>Select-Object</span> <span class=n>providername</span><span class=p>,</span><span class=n>id</span>
</span></span><span class=line><span class=cl><span class=c># Microsoft-Windows-Security-Auditing                             54849625-5478-4994-a5ba-3e3b0328c30d</span>
</span></span><span class=line><span class=cl><span class=c># 获取provider提供的task信息</span>
</span></span><span class=line><span class=cl><span class=nb>Get-WinEvent</span> <span class=n>-ListProvider</span> <span class=s2>&#34;Microsoft-Windows-Security-Auditing&#34;</span>  <span class=p>|</span> <span class=nb>Select-Object</span> <span class=n>-ExpandProperty</span> <span class=n>tasks</span>
</span></span><span class=line><span class=cl><span class=c># SE_ADT_OBJECTACCESS_FIREWALLCONNECTION       12810 Filtering Platform Connection          00000000-0000-0000-0000-000000000000</span>
</span></span></code></pre></div><table><thead><tr><th>ProviderName</th><th>Id</th></tr></thead><tbody><tr><td>Security Account Manager</td><td>00000000-0000-0000-0000-000000000000</td></tr><tr><td>Security</td><td>00000000-0000-0000-0000-000000000000</td></tr><tr><td>SecurityCenter</td><td>00000000-0000-0000-0000-000000000000</td></tr><tr><td>Microsoft-Windows-Security-SPP-UX-GenuineCenter-Logging</td><td>fb829150-cd7d-44c3-af5b-711a3c31cedc</td></tr><tr><td>Microsoft-Windows-Security-Mitigations</td><td>fae10392-f0af-4ac0-b8ff-9f4d920c3cdf</td></tr><tr><td>Microsoft-Windows-VerifyHardwareSecurity</td><td>f3f53c76-b06d-4f15-b412-61164a0d2b73</td></tr><tr><td>Microsoft-Windows-SecurityMitigationsBroker</td><td>ea8cd8a5-78ff-4418-b292-aadc6a7181df</td></tr><tr><td>Microsoft-Windows-Security-Adminless</td><td>ea216962-877b-5b73-f7c5-8aef5375959e</td></tr><tr><td>Microsoft-Windows-Security-Vault</td><td>e6c92fb8-89d7-4d1f-be46-d56e59804783</td></tr><tr><td>Microsoft-Windows-Security-Netlogon</td><td>e5ba83f6-07d0-46b1-8bc7-7e669a1d31dc</td></tr><tr><td>Microsoft-Windows-Security-SPP</td><td>e23b33b0-c8c9-472c-a5f9-f2bdfea0f156</td></tr><tr><td>Microsoft-Windows-Windows Firewall With Advanced Security</td><td>d1bc9aff-2abf-4d71-9146-ecb2a986eb85</td></tr><tr><td>Microsoft-Windows-Security-SPP-UX-Notifications</td><td>c4efc9bb-2570-4821-8923-1bad317d2d4b</td></tr><tr><td>Microsoft-Windows-Security-SPP-UX-GC</td><td>bbbdd6a3-f35e-449b-a471-4d830c8eda1f</td></tr><tr><td>Microsoft-Windows-Security-Kerberos</td><td>98e6cfcb-ee0a-41e0-a57b-622d4e1b30b1</td></tr><tr><td>Microsoft-Windows-Security-ExchangeActiveSyncProvisioning</td><td>9249d0d0-f034-402f-a29b-92fa8853d9f3</td></tr><tr><td>Microsoft-Windows-NetworkSecurity</td><td>7b702970-90bc-4584-8b20-c0799086ee5a</td></tr><tr><td>Microsoft-Windows-Security-SPP-UX</td><td>6bdadc96-673e-468c-9f5b-f382f95b2832</td></tr><tr><td>Microsoft-Windows-Security-Auditing</td><td>54849625-5478-4994-a5ba-3e3b0328c30d</td></tr><tr><td>Microsoft-Windows-Security-LessPrivilegedAppContainer</td><td>45eec9e5-4a1b-5446-7ad8-a4ab1313c437</td></tr><tr><td>Microsoft-Windows-Security-UserConsentVerifier</td><td>40783728-8921-45d0-b231-919037b4b4fd</td></tr><tr><td>Microsoft-Windows-Security-IdentityListener</td><td>3c6c422b-019b-4f48-b67b-f79a3fa8b4ed</td></tr><tr><td>Microsoft-Windows-Security-EnterpriseData-FileRevocationManager</td><td>2cd58181-0bb6-463e-828a-056ff837f966</td></tr><tr><td>Microsoft-Windows-Security-Audit-Configuration-Client</td><td>08466062-aed4-4834-8b04-cddb414504e5</td></tr><tr><td>Microsoft-Windows-Security-IdentityStore</td><td>00b7e1df-b469-4c69-9c41-53a6576e3dad</td></tr></tbody></table><h3 id=构造-block-事件>构造 block 事件</h3><p><strong>必须非常注意，在构造 block 事件时， 会影响本地其它软件的运行！</strong>
可及时使用<code>.\WFPSampler.exe -clean</code>来清理过滤器.</p><p>操作步骤:</p><ol><li><p>打开 Filtering Platform Connection 的审计开关, <code>auditpol /set /subcategory:"{0CCE9226-69AE-11D9-BED3-505054503030}" /success:enable /failure:enable</code></p></li><li><p>打开 Event Viewer, 构造一个 Custom View, 创建过滤器, 我们暂只关注 5155, 5157, 5159 三个事件.
<img alt="filter example" src=https://s2.loli.net/2023/05/06/TjfMkws8pu4NZRW.png></p></li><li><p>构造一个过滤器, 我们使用<strong>WFPSampler.exe</strong>来构造过滤器, 阻止监听本地的<strong>80</strong>端口, <code>.\WFPSampler.exe -s BASIC_ACTION_BLOCK -l FWPM_LAYER_ALE_AUTH_LISTEN_V4 -iplp 80</code></p></li><li><p>使用一个第三方(非 IIS)的 http server, 这里使用的 nginx, 默认监听 80 端口, 双击启动启动则触发 5155 事件
<img alt=触发审计事件示例 src=https://s2.loli.net/2023/05/06/V6vlyFZ4bQa5G9Y.png></p></li><li><p>还原过滤器, <code>.\WFPSampler.exe -clean</code></p></li><li><p>还原审计开关, <code>auditpol /set /category:"{0CCE9226-69AE-11D9-BED3-505054503030}" /success:disable /failure:disable</code></p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 5155 blocked an application or service from listening on a port for incoming connections</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_AUTH_LISTEN_V4</span>
</span></span><span class=line><span class=cl><span class=c># 5157 blocked a connection</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_AUTH_CONNECT_V4</span>
</span></span><span class=line><span class=cl><span class=c># 5159, blocked a bind to a local port</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># Other</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD</span>
</span></span><span class=line><span class=cl><span class=p>.\</span><span class=n>WFPSampler</span><span class=p>.</span><span class=py>exe</span> <span class=n>-s</span> <span class=n>BASIC_ACTION_BLOCK</span> <span class=n>-l</span> <span class=n>FWPM_LAYER_ALE_AUTH_CONNECT_V4_DISCARD</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># To find a specific Windows Filtering Platform filter by ID, run the following command:</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>wfp</span> <span class=n>show</span> <span class=kd>filter</span><span class=nb>s</span>
</span></span><span class=line><span class=cl><span class=c># To find a specific Windows Filtering Platform layer ID, you need to execute the following command:</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>wfp</span> <span class=n>show</span> <span class=n>state</span>
</span></span></code></pre></div><h2 id=监控网络事件net_event>监控网络事件(NET_EVENT)</h2><ul><li>网络事件支持枚举查找, 支持订阅.</li><li>枚举方式支持定制过滤条件, 获取一段时间内的网络事件.</li><li>订阅方式可以注入一个 callback 函数, 实时反馈.</li></ul><p>支持的事件种类:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=n>FWPM_NET_EVENT_TYPE_</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_CLASSIFY_DROP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_IPSEC_DOSP_DROP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_CLASSIFY_ALLOW</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_CAPABILITY_DROP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_CAPABILITY_ALLOW</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_CLASSIFY_DROP_MAC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_LPM_PACKET_ARRIVAL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FWPM_NET_EVENT_TYPE_MAX</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FWPM_NET_EVENT_TYPE</span><span class=p>;</span>
</span></span></code></pre></div><p>支持的过滤条件(FWPM_NET_EVENT_ENUM_TEMPLATE):</p><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>FWPM_CONDITION_IP_PROTOCOL</td><td>The IP protocol number, as specified in RFC 1700.</td></tr><tr><td>FWPM_CONDITION_IP_LOCAL_ADDRESS</td><td>The local IP address.</td></tr><tr><td>FWPM_CONDITION_IP_REMOTE_ADDRESS</td><td>The remote IP address.</td></tr><tr><td>FWPM_CONDITION_IP_LOCAL_PORT</td><td>The local transport protocol port number. For ICMP, the message type.</td></tr><tr><td>FWPM_CONDITION_IP_REMOTE_PORT</td><td>The remote transport protocol port number. For ICMP, the message code.</td></tr><tr><td>FWPM_CONDITION_SCOPE_ID</td><td>The interface IPv6 scope identifier. Reserved for internal use.</td></tr><tr><td>FWPM_CONDITION_ALE_APP_ID</td><td>The full path of the application.</td></tr><tr><td>FWPM_CONDITION_ALE_USER_ID</td><td>The identification of the local user.</td></tr></tbody></table><p>非 driver 调用的方式只能获得普通的 drop 事件.</p><h2 id=监控网络链接netconnection>监控网络链接(NetConnection)</h2><p>相较监控网络事件, 监控链接需要更高权限.
<a href=https://docs.microsoft.com/en-us/windows/win32/api/fwpmu/nf-fwpmu-fwpmconnectionsubscribe0>callback 方式</a></p><blockquote><p>The caller needs FWPM_ACTRL_ENUM access to the connection objects&rsquo; containers and FWPM_ACTRL_READ access to the connection objects. See Access Control for more information.</p></blockquote><p><strong>暂未能成功监控网络链接.</strong></p><p>查到同样问题, <a href=https://stackoverflow.com/questions/63038046/receiving-in-out-traffic-stats-using-wfp-user-mode-api>Receiving in/out traffic stats using WFP user-mode API</a>, 和我调研中遇到的现象一样, 订阅函数收不到任何上报, 得不到任何事件, 没有报错. 开审计, 提权都没有成功. 有人提示非内核模式只能得到 drop 事件的上报, 这不能满足获取阻断事件的需求.</p><p>添加 security descriptor 示例: <a href=https://docs.microsoft.com/en-us/windows/win32/fwp/reserving-ports>https://docs.microsoft.com/en-us/windows/win32/fwp/reserving-ports</a></p><h2 id=application-layer-enforcementale介绍>Application Layer Enforcement(ALE)介绍</h2><ul><li>ALE 包含一系列在内核模式下的过滤器, 支持状态过滤.</li><li>ALE 层的过滤器可授权链接的创建, 端口分配, 套接字管理, 原始套接字创建, 和混杂模式接收.</li><li>ALE 层过滤器的分类基于链接(connection), 或基于套接字(socket), 其它层的过滤器只能基于数据包(packet)进行分类.</li><li>ALE 过滤器参考 <a href=https://docs.microsoft.com/en-us/windows/win32/fwp/ale-layers>ale-layers</a><ul><li>更多过滤器参考 <a href=https://docs.microsoft.com/en-us/windows/win32/fwp/management-filtering-layer-identifiers->filtering-layer-identifiers</a></li></ul></li></ul><h2 id=编码>编码</h2><p>大多数 WFP 函数都可以从用户模式或内核模式调用。 但是，用户模式函数返回表示 Win32 错误代码的 DWORD 值，而内核模式函数返回表示 NT 状态代码的 NTSTATUS 值。 因此，函数名称和语义在用户模式和内核模式之间是相同的，但函数签名则不同。 这需要函数原型的单独用户模式和内核模式特定标头。 用户模式头文件名以"u"结尾，内核模式头文件名以"k"结尾。</p><h2 id=结论>结论</h2><p>需求仅需要知道事件发生, 不需要即时处理事件, 另外开发驱动会带来更大的风险, 因此决定使用事件审计, 监控日志生成事件的方式来获得阻断事件.<br>新开一个线程来使用<a href=https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-notifychangeeventlog>NotifyChangeEventLog</a>来监控日志记录事件.</p><h2 id=附录>附录</h2><h3 id=wfp-体系结构>WFP 体系结构</h3><p>WFP(Windows Filter Platform) <img alt="Windows 筛选平台的基本体系结构" src=https://docs.microsoft.com/en-us/windows/win32/fwp/images/wfp-architecture.png></p><h3 id=数据流>数据流</h3><p>Data flow:</p><ol><li>A packet comes into the network stack.</li><li>The network stack finds and calls a shim.</li><li>The shim invokes the classification process at a particular layer.</li><li>During classification, filters are matched and the resultant action is taken. (See Filter Arbitration.)</li><li>If any callout filters are matched during the classification process, the corresponding callouts are invoked.</li><li>The shim acts on the final filtering decision (for example, drop the packet).</li></ol><h3 id=参考链接>参考链接</h3><ul><li><a href=https://docs.microsoft.com/en-us/windows/win32/fwp/management-filtering-layer-identifiers->过滤器种类</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/fwp/filtering-conditions-available-at-each-filtering-layer>过滤器的附加条件</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499->error code</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/fwp/wfp-error-codes>WFP error code</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-98219600397f17c3d5e4ac6fbfc5f707>Windows防火墙管理-netsh</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Windows防火墙管理-netsh</li></ul><h1 id=windows-防火墙管理-netsh>Windows 防火墙管理-netsh</h1><h2 id=管理工具>管理工具</h2><h2 id=netsh-advfirewall>netsh advfirewall</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 导出防火墙规则</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>export</span> <span class=n>advfirewallpolicy</span><span class=p>.</span><span class=py>wfw</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 导入防火墙规则</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>import</span> <span class=n>advfirewallpolicy</span><span class=p>.</span><span class=py>wfw</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙状态</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>show</span> <span class=n>allprofiles</span> <span class=n>state</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙默认规则</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>show</span> <span class=n>allprofiles</span> <span class=n>firewallpolicy</span>
</span></span><span class=line><span class=cl><span class=c># netsh advfirewall set allprofiles firewallpolicy blockinbound,allowoutbound</span>
</span></span><span class=line><span class=cl><span class=c># netsh advfirewall set allprofiles firewallpolicy blockinbound,blockoutbound</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙设置</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>show</span> <span class=n>allprofiles</span> <span class=n>settings</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 启用防火墙</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=nb>set </span><span class=n>allprofiles</span> <span class=n>state</span> <span class=n>on</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 禁用防火墙</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=nb>set </span><span class=n>allprofiles</span> <span class=n>state</span> <span class=n>off</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙规则</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>firewall</span> <span class=n>show</span> <span class=n>rule</span> <span class=n>name</span><span class=p>=</span><span class=n>all</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙状态</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>advfirewall</span> <span class=n>monitor</span> <span class=n>show</span> <span class=n>firewall</span>
</span></span></code></pre></div><h2 id=netsh-firewalldeprecated>netsh firewall(deprecated)</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 查看防火墙状态</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>firewall</span> <span class=n>show</span> <span class=n>state</span>
</span></span></code></pre></div><h2 id=netsh-mbnmobile-broadband-network>netsh mbn(Mobile Broadband network)</h2><h2 id=netsh-wfp>netsh wfp</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 查看防火墙状态</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>wfp</span> <span class=n>show</span> <span class=n>state</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看防火墙规则</span>
</span></span><span class=line><span class=cl><span class=n>netsh</span> <span class=n>wfp</span> <span class=n>show</span> <span class=kd>filter</span><span class=nb>s</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ea3b4f1af238c774fab2871e85bf40ef>Windows相关资源</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Windows相关资源</li></ul><h1 id=windows-资源整理>Windows 资源整理</h1><ul><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#windows-资源整理>Windows 资源整理</a><ul><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#工具篇>工具篇</a><ul><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#监控分析>监控&分析</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#antirootkit-工具>AntiRootkit 工具</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#pe-工具>PE 工具</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#逆向调试>逆向&调试</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#注入工具>注入工具</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#网络>网络</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#压测工具>压测工具</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#其他>其他</a></li></ul></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#代码篇>代码篇</a><ul><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#操作系统>操作系统</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#内核封装>内核封装</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#vt-技术>VT 技术</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#其他-1>其他</a></li></ul></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#ctf-资源>CTF 资源</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#渗透相关>渗透相关</a></li><li><a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/#专利免费查询>专利免费查询</a></li></ul></li></ul><p>这里只列举了一些 Windows 上调试，排查问题以及测试的一些常用工具，其他的加壳脱壳，加密解密，文件编辑器以及编程工具不进行整理了。</p><h2 id=工具篇>工具篇</h2><h3 id=监控分析>监控&分析</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>DebugView</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/debugview>https://docs.microsoft.com/zh-cn/sysinternals/downloads/debugview</a></td><td style=text-align:left>sysinternals 里面的工具，可用来查看、控制内核及用户态调式输出</td></tr><tr><td style=text-align:left><strong>Process Monitor</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon>https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon</a></td><td style=text-align:left>sysinternals 里面的工具，实时监视文件系统，注册表，进程，线程以及 DLL 的活动，方便排查问题</td></tr><tr><td style=text-align:left><strong>Process Explorer</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer>https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</a></td><td style=text-align:left>sysinternals 里面的工具，进程查看器，可以浏览加载的 DLL，调用堆栈以及查找文件被哪些进程打开</td></tr><tr><td style=text-align:left><strong>WinObj</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/winobj>https://docs.microsoft.com/zh-cn/sysinternals/downloads/winobj</a></td><td style=text-align:left>sysinternals 里面的工具，对象管理器命名空间的查看利器，没有加载驱动而是使用系统 API 实现,可参考 GitHub 中的 WinObjEx64</td></tr><tr><td style=text-align:left><strong>WinObjEx64</strong></td><td style=text-align:left><a href=https://github.com/hfiref0x/WinObjEx64>https://github.com/hfiref0x/WinObjEx64</a></td><td style=text-align:left>对象管理器命名空间的查看利器，开源的</td></tr><tr><td style=text-align:left><strong>Handle</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/zh-cn/sysinternals/downloads/handle>https://docs.microsoft.com/zh-cn/sysinternals/downloads/handle</a></td><td style=text-align:left>sysinternals 里面的工具，查看特定的文件或者目录被哪个应用程序占用</td></tr><tr><td style=text-align:left><strong>sysinternals</strong></td><td style=text-align:left><a href=https://live.sysinternals.com/>https://live.sysinternals.com/</a></td><td style=text-align:left>sysinternals 里面还有很多工具，一般用不着，暂时不进行罗列，上面几个是常用的工具</td></tr><tr><td style=text-align:left><strong>CPU-Z</strong></td><td style=text-align:left><a href=https://www.cpuid.com/softwares/cpu-z.html>https://www.cpuid.com/softwares/cpu-z.html</a></td><td style=text-align:left>CPU 实时监测工具</td></tr><tr><td style=text-align:left><strong>ProcMonX</strong></td><td style=text-align:left><a href=https://github.com/zodiacon/ProcMonX>https://github.com/zodiacon/ProcMonX</a></td><td style=text-align:left>使用 ETW 实现的类似于 Process Monitor 功能的工具，开源 C#语言编写</td></tr><tr><td style=text-align:left><strong>ProcMonXv2</strong></td><td style=text-align:left><a href=https://github.com/zodiacon/ProcMonXv2>https://github.com/zodiacon/ProcMonXv2</a></td><td style=text-align:left>使用 ETW 实现的类似于 Process Monitor 功能的工具，开源 C#语言编写,第二版</td></tr><tr><td style=text-align:left><strong>processhacker</strong></td><td style=text-align:left><a href=https://github.com/processhacker/processhacker>https://github.com/processhacker/processhacker</a></td><td style=text-align:left>开源的类似于 Process Explorer 的工具，支持 GPU 相关的信息显示</td></tr><tr><td style=text-align:left><strong>API Monitor</strong></td><td style=text-align:left><a href=http://www.rohitab.com/apimonitor>http://www.rohitab.com/apimonitor</a></td><td style=text-align:left>通过跟踪 API 的调用，用来查看应用程序和服务的工作方式或跟踪应用程序中存在的问题，可修改 API 的入参及出参</td></tr><tr><td style=text-align:left><strong>Dependency Walker</strong></td><td style=text-align:left><a href=http://www.dependencywalker.com/>http://www.dependencywalker.com/</a></td><td style=text-align:left>扫描任何 32 位或 64 位 Windows 模块,列出了该模块导出的所有功能等</td></tr><tr><td style=text-align:left><strong>DeviceTree</strong></td><td style=text-align:left><a href="http://www.osronline.com/article.cfm%5earticle=97.htm">http://www.osronline.com/article.cfm%5earticle=97.htm</a></td><td style=text-align:left>显示系统的所有驱动对象以及相关设备栈信息</td></tr><tr><td style=text-align:left><strong>Unlocker</strong></td><td style=text-align:left><a href=https://www.softpedia.com/get/System/System-Miscellaneous/Unlocker.shtml>https://www.softpedia.com/get/System/System-Miscellaneous/Unlocker.shtml</a></td><td style=text-align:left>解锁占用文件的，很多类似的工具以及开源代码</td></tr><tr><td style=text-align:left><strong>RpcView</strong></td><td style=text-align:left><a href=https://github.com/silverf0x/RpcView>https://github.com/silverf0x/RpcView</a></td><td style=text-align:left>显示以及反编译当前系统的 RPC 接口等信息，分析 RPC 的情况下可以借以辅助</td></tr><tr><td style=text-align:left><strong>RequestTrace</strong></td><td style=text-align:left><a href=https://the-sz.com/products/rt/>https://the-sz.com/products/rt/</a></td><td style=text-align:left>可以查看 WINDOWS 上 IRP、SRB、URB 的详细信息，包含数据缓存等，一般也不会使用，因为 WINDBG 调试就可以分析数据，不调试的情况可以使用它来辅助</td></tr><tr><td style=text-align:left><strong>IRPMon</strong></td><td style=text-align:left><a href=https://github.com/MartinDrab/IRPMon>https://github.com/MartinDrab/IRPMon</a></td><td style=text-align:left>通过挂钩驱动对象，实现类似于 RequestTrace、IrpTracker 的功能，监控驱动对象的所有 IRP 等形式的请求</td></tr><tr><td style=text-align:left><strong>IRPTrace</strong></td><td style=text-align:left><a href=https://github.com/haidragon/drivertools>https://github.com/haidragon/drivertools</a></td><td style=text-align:left>里面有一些其他工具</td></tr></tbody></table><h3 id=antirootkit-工具>AntiRootkit 工具</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>PcHunter</strong></td><td style=text-align:left><a href=https://www.anxinsec.com/view/antirootkit/>https://www.anxinsec.com/view/antirootkit/</a></td><td style=text-align:left>安全分析工具，为了对抗 Rootkit，使用穿透技术进行文件，网络，注册表等的操作，并提供线程、进程以及内核模块的各种详细信息</td></tr><tr><td style=text-align:left><strong>Windows-Kernel-Explorer</strong></td><td style=text-align:left><a href=https://github.com/AxtMueller/Windows-Kernel-Explorer>https://github.com/AxtMueller/Windows-Kernel-Explorer</a></td><td style=text-align:left>类似于 Pchunter，不开源，如果 PcHunter 没有支持最新系统，可以尝试这个软件</td></tr><tr><td style=text-align:left><strong>PowerTool</strong></td><td style=text-align:left></td><td style=text-align:left>目前没咋更新，朋友公司的同事开发的，据说代码很乱。。。</td></tr><tr><td style=text-align:left><strong>py</strong></td><td style=text-align:left><a href=https://github.com/antiwar3/py>https://github.com/antiwar3/py</a></td><td style=text-align:left>飘云 ark</td></tr></tbody></table><h3 id=pe-工具>PE 工具</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>CFF Explorer</strong></td><td style=text-align:left><a href="https://ntcore.com/?page_id=388">https://ntcore.com/?page_id=388</a></td><td style=text-align:left>还不错的</td></tr><tr><td style=text-align:left><strong>ExeinfoPe</strong></td><td style=text-align:left><a href=http://www.exeinfo.xn.pl/>http://www.exeinfo.xn.pl/</a></td><td style=text-align:left></td></tr></tbody></table><h3 id=逆向调试>逆向&调试</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th><th></th></tr></thead><tbody><tr><td style=text-align:left><strong>Ghidra</strong></td><td style=text-align:left><a href=https://www.nsa.gov/resources/everyone/ghidra/>https://www.nsa.gov/resources/everyone/ghidra/</a></td><td style=text-align:left>由美国国家安全局（NSA）研究部门开发的软件逆向工程（SRE）套件，用于支持网络安全任务</td><td></td></tr><tr><td style=text-align:left><strong>IDA</strong></td><td style=text-align:left><a href=https://down.52pojie.cn/>https://down.52pojie.cn/</a></td><td style=text-align:left>最新的破解版吧好像是 7.5，可在吾爱破解论坛查找下载地址</td><td></td></tr><tr><td style=text-align:left><strong>dnSpy</strong></td><td style=text-align:left><a href=https://github.com/dnSpy/dnSpy>https://github.com/dnSpy/dnSpy</a></td><td style=text-align:left>.NET 程序的逆向工具，对于不混淆不加密的.NET 程序相当于看源代码了，前提是了解.NET 框架</td><td></td></tr><tr><td style=text-align:left><strong>OllyDbg</strong></td><td style=text-align:left><a href=https://down.52pojie.cn/Tools/Debuggers//>https://down.52pojie.cn/Tools/Debuggers//</a></td><td style=text-align:left>用于逆向分析应用程序，插件丰富，但是不开源也不支持 x64 程序</td><td></td></tr><tr><td style=text-align:left><strong>x64DBG</strong></td><td style=text-align:left><a href=https://x64dbg.com/>https://x64dbg.com/</a></td><td style=text-align:left>用于逆向分析应用程序，开源，支持 x64 程序，相对于 windbg 来说操作更方便点，和 OD 比较建议选择 x64dbg</td><td></td></tr><tr><td style=text-align:left><strong>CheatEngine</strong></td><td style=text-align:left><a href=https://www.cheatengine.org/>https://www.cheatengine.org/</a></td><td style=text-align:left>逆向破解的神器，支持各种内存搜索、修改以及一些其他的高级逆向功能</td><td></td></tr><tr><td style=text-align:left><strong>VirtualKD-Redux</strong></td><td style=text-align:left><a href=https://github.com/4d61726b/VirtualKD-Redux/releases>https://github.com/4d61726b/VirtualKD-Redux/releases</a></td><td style=text-align:left>Windbg 虚拟机调试的全自动化辅助工具，不再需要设置一堆环境变量，支持最新 VMWare</td><td></td></tr><tr><td style=text-align:left><strong>Driver Loader</strong></td><td style=text-align:left><a href="http://www.osronline.com/article.cfm%5Earticle=157.htm">http://www.osronline.com/article.cfm%5Earticle=157.htm</a></td><td style=text-align:left>OSR 提供的工具，进行驱动的安装，加载以及卸载</td><td> </td></tr><tr><td style=text-align:left>reverse-engineering</td><td style=text-align:left><a href=https://github.com/wtsxDev/reverse-engineering>https://github.com/wtsxDev/reverse-engineering</a></td><td style=text-align:left>基本上逆向需要得工具都可以在这里找到</td><td></td></tr></tbody></table><h3 id=注入工具>注入工具</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th><th></th></tr></thead><tbody><tr><td style=text-align:left><strong>yapi</strong></td><td style=text-align:left><a href=https://github.com/ez8-co/yapi>https://github.com/ez8-co/yapi</a></td><td style=text-align:left>一个程序注入 x64/x86 进程</td><td>开源，使用少，可重点查看源码，支持 32 位程序向 64 位程序注入</td></tr><tr><td style=text-align:left><strong>Xenos</strong></td><td style=text-align:left><a href=https://github.com/DarthTon/Xenos>https://github.com/DarthTon/Xenos</a></td><td style=text-align:left>开源，而且使用了鼎鼎大名的黑古工程，支持内核注入</td><td></td></tr><tr><td style=text-align:left><strong>ExtremeInjector</strong></td><td style=text-align:left><a href=https://github.com/master131/ExtremeInjector>https://github.com/master131/ExtremeInjector</a></td><td style=text-align:left>应用层注入工具，支持 32 位程序向 64 位程序注入</td><td></td></tr></tbody></table><h3 id=网络>网络</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>Fiddler</strong></td><td style=text-align:left><a href=https://www.telerik.com/fiddler>https://www.telerik.com/fiddler</a></td><td style=text-align:left>可直接中间人劫持，不需要手动添加证书等，支持脚本进行流量劫持,同事也提供了 SDK 进行编码</td></tr><tr><td style=text-align:left><strong>Wireshark</strong></td><td style=text-align:left><a href=https://www.wireshark.org/download.html>https://www.wireshark.org/download.html</a></td><td style=text-align:left>这个就不多介绍了</td></tr><tr><td style=text-align:left><strong>Burp Suite</strong></td><td style=text-align:left><a href=https://portswigger.net/burp>https://portswigger.net/burp</a></td><td style=text-align:left>渗透的好像都偏爱这个抓包工具，依赖 JDK，可在吾爱下载破解版</td></tr></tbody></table><h3 id=压测工具>压测工具</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>Driver Verifier</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/driver-verifier>https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/driver-verifier</a></td><td style=text-align:left>系统自带，驱动稳定性测试工具</td></tr><tr><td style=text-align:left><strong>Application Verifier</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier>https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier</a></td><td style=text-align:left>系统自带，应用层的压测工具</td></tr><tr><td style=text-align:left><strong>CPUStress</strong></td><td style=text-align:left><a href=https://docs.microsoft.com/en-us/sysinternals/downloads/cpustres>https://docs.microsoft.com/en-us/sysinternals/downloads/cpustres</a></td><td style=text-align:left>让 CPU 负荷工作，测试极端情况下软件的稳定性以及响应度等</td></tr></tbody></table><h3 id=其他>其他</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>game-hacking</strong></td><td style=text-align:left><a href=https://github.com/dsasmblr/game-hacking>https://github.com/dsasmblr/game-hacking</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>awesome-malware-analysis</strong></td><td style=text-align:left><a href=https://github.com/rootkiter/awesome-malware-analysis>https://github.com/rootkiter/awesome-malware-analysis</a></td><td style=text-align:left>病毒分析工具集合</td></tr><tr><td style=text-align:left><strong>drawio</strong></td><td style=text-align:left><a href=https://github.com/jgraph/drawio-desktop>https://github.com/jgraph/drawio-desktop</a></td><td style=text-align:left>绘图神器</td></tr><tr><td style=text-align:left>RazorSQL</td><td style=text-align:left><a href=https://www.razorsql.com/>https://www.razorsql.com/</a></td><td style=text-align:left>SQLite3 数据库 GUI 工具</td></tr><tr><td style=text-align:left>Git 学习笔记</td><td style=text-align:left><a href=https://github.com/No-Github/1earn/blob/master/1earn/Develop/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md>https://github.com/No-Github/1earn/blob/master/1earn/Develop/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md</a></td><td style=text-align:left>Git 版本管理知识</td></tr><tr><td style=text-align:left>Markdown 语法学习</td><td style=text-align:left><a href=https://github.com/No-Github/1earn/blob/master/1earn/Develop/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/Markdown/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0.md>https://github.com/No-Github/1earn/blob/master/1earn/Develop/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/Markdown/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0.md</a></td><td style=text-align:left>Markdown 语法学习</td></tr></tbody></table><h2 id=代码篇>代码篇</h2><h3 id=操作系统>操作系统</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>ReactOS</strong></td><td style=text-align:left><a href=https://github.com/reactos/reactos>https://github.com/reactos/reactos</a></td><td style=text-align:left>好像是逆向 windows 2000 的开源系统，可以替换 win 2000 的内核程序</td></tr><tr><td style=text-align:left><strong>wrk-v1.2</strong></td><td style=text-align:left><a href=https://github.com/jmcjmmcjc/wrk-v1.2>https://github.com/jmcjmmcjc/wrk-v1.2</a></td><td style=text-align:left>Windows NT 5.2 Partial Source Code</td></tr><tr><td style=text-align:left><strong>WinNT4</strong></td><td style=text-align:left><a href=https://github.com/ZoloZiak/WinNT4>https://github.com/ZoloZiak/WinNT4</a></td><td style=text-align:left>Windows NT4 Kernel Source code</td></tr><tr><td style=text-align:left>whids</td><td style=text-align:left><a href=https://github.com/0xrawsec/whids/tree/a826d87e0d035daac10bfa96b530c5deff6b9915>https://github.com/0xrawsec/whids/tree/a826d87e0d035daac10bfa96b530c5deff6b9915</a></td><td style=text-align:left>Open Source EDR for Windows</td></tr></tbody></table><h3 id=内核封装>内核封装</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>CPPHelper</strong></td><td style=text-align:left><a href=https://github.com/Chuyu-Team/CPPHelper>https://github.com/Chuyu-Team/CPPHelper</a></td><td style=text-align:left>C++基础辅助类库</td></tr><tr><td style=text-align:left><strong>cpp_component</strong></td><td style=text-align:left><a href=https://github.com/skyformat99/cpp_component>https://github.com/skyformat99/cpp_component</a></td><td style=text-align:left>对 cpp 一些常用的功能进行封装</td></tr><tr><td style=text-align:left><strong>WinToolsLib</strong></td><td style=text-align:left><a href=https://github.com/deeonis-ru/WinToolsLib>https://github.com/deeonis-ru/WinToolsLib</a></td><td style=text-align:left>Suite of classes for Windows programming</td></tr><tr><td style=text-align:left><strong>KDU</strong></td><td style=text-align:left><a href=https://github.com/hfiref0x/KDU>https://github.com/hfiref0x/KDU</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>KTL</strong></td><td style=text-align:left><a href=https://github.com/MeeSong/KTL>https://github.com/MeeSong/KTL</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>Kernel-Bridge</strong></td><td style=text-align:left><a href=https://github.com/HoShiMin/Kernel-Bridge>https://github.com/HoShiMin/Kernel-Bridge</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>KernelForge</strong></td><td style=text-align:left><a href=https://github.com/killvxk/KernelForge>https://github.com/killvxk/KernelForge</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>ExecutiveCallbackObjects</strong></td><td style=text-align:left><a href=https://github.com/0xcpu/ExecutiveCallbackObjects>https://github.com/0xcpu/ExecutiveCallbackObjects</a></td><td style=text-align:left>内核下的各种回调研究</td></tr><tr><td style=text-align:left><strong>SyscallHook</strong></td><td style=text-align:left><a href=https://github.com/AnzeLesnik/SyscallHook>https://github.com/AnzeLesnik/SyscallHook</a></td><td style=text-align:left>System call hook for Windows 10 20H1</td></tr><tr><td style=text-align:left><strong>Antivirus_R3_bypass_demo</strong></td><td style=text-align:left><a href=https://github.com/huoji120/Antivirus_R3_bypass_demo>https://github.com/huoji120/Antivirus_R3_bypass_demo</a></td><td style=text-align:left>分别用 R3 的 0day 与 R0 的 0day 来干掉杀毒软件</td></tr><tr><td style=text-align:left><strong>KernelHiddenExecute</strong></td><td style=text-align:left><a href=https://github.com/zouxianyu/KernelHiddenExecute>https://github.com/zouxianyu/KernelHiddenExecute</a></td><td style=text-align:left>在内核地址空间中隐藏代码/数据</td></tr><tr><td style=text-align:left><strong>DriverInjectDll</strong></td><td style=text-align:left><a href=https://github.com/strivexjun/DriverInjectDll>https://github.com/strivexjun/DriverInjectDll</a></td><td style=text-align:left>内核模式下全局注入，内存注入，支持 WIN7-WIN10</td></tr><tr><td style=text-align:left><strong>zwhawk</strong></td><td style=text-align:left><a href=https://github.com/eLoopWoo/zwhawk>https://github.com/eLoopWoo/zwhawk</a></td><td style=text-align:left>Windows 远程命令和控制界面的内核 rootkit</td></tr><tr><td style=text-align:left><strong>ZeroBank-ring0-bundle</strong></td><td style=text-align:left><a href=https://github.com/Trietptm-on-Coding-Algorithms/ZeroBank-ring0-bundle>https://github.com/Trietptm-on-Coding-Algorithms/ZeroBank-ring0-bundle</a></td><td style=text-align:left>连接到远程服务器以发送和接收命令的内核模式 rootkit</td></tr><tr><td style=text-align:left><strong>kdmapper</strong></td><td style=text-align:left><a href=https://github.com/z175/kdmapper>https://github.com/z175/kdmapper</a></td><td style=text-align:left>About driver manual mapper (outdated/for educational purposes)</td></tr><tr><td style=text-align:left><strong>antispy</strong></td><td style=text-align:left><a href=https://github.com/mohuihui/antispy>https://github.com/mohuihui/antispy</a></td><td style=text-align:left>a free but powerful anti virus and rootkits toolkit</td></tr><tr><td style=text-align:left><strong>windows_kernel_resources</strong></td><td style=text-align:left><a href=https://github.com/sam-b/windows_kernel_resources>https://github.com/sam-b/windows_kernel_resources</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>HookLib</strong></td><td style=text-align:left><a href=https://github.com/HoShiMin/HookLib>https://github.com/HoShiMin/HookLib</a></td><td style=text-align:left>UserMode and KernelMode support</td></tr><tr><td style=text-align:left><strong>Kernel-Whisperer</strong></td><td style=text-align:left><a href=https://github.com/BrunoMCBraga/Kernel-Whisperer>https://github.com/BrunoMCBraga/Kernel-Whisperer</a></td><td style=text-align:left>内核模块封装</td></tr><tr><td style=text-align:left>SQLiteCpp</td><td style=text-align:left><a href=https://github.com/SRombauts/SQLiteCpp>https://github.com/SRombauts/SQLiteCpp</a></td><td style=text-align:left>a smart and easy to use C++ SQLite3 wrapper</td></tr><tr><td style=text-align:left>awesome-windows-kernel-security-development</td><td style=text-align:left><a href=https://github.com/ExpLife0011/awesome-windows-kernel-security-development>https://github.com/ExpLife0011/awesome-windows-kernel-security-development</a></td><td style=text-align:left>各种内核技术得代码合集</td></tr></tbody></table><h3 id=vt-技术>VT 技术</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>hvpp</strong></td><td style=text-align:left><a href=https://github.com/wbenny/hvpp>https://github.com/wbenny/hvpp</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>HyperBone</strong></td><td style=text-align:left><a href=https://github.com/DarthTon/HyperBone>https://github.com/DarthTon/HyperBone</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>HyperWin</strong></td><td style=text-align:left><a href=https://github.com/amiryeshurun/HyperWin>https://github.com/amiryeshurun/HyperWin</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>Hypervisor</strong></td><td style=text-align:left><a href=https://github.com/Bareflank/hypervisor>https://github.com/Bareflank/hypervisor</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>HyperPlatform</strong></td><td style=text-align:left><a href=https://github.com/tandasat/HyperPlatform>https://github.com/tandasat/HyperPlatform</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>Hyper-V-Internals</strong></td><td style=text-align:left><a href=https://github.com/gerhart01/Hyper-V-Internals>https://github.com/gerhart01/Hyper-V-Internals</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>Hypervisor-From-Scratch</strong></td><td style=text-align:left><a href=https://github.com/SinaKarvandi/Hypervisor-From-Scratch>https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>KasperskyHook</strong></td><td style=text-align:left><a href=https://github.com/iPower/KasperskyHook>https://github.com/iPower/KasperskyHook</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>awesome-virtualization</strong></td><td style=text-align:left><a href=https://github.com/Wenzel/awesome-virtualization>https://github.com/Wenzel/awesome-virtualization</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>ransomware_begone</strong></td><td style=text-align:left><a href=https://github.com/ofercas/ransomware_begone>https://github.com/ofercas/ransomware_begone</a></td><td style=text-align:left></td></tr></tbody></table><h3 id=其他-1>其他</h3><table><thead><tr><th style=text-align:left>工具名</th><th style=text-align:left>下载地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>Divert</strong></td><td style=text-align:left><a href=https://github.com/basil00/Divert>https://github.com/basil00/Divert</a></td><td style=text-align:left>将数据流量转发给应用程序，可以修改，丢弃等操作网络流量</td></tr><tr><td style=text-align:left><strong>Blackbone</strong></td><td style=text-align:left><a href=https://github.com/DarthTon/Blackbone>https://github.com/DarthTon/Blackbone</a></td><td style=text-align:left>内核模式下的几种注入方式，包括了内核模式下的内存注入</td></tr><tr><td style=text-align:left><strong>NetWatch</strong></td><td style=text-align:left><a href=https://github.com/huoji120/NetWatch>https://github.com/huoji120/NetWatch</a></td><td style=text-align:left>威胁流量检测系统，可以做虚拟内存补丁</td></tr><tr><td style=text-align:left><strong>x64_AOB_Search</strong></td><td style=text-align:left><a href=https://github.com/wanttobeno/x64_AOB_Search>https://github.com/wanttobeno/x64_AOB_Search</a></td><td style=text-align:left>快速内存搜索算法，商用级别,支持通配符</td></tr><tr><td style=text-align:left><strong>DuckMemoryScan</strong></td><td style=text-align:left><a href=https://github.com/huoji120/DuckMemoryScan>https://github.com/huoji120/DuckMemoryScan</a></td><td style=text-align:left>检测绝大部分所谓的内存免杀马</td></tr><tr><td style=text-align:left><strong>FSDefender</strong></td><td style=text-align:left><a href=https://github.com/Randomize163/FSDefender>https://github.com/Randomize163/FSDefender</a></td><td style=text-align:left>文件驱动监控 + 云备份方案</td></tr><tr><td style=text-align:left><strong>AntiRansomware</strong></td><td style=text-align:left><a href=https://github.com/clavis0x/AntiRansomware>https://github.com/clavis0x/AntiRansomware</a></td><td style=text-align:left>防勒索方案，不让覆盖，写就进行扫描</td></tr><tr><td style=text-align:left><strong>Lazy</strong></td><td style=text-align:left><a href=https://github.com/moonAgirl/Lazy>https://github.com/moonAgirl/Lazy</a></td><td style=text-align:left>(恶意)勒索软件终结者</td></tr><tr><td style=text-align:left>awesome-cheatsheets</td><td style=text-align:left><a href=https://github.com/skywind3000/awesome-cheatsheets/blob/master/tools/git.txt>https://github.com/skywind3000/awesome-cheatsheets/blob/master/tools/git.txt</a></td><td style=text-align:left>各种 python,git 速查表</td></tr></tbody></table><h2 id=ctf-资源>CTF 资源</h2><table><thead><tr><th style=text-align:left>仓库名</th><th style=text-align:left>仓库地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>CTF-All-In-One</strong></td><td style=text-align:left><a href=https://github.com/firmianay/CTF-All-In-One>https://github.com/firmianay/CTF-All-In-One</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>ctf-book</strong></td><td style=text-align:left><a href=https://github.com/firmianay/ctf-book>https://github.com/firmianay/ctf-book</a></td><td style=text-align:left>CTF 竞赛权威指南(Pwn 篇) 相关资源</td></tr></tbody></table><h2 id=渗透相关>渗透相关</h2><table><thead><tr><th style=text-align:left>仓库名</th><th style=text-align:left>仓库地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>Web-Security-Learning</strong></td><td style=text-align:left><a href=https://github.com/CHYbeta/Web-Security-Learning>https://github.com/CHYbeta/Web-Security-Learning</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>pentest</strong></td><td style=text-align:left><a href=https://github.com/r0eXpeR/pentest>https://github.com/r0eXpeR/pentest</a></td><td style=text-align:left>内网渗透中的一些工具及项目资料</td></tr><tr><td style=text-align:left><strong>K8tools</strong></td><td style=text-align:left><a href=http://k8gege.org/p/72f1fea6.html>http://k8gege.org/p/72f1fea6.html</a></td><td style=text-align:left>K8tools 工具合集</td></tr><tr><td style=text-align:left><strong>Awesome-Red-Teaming</strong></td><td style=text-align:left><a href=https://github.com/yeyintminthuhtut/Awesome-Red-Teaming>https://github.com/yeyintminthuhtut/Awesome-Red-Teaming</a></td><td style=text-align:left>List of Awesome Red Teaming Resources</td></tr><tr><td style=text-align:left><strong>Awesome-Hacking</strong></td><td style=text-align:left><a href=https://github.com/Hack-with-Github/Awesome-Hacking>https://github.com/Hack-with-Github/Awesome-Hacking</a></td><td style=text-align:left>A collection of various awesome lists for hackers</td></tr><tr><td style=text-align:left>awesome-web-hacking</td><td style=text-align:left><a href=https://github.com/infoslack/awesome-web-hacking>https://github.com/infoslack/awesome-web-hacking</a></td><td style=text-align:left>渗透知识</td></tr></tbody></table><h2 id=专利免费查询>专利免费查询</h2><table><thead><tr><th style=text-align:left>仓库名</th><th style=text-align:left>仓库地址</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>专利信息服务平台</strong></td><td style=text-align:left><a href=http://search.cnipr.com/>http://search.cnipr.com/</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>patents</strong></td><td style=text-align:left>&lt;www.google.com/patents></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>incopat</strong></td><td style=text-align:left>&lt;www.incopat.com></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>佰腾</strong></td><td style=text-align:left><a href=https://www.baiten.cn/>https://www.baiten.cn/</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>rainpat</strong></td><td style=text-align:left><a href=https://www.rainpat.com/>https://www.rainpat.com/</a></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>度衍</strong></td><td style=text-align:left><a href=https://www.uyanip.com/>https://www.uyanip.com/</a></td><td style=text-align:left></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-cb9613752bee2e31a2596d114cfa27f0>Windows导览</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> Windows 导览</li></ul><h1 id=windows>Windows</h1><ul><li>[<a href=/blog/2024/06/28/win-to-go/ title=Win-to-go>Win-to-go</a>]</li><li>[<a href=%E7%90%86%E8%A7%A3Windows%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F title=理解Windows文件系统>理解Windows文件系统</a>]</li><li>[<a href=%E7%90%86%E8%A7%A3Windows%E8%BF%9B%E7%A8%8B title=理解Windows进程>理解Windows进程</a>]</li><li>[<a href=/blog/2024/06/28/windows%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/ title=Windows相关资源>Windows相关资源</a>]</li><li>[<a href=Windows%E7%AE%A1%E7%90%86%E8%BF%9B%E9%98%B6 title=Windows管理进阶>Windows管理进阶</a>]</li><li>[<a href=/blog/2024/06/28/windows%E9%98%B2%E7%81%AB%E5%A2%99%E7%AE%A1%E7%90%86-netsh/ title=Windows防火墙管理-netsh>Windows防火墙管理-netsh</a>]</li><li>[<a href=/blog/2024/06/28/windows%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96/ title=Windows阻断网络流量获取>Windows阻断网络流量获取</a>]</li><li>[<a href=../../../%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/Windows%E9%BA%BB%E7%83%A6%E9%97%AE%E9%A2%98 title=Windows麻烦问题>Windows麻烦问题</a>]</li><li>[<a href=/blog/2024/06/28/%E7%90%86%E8%A7%A3windows%E4%BA%8B%E4%BB%B6%E8%B7%9F%E8%B8%AA_etw/ title=理解Windows事件跟踪_ETW>理解Windows事件跟踪_ETW</a>]</li><li>[<a href=/blog/2024/06/28/%E7%90%86%E8%A7%A3windows%E7%BD%91%E7%BB%9C_wfp/ title=理解Windows网络_WFP>理解Windows网络_WFP</a>]</li><li>[<a href=/blog/2024/06/28/windows-ipv6%E7%AE%A1%E7%90%86/ title=windows-ipv6管理>windows-ipv6管理</a>]</li><li>[<a href=/blog/2023/05/06/windows%E6%A1%A5%E6%8E%A5%E6%97%B6%E7%9A%84ipv6%E9%97%AE%E9%A2%98/ title=Windows桥接时的IPv6问题>Windows桥接时的IPv6问题</a>]</li><li>[<a href=/blog/2024/06/28/wireguard%E9%85%8D%E7%BD%AE/ title=wireguard配置>wireguard配置</a>]</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-add85b56bb4af8b5216a8122ebeea317>windows-ipv6管理</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> windows-ipv6管理</li></ul><h1 id=windows-ipv6-管理>windows-ipv6 管理</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps1 data-lang=ps1><span class=line><span class=cl><span class=c># 查看ipv6地址, 过滤locallink地址, 过滤Loopback地址</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetIPAddress</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span> <span class=p>|</span> <span class=nb>Where-Object</span> <span class=p>{</span><span class=nv>$_</span><span class=p>.</span><span class=py>IPAddress</span> <span class=o>-notlike</span> <span class=s2>&#34;fe80*&#34;</span> <span class=o>-and</span> <span class=nv>$_</span><span class=p>.</span><span class=py>IPAddress</span> <span class=o>-notlike</span> <span class=s2>&#34;::1&#34;</span><span class=p>}</span> <span class=p>|</span> <span class=nb>Format-Table</span> <span class=n>-AutoSize</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看ipv6路由</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetRoute</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看ipv6邻居</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetNeighbor</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 查看interface</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetAdapter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 使能临时ipv6地址</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-UseTemporaryAddress</span> <span class=n>Enabled</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 获取interface 信息</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetIPInterface</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span> <span class=n>-ifAlias</span> <span class=n>Ethernet</span> <span class=p>|</span> <span class=nb>Select-Object</span> <span class=n>-Property</span> <span class=p>*</span>
</span></span><span class=line><span class=cl><span class=nb>Get-NetIPv6Protocol</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 设置interface 信息, 解决Windows IPv6地址不更新的问题</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPInterface</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span> <span class=n>-ifAlias</span> <span class=n>Ethernet</span> <span class=n>-Dhcp</span> <span class=n>Disabled</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPInterface</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span> <span class=n>-ifAlias</span> <span class=n>Ethernet</span> <span class=n>-AdvertiseDefaultRoute</span> <span class=n>Disabled</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPInterface</span> <span class=n>-AddressFamily</span> <span class=n>IPv6</span> <span class=n>-ifAlias</span> <span class=n>Ethernet</span> <span class=n>-IgnoreDefaultRoutes</span> <span class=n>Enabled</span>
</span></span><span class=line><span class=cl><span class=c># 手动恢复ipv6访问</span>
</span></span><span class=line><span class=cl><span class=c># Set-NetIPInterface -AddressFamily IPv6 -ifAlias Ethernet -RouterDiscovery Disabled</span>
</span></span><span class=line><span class=cl><span class=c># Set-NetIPInterface -AddressFamily IPv6 -ifAlias Ethernet -RouterDiscovery Enabled</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-DhcpMediaSense</span> <span class=n>Disabled</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-RandomizeIdentifiers</span> <span class=n>Disabled</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-UseTemporaryAddresses</span> <span class=n>Disabled</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-MaxTemporaryDesyncTime</span> <span class=mf>0</span><span class=err>:</span><span class=mf>3</span><span class=err>:</span><span class=mf>0</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-MaxTemporaryPreferredLifetime</span> <span class=mf>0</span><span class=err>:</span><span class=mf>10</span><span class=err>:</span><span class=mf>0</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-MaxTemporaryValidLifetime</span> <span class=mf>0</span><span class=err>:</span><span class=mf>30</span><span class=err>:</span><span class=mf>0</span>
</span></span><span class=line><span class=cl><span class=nb>Set-NetIPv6Protocol</span> <span class=n>-TemporaryRegenerateTime</span> <span class=mf>0</span><span class=err>:</span><span class=mf>0</span><span class=err>:</span><span class=mf>30</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-e9e3d6173c9a65d937dabcb06bfd3085>window-message</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><ul><li><input disabled type=checkbox> window-message</li></ul><h1 id=windows-message>windows-message</h1><ul><li><a href=https://gist.github.com/amgine/2395987>All windows messages as C# enum (github.com)</a></li><li><a href=https://wiki.winehq.org/List_Of_Windows_Messages>List Of Windows Messages - WineHQ Wiki</a></li><li><a href=http://www.pinvoke.net/default.aspx/Constants/WM.html>pinvoke.net: WM (Constants)</a></li><li><a href=http://pinvoke.net/default.aspx/Enums.WindowsMessages>pinvoke.net: WindowsMessages (Enums)</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/winmsg/window-notifications>Window Notifications</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-193faaa62417d666d3091475b953c37f>Win-to-go</h1><div class="td-byline mb-4"><time datetime=2024-06-28 class=text-body-secondary>Friday, June 28, 2024</time></div><p>===</p><p>Windows To Go 的优点在于移动便携性, 缺点在于经典 Windows系统的数个功能受到限制.</p><ul><li><a href=/blog/2024/06/28/win-to-go/#前言>前言</a></li><li><a href=/blog/2024/06/28/win-to-go/#windows-to-go-overview>Windows To Go Overview</a></li><li><a href=/blog/2024/06/28/win-to-go/#windows-to-go-和传统-windows-安装方式的区别>Windows To Go 和传统 Windows 安装方式的区别</a></li><li><a href=/blog/2024/06/28/win-to-go/#使用-windows-to-go-来移动工作>使用 Windows To Go 来移动工作</a></li><li><a href=/blog/2024/06/28/win-to-go/#准备安装-windows-to-go>准备安装 Windows To Go</a></li><li><a href=/blog/2024/06/28/win-to-go/#硬件要求>硬件要求</a></li><li><a href=/blog/2024/06/28/win-to-go/#usb-硬盘或-u盘>USB 硬盘或 U盘</a></li><li><a href=/blog/2024/06/28/win-to-go/#载体机器host-computer>载体机器(Host computer)</a></li><li><a href=/blog/2024/06/28/win-to-go/#检查载体-pc-和-windows-to-go-盘的架构兼容性>检查载体 PC 和 Windows To Go 盘的架构兼容性</a></li><li><a href=/blog/2024/06/28/win-to-go/#windows-to-go-的常见问题>Windows To Go 的常见问题</a></li></ul><h2 id=前言>前言</h2><p>Windows To Go出现很多年了, 可是百度到的中文文档却如此少, 不禁为国内IT技术的发展而担忧.作者J参加工作时间不长, 能力有限, 但工作中接触大量英文开发文档, 因此仍希望能做一点基础的铺路工作, 方便后来者查阅, 有不当之处也请读者不吝指出. Windows To Go有详尽的官方文档, 有英文阅读能力的可以直接跳转到微软官方文档. 链接如下:</p><ul><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-overview>Windows To Go Overview</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/best-practice-recommendations-for-windows-to-go>Best practice recommendations for Windows To Go</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/deployment-considerations-for-windows-to-go>Deployment considerations for Windows To Go</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/prepare-your-organization-for-windows-to-go>Prepare your organization for Windows To Go</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/security-and-data-protection-considerations-for-windows-to-go>Security and data protection considerations for Windows To Go</a></li><li><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-frequently-asked-questions>Windows To Go: frequently asked questions</a></li></ul><p>本文主要会介绍 Overview, 和一些常见问题, 大部分内容为翻译, 少量作者的提醒以[J]来标注直至句号结束, 以确保不误导读者.</p><h2 id=windows-to-go-overview>Windows To Go Overview</h2><p>Windows To Go 是 Windows 企业版和教育版上的功能, 大多数家庭用户使用的家庭版没有此功能. 它使我们能创建从U盘或硬盘启动的便携Windows系统. Windows To Go 并不是创造出来取代传统工作工具的. 它的主要目的是为了使具有经常切换工作空间需求的人更有效率. 在开始使用 Windows To Go 之前, 使用者必须了解以下注意事项:</p><ul><li>Windows To Go 和传统 Windows 安装方式的区别;</li><li>使用 Windows To Go 来移动工作;</li><li>准备安装 Windows To Go;</li><li>硬件要求.</li></ul><h2 id=windows-to-go-和传统-windows-安装方式的区别>Windows To Go 和传统 Windows 安装方式的区别</h2><p>Windows To Go 的工作环境和传统 Windows 几乎一样, 只有以下几点不同:</p><ul><li>除了使用中的U盘, 机器的其它硬盘默认为离线状态. 即在文件管理器里不可见, 这是为了保护数据的安全. [J]但你仍然有方法可以使其它硬盘出现, 并修改里边的文件.</li><li>TPM 信任平台模块不可用. TPM 模块会绑定到特定某台电脑, 以保护商业数据. [J]多数民用电脑没有TPM模块, 但如果你的商用电脑已经加入了公司的域, 最好不要尝试在该电脑上使用 Windows To Go, 否则建议您先准备好下份工作的简历.</li><li>Windows To Go的休眠默认被禁用, 但仍可以通过组策略来打开. [J]很多机器在休眠会断开和USB设备的连接, 导致不能从休眠中恢复, 这很好理解, 微软已经替我们考虑到了这点, 所以没必要去修改这个设置.</li><li>Windows 的恢复(Restore)功能被禁用. 如果系统出现问题, 只能重装Windows了.</li><li>恢复到出厂设置不可用, 重置Windows不可用.</li><li>升级不可用. Windows 只能停留在安装时的版本, 不能从Windows 7 升到8, 也不能从 Windows 10 Red Stone 1 升级到 Red Stone 2.</li></ul><h2 id=使用-windows-to-go-来移动工作>使用 Windows To Go 来移动工作</h2><p>Windows To Go 可以在多台机器之间切换, 系统会自动决定设备启动需要的驱动程序. 有一些和系统硬件强关联的应用可能无法运行. [J]比如Thinkpad触控板的设置程序, 指纹识别设置程序等.</p><h2 id=准备安装-windows-to-go>准备安装 Windows To Go</h2><p>可以使用 <strong>System Center Configuration Manager</strong>, 或者 Windows 的标准部署工具, 例如 <strong>DiskPart</strong>, <strong>Deployment Image Servicing and Management (DISM)</strong>. 需要注意以下问题:</p><ul><li>是否有需要注入到 Windows To Go 镜像的驱动?</li><li>在不同机器上移动工作时时, 怎样合适的存储及同步数据?</li><li>32位还是64位? [J]新的机器都支持64位, 64位处理器的机器也能运行32位系统, 32位处理器不能运行64位的系统, 64位系统运行时占用更大的硬盘空间和内存空间. 如果你需要迁移使用的机器处理器架构有只支持32位的处理器, 或者机器内存少于4G, 建议你使用32位系统.</li><li>从协作网络以外的网络远程连接时的分辨率应该设为多少?</li></ul><h2 id=硬件要求>硬件要求</h2><h3 id=usb-硬盘或-u盘>USB 硬盘或 U盘</h3><p>Windows To Go针对以下列出的设备已做出了特别优化来满足需求, 包括</p><ul><li>优化USB设备的高随机读写, 以使日常操作更流畅.</li><li>在已认证的设备上可以启动Windows 7及后续系统.</li><li>即使运行Windows To Go, USB设备也享受原厂保修支持. [J]没说插U盘的电脑会享受保修.</li></ul><p>没有通过认证的 USB 设备, 不支持使用 Windows To Go. [J]能不能使用试试就知道了, 不行也知道是为什么. [J]同时网上有修改 U 盘厂商和型号来达到强制支持的另类方法, 不做赘述.</p><h3 id=载体机器host-computer>载体机器(Host computer)</h3><ul><li>认证支持Windows 7及后续系统.</li><li>运行Windows RT系统的电脑不受支持.</li><li>苹果Mac电脑不受支持. [J]尽管网络上遍布谈Windows To Go在Mac上运行的体验, 但官方文档明确说了, 不支持Mac的使用场景.</li></ul><p>以下列出载体电脑的最低配置.</p><table><thead><tr><th>Item</th><th>Requirement</th></tr></thead><tbody><tr><td>启动方式</td><td>可以USB启动</td></tr><tr><td>固件</td><td>从USB启动的设置打开</td></tr><tr><td>处理器架构</td><td>必须支持Windows To Go</td></tr><tr><td>外置USB Hub</td><td>不支持. Windows To Go 设备必须直接接在载体电脑上</td></tr><tr><td>处理器</td><td>1GHz以上</td></tr><tr><td>RAM</td><td>2 GB以上</td></tr><tr><td>显卡</td><td>有WDDM1.2的DirectX 9及以上</td></tr><tr><td>USB端口</td><td>USB 2.0及以上</td></tr></tbody></table><h3 id=检查载体-pc-和-windows-to-go-盘的架构兼容性>检查载体 PC 和 Windows To Go 盘的架构兼容性</h3><table><thead><tr><th>Host PC Firmware Type</th><th>Host PC Processor Architecture</th><th>Compatible Windows To Go Image Architecture</th></tr></thead><tbody><tr><td>Legacy BIOS</td><td>32-bit</td><td>32-bit only</td></tr><tr><td>Legacy BIOS</td><td>64-bit</td><td>32-bit and 64-bit</td></tr><tr><td>UEFI BIOS</td><td>32-bit</td><td>32-bit only</td></tr><tr><td>UEFI BIOS</td><td>64-bit</td><td>64-bit only</td></tr></tbody></table><h2 id=windows-to-go-的常见问题>Windows To Go 的常见问题</h2><p><a href=https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-frequently-asked-questions>Windows To Go: frequently asked questions</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-98d47cdc0b45fd5888633472125c6bce>设计模式究竟有几个原则</h1><div class="td-byline mb-4"><time datetime=2024-05-16 class=text-body-secondary>Thursday, May 16, 2024</time></div><p>最早总结的设计模式只有 5 个, 即<code>SOLID</code>:</p><ul><li><code>单一职责原则 (Single Responsibility Principle, SRP)</code>：一个类应该只有一个引起变化的原因，即一个类应该只有一个责任。</li><li><code>开闭原则 (Open/Closed Principle, OCP)</code>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭，即应该通过扩展来实现变化，而不是通过修改已有的代码。</li><li><code>里氏替换原则 (Liskov Substitution Principle, LSP)</code>：子类型必须能够替换其基类型，即派生类必须能够替换其基类而不影响程序的正确性。</li><li><code>接口隔离原则 (Interface Segregation Principle, ISP)</code>：不应该强迫客户端依赖于它们不使用的接口。应该将大接口拆分成更小的、更具体的接口，以便客户端只需知道它们需要使用的方法。</li><li><code>依赖倒置原则 (Dependency Inversion Principle, DIP)</code>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象。</li></ul><p>后来增加了两个规则, 这些后加的规则相较来说更具体, 更有指导性. 我们从原则解释中可以看到<code>SOLID</code>描述<code>应该怎么做</code>, 后加的规则描述<code>优先/最好怎么做</code>.</p><ul><li><code>合成/聚合复用原则 (Composition/Aggregation Reuse Principle, CARP)</code>：应该优先使用对象组合（合成）和聚合，而不是继承来达到代码复用的目的。</li><li><code>迪米特法则 (Law of Demeter, LoD)</code>：一个对象应该对其他对象有尽可能少的了解，即一个对象应该对其它对象的内部结构和实现细节知道得越少越好。</li></ul><p>除了上述提到的常见设计原则外，还有一些其他的设计原则，虽然不如前面提到的那些广为人知，但同样对软件设计和架构有重要的指导作用。
后续提出的这些规则, 有点画蛇添足, 至少我认为它们不反直觉, 不需要深入思考.</p><ul><li><code>最少知识原则 (Principle of Least Knowledge, PoLK)</code>：也被称为迪米特法则的扩展，主张一个对象应该尽可能少地了解其他对象的信息。这个原则的产生可以追溯到 1987 年由帕特里夏·莱塞尔（Patricia Lago）和科威特·伯克（Koos Visser）提出的“最少通信法则”。</li><li><code>稳定依赖原则 (Stable Dependencies Principle, SDP)</code>：该原则认为软件设计应该确保稳定的组件不依赖于不稳定的组件，即稳定性较高的组件应该更少地依赖于稳定性较低的组件。这个原则的思想来源于对软件系统中组件之间关系的深入研究。</li><li><code>稳定抽象原则 (Stable Abstraction Principle, SAP)</code>：与稳定依赖原则相呼应，该原则指导着将抽象性与稳定性相匹配，即稳定的组件应该是抽象的，而不稳定的组件应该是具体的。这个原则有助于确保软件系统的稳定性和灵活性。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-05350a194e913f1a0ae82c3a0ad530da>多平台内容发布工具--蚁小二体验</h1><div class="td-byline mb-4"><time datetime=2024-05-09 class=text-body-secondary>Thursday, May 09, 2024</time></div><h2 id=前言>前言</h2><p>最近想写点东西扩展下收入类别, 四处调研了下创作者平台, 看看是否能靠文字赚点钱, 实在不行赚点金币也是好的.</p><p>先不论具体的平台, 写东西多少是要费点脑子的, 文章生产不易, 自然不会只投一个平台, 如果需要发布多个平台, 则会涉及一件比较令人厌烦的事, 那就是同一件事需要重复做多次.</p><p>如果各平台都支持外链, 支持 markdown 格式, 简单的复制粘贴倒也不会太令人苦恼. 但实际情况是, 很多平台都不支持 markdown 文件导入, 但好消息是它们都支持 word 导入. 可以 md 转 docx, 再 docx 导入.</p><p>另外在多个平台发文, 还需要在各自的发布页面操作, 我希望的是可以批量操作. 搜索的时候找到了<code>蚁小二</code>这样一个工具, 请放心这不是带货, 如果这东西确实能给我带来很多价值的话, 我自然会审慎而吝啬的决定是否要分享. 既然我分享出来了, 就代表我对它带来的价值存疑.</p><h2 id=支持的平台>支持的平台</h2><p><img src=https://s2.loli.net/2024/06/20/NGdJbYPmKFsu6MX.png></p><p>可以一键发布内容到多个平台, 我所使用的免费版支持添加五个账号, 由于我是文字创作, 五个账号已经足够了. 如果是视频创作者, 这个工具或许可以帮上许多忙.</p><h2 id=文字自媒体体验>文字自媒体体验</h2><p>视频部分由于我完全不会做视频, 就暂且不分享体验了, 下面仅就自媒体平台体验做一些分享.</p><p><img src=https://s2.loli.net/2024/06/20/unKh5tRUSXyCDsx.png></p><ul><li>创作界面可以参考常见的 word 编辑器, 包含段落, 加粗, 引用, 下划线, 删除线, 斜体, 分割线, 缩进, 图片</li><li>不支持超链接</li><li>不支持表格</li><li>没有 markdown, 可以通过在 vscode 的 mardown 预览中拷贝粘贴实现了一些格式的保留</li><li>抽象支持多个平台</li><li>抽象支持平台多个账号</li></ul><p><em>一键发布</em>, 不得不说体验还可以, 但是我想看到文章反馈还是得去各平台查看.</p><p><img src=https://s2.loli.net/2024/06/20/H2ARnQ6FCwNYLjS.png></p><p>平时不太看这些自媒体, 因为质量着实不高, 现在看其实门槛也不高, 未来我也将会在这些平台上发布一些内容, 敬请期待.</p><p>这是我第一次使用这个工具, 我并不是专家, 不知道发什么能赚钱, 也不知道收入如何, 如果有大佬, 诚心请教指点一二, 不胜感激.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-07009eb0faa2af68d3ead7fafed15c12>简书的创作体验</h1><div class="td-byline mb-4"><time datetime=2024-05-09 class=text-body-secondary>Thursday, May 09, 2024</time></div><p>简书的写文章体验仅强于记事本.</p><h2 id=笔记管理简洁>笔记管理简洁</h2><p>这是文章编辑页面, 仅两层抽象,</p><ul><li>笔记本列表</li><li>笔记列表</li><li>编辑器</li></ul><p><img src=https://s2.loli.net/2024/05/09/QaCNwOghDi6b7xu.png></p><p>层级少有好处也有坏处, 简单的操作可以减低理解成本. 但会在将来增加作者的文章管理成本.</p><h2 id=图片上传困难>图片上传困难</h2><p><strong>简书在长达 8 年的时间里仍然没有处理好外链图片上传问题</strong></p><p><img alt=https://www.jianshu.com/p/acb660ddc619 src=https://s2.loli.net/2024/05/09/nxkTBGpo3KDjtsh.png></p><p>外链只是有时会失败, 许多图床是允许空 reffer 或任意 reffer 获取的, 简书试都不试下, 还称本地上传是"正确"的图片上传方式, 不知道运营者有没有试过别的平台的创作体验.</p><p>很难相信会有作者只深耕一个平台, 平台如果不能让创作者方便的复制粘贴, 只能一直走小众路线.</p><h2 id=没有审核>没有审核</h2><p>简书似乎不怎么审核, 从未看到过审核状态, 文章发出即可阅. 如果一个平台不怎么审核的话, 或许我们可以这样那样&mldr;</p><h2 id=随机-ip-属地>随机 IP 属地</h2><p>简书实际没有实现 IP 属地, IP 地址刷新即随机更新.</p></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Telegram aria-label=Telegram><a target=_blank rel=noopener href=https://t.me/jqknono aria-label=Telegram><i class="fab fa-telegram"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/jqknono aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/jqknono aria-label="User mailing list"><i class=envelope></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2015&ndash;2025
<span class=td-footer__authors>jqknono</span></span><span class=td-footer__all_rights_reserved>保留所有权利</span></div></div></div></footer></div><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script><script src=/js/deflate.js></script><script src=/js/main.min.42f4b5e8a33d07cac902f216175a2b5b3e99803be04f32b17af7fbe17183051a.js integrity="sha256-QvS16KM9B8rJAvIWF1orWz6ZgDvgTzKxevf74XGDBRo=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>